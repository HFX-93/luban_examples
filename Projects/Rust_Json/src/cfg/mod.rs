
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

pub struct LoadError {

}

impl std::fmt::Debug for LoadError {
    fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> { Ok(()) }
}

#[allow(dead_code)]
pub struct Vector2 {
    pub x:f32,
    pub y:f32,
}

impl Vector2 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector2, LoadError> {
        Ok(Vector2{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}

#[allow(dead_code)]
pub struct Vector3 {
    pub x:f32,
    pub y:f32,
    pub z:f32,
}

impl Vector3 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector3, LoadError> {
        Ok(Vector3{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            z: match __js["z"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}

#[allow(dead_code)]
pub struct Vector4 {
    pub x:f32,
    pub y:f32,
    pub z:f32,
    pub w:f32,
}


impl Vector4 {
    pub fn new(__js:&json::JsonValue) -> Result<Vector4, LoadError> {
        Ok(Vector4{
            x:  match __js["x"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            z: match __js["z"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
            w: match __js["w"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{})},
         })
    }
}
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_EExecutor {
    CLIENT = 0,
    SERVER = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS = 8,
    ENUM = 9,
    OBJECT = 10,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Ai_EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Common_EBoolOperator {
    AND = 0,
    OR = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Error_EOperation {
    /**
     * 登出
     */
    LOGOUT = 0,
    /**
     * 重启
     */
    RESTART = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Error_EErrorCode {
    OK = 0,
    SERVER_NOT_EXISTS = 1,
    HAS_BIND_SERVER = 2,
    AUTH_FAIL = 3,
    NOT_BIND_SERVER = 4,
    SERVER_ACCESS_FAIL = 5,
    EXAMPLE_FLASH = 6,
    EXAMPLE_MSGBOX = 7,
    EXAMPLE_DLG_OK = 8,
    EXAMPLE_DLG_OK_CANCEL = 9,
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    ROLE_CREATE_NAME_EMPTY = 101,
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    ROLE_CREATE_INVALID_PROFESSION = 104,
    ROLE_CREATE_INVALID_GENDER = 105,
    ROLE_NOT_OWNED_BY_USER = 106,
    ROLE_LEVEL_NOT_ARRIVE = 107,
    PARAM_ILLEGAL = 200,
    TEMP_BAG_NOT_EMPTY = 201,
    ITEM_CAN_NOT_USE = 202,
    CURRENCY_NOT_ENOUGH = 203,
    BAG_IS_FULL = 204,
    ITEM_NOT_ENOUGH = 205,
    ITEM_IN_BAG = 206,
    GENDER_NOT_MATCH = 300,
    LEVEL_TOO_LOW = 301,
    LEVEL_TOO_HIGH = 302,
    EXCEED_LIMIT = 303,
    OVER_TIME = 304,
    SERVER_ERROR = 305,
    SKILL_NOT_IN_LIST = 400,
    SKILL_NOT_COOLDOWN = 401,
    SKILL_TARGET_NOT_EXIST = 402,
    SKILL_ANOTHER_CASTING = 403,
    SKILL_OUT_OF_DISTANCE = 404,
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    SKILL_INVALID_DIRECTION = 406,
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    SKILL_ENERGY_NOT_ENOUGH = 408,
    DIALOG_NODE_NOT_CHOOSEN = 500,
    DIALOG_NOT_FINISH = 501,
    DIALOG_HAS_FINISH = 502,
    QUEST_STAGE_NOT_FINISHED = 503,
    QUEST_NOT_DOING = 504,
    QUEST_STAGE_NOT_DOING = 505,
    QUEST_HAS_ACCEPTED = 506,
    MAP_OBJECT_NOT_EXIST = 600,
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    HAS_NOT_EQUIP = 602,
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    NOT_AVAILABLE_SUIT_ID = 604,
    NO_INTERACTION_COMPONENT = 605,
    HAS_INTERACTED = 606,
    VIALITY_NOT_ENOUGH = 607,
    PLAYER_SESSION_NOT_EXIST = 608,
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    MAP_NOT_EXIST = 610,
    MAIL_TYPE_ERROR = 700,
    MAIL_NOT_EXITST = 701,
    MAIL_HAVE_DELETED = 702,
    MAIL_AWARD_HAVE_RECEIVED = 703,
    MAIL_OPERATE_TYPE_ERROR = 704,
    MAIL_CONDITION_NOT_MEET = 705,
    MAIL_STATE_ERROR = 706,
    MAIL_NO_AWARD = 707,
    MAIL_BOX_IS_FULL = 708,
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    NOT_WEAR_CLOTHES = 801,
    NOT_WEAR_SUIT = 802,
    SUIT_NOT_UNLOCK = 900,
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    SUIT_STATE_ERROR = 902,
    SUIT_COMPONENT_STATE_ERROR = 903,
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    STORE_NOT_ENABLED = 1000,
    SHELF_NOT_ENABLED = 1001,
    GOODS_NOT_ENABLED = 1002,
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    RETRY = 1100,
    NOT_COOLDOWN = 1101,
    SELFIE_UNLOCK = 1200,
    SELFIE_ALREADY_UNLOCK = 1201,
    SELFIE_LACK_STARTS = 1202,
    SELFIE_HAD_REWARD = 1203,
}


/**
 * 道具品质
 */
#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EItemQuality {
    /**
     * 白
     */
    WHITE = 0,
    /**
     * 绿
     */
    GREEN = 1,
    /**
     * 蓝
     */
    BLUE = 2,
    /**
     * 紫
     */
    PURPLE = 3,
    /**
     * 金
     */
    GOLDEN = 4,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_ECurrencyType {
    /**
     * 钻石
     */
    DIAMOND = 1,
    /**
     * 金币
     */
    GOLD = 2,
    /**
     * 银币
     */
    SILVER = 3,
    /**
     * 经验
     */
    EXP = 4,
    /**
     * 能量点
     */
    POWER_POINT = 5,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EMajorType {
    /**
     * 货币
     */
    CURRENCY = 1,
    /**
     * 服装
     */
    CLOTH = 2,
    /**
     * 任务
     */
    QUEST = 3,
    /**
     * 消耗品
     */
    CONSUMABLES = 4,
    /**
     * 宝箱
     */
    TREASURE_BOX = 5,
    /**
     * 成就和称谓
     */
    ACHIEVEMENT_AND_TITLE = 6,
    /**
     * 头像框
     */
    HEAD_FRAME = 7,
    /**
     * 语音
     */
    VOICE = 8,
    /**
     * 动作
     */
    ACTION = 9,
    /**
     * 扩容道具
     */
    EXPANSION = 10,
    /**
     * 制作材料
     */
    MATERIAL = 11,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EMinorType {
    /**
     * 钻石
     */
    DIAMOND = 101,
    /**
     * 金币
     */
    GOLD = 102,
    /**
     * 银币
     */
    SILVER = 103,
    /**
     * 经验
     */
    EXP = 104,
    /**
     * 能量点
     */
    POWER_POINT = 105,
    /**
     * 发型
     */
    HAIR_STYLE = 210,
    /**
     * 外套
     */
    COAT = 220,
    /**
     * 上衣
     */
    UPPER_JACKET = 230,
    /**
     * 裤子
     */
    TROUSERS = 241,
    /**
     * 裙子
     */
    SKIRT = 242,
    /**
     * 袜子
     */
    SOCKS = 250,
    /**
     * 鞋子
     */
    SHOES = 260,
    /**
     * 发饰
     */
    HAIR_ACCESSORY = 271,
    /**
     * 帽子
     */
    HAT = 272,
    /**
     * 耳饰
     */
    EARRING = 273,
    /**
     * 颈饰
     */
    NECKLACE = 274,
    /**
     * 腕饰
     */
    BRACELET = 275,
    /**
     * 发箍
     */
    HAIR_CLASP = 276,
    /**
     * 手套
     */
    GLOVE = 277,
    /**
     * 手持物
     */
    HANDHELD_OBJECT = 278,
    /**
     * 特殊
     */
    SPECIAL = 279,
    /**
     * 底妆
     */
    BASE_COSMETIC = 281,
    /**
     * 眉妆
     */
    EYEBROW_COSMETIC = 282,
    /**
     * 睫毛
     */
    EYELASH = 283,
    /**
     * 美瞳
     */
    COSMETIC_CONTACT_LENSES = 284,
    /**
     * 唇妆
     */
    LIP_COSMETIC = 285,
    /**
     * 肤色
     */
    SKIN_COLOR = 286,
    /**
     * 连衣裙
     */
    ONE_PIECE_DRESS = 290,
    /**
     * 换装场景
     */
    SWITCH_CLOTHES_SCENE = 291,
    /**
     * 任务道具
     */
    QUEST = 301,
    /**
     * 投掷物
     */
    CAST = 401,
    /**
     * 刀剑
     */
    SWORD = 421,
    /**
     * 弓箭
     */
    BOW_ARROW = 422,
    /**
     * 法杖
     */
    WANDS = 423,
    /**
     * 特殊工具
     */
    SPECIAL_TOOL = 424,
    /**
     * 食物
     */
    FOOD = 403,
    /**
     * 宝箱
     */
    TREASURE_BOX = 501,
    /**
     * 钥匙
     */
    KEY = 502,
    /**
     * 多选一宝箱
     */
    MULTI_CHOOSE_TREASURE_BOX = 503,
    /**
     * 成就相关
     */
    ACHIEVEMENT = 601,
    /**
     * 称谓相关
     */
    TITLE = 602,
    /**
     * 头像框
     */
    AVATAR_FRAME = 701,
    /**
     * 语音
     */
    VOICE = 801,
    /**
     * 特殊待机动作
     */
    IDLE_POSE = 901,
    /**
     * 拍照动作
     */
    PHOTO_POSE = 902,
    /**
     * 背包
     */
    BAG = 1001,
    /**
     * 好友数量
     */
    FRIEND_CAPACITY = 1002,
    /**
     * 制作材料
     */
    CONSTRUCTION_MATERIAL = 1101,
    /**
     * 设计图纸
     */
    DESIGN_DRAWING = 1102,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EClothersStarQualityType {
    /**
     * 一星
     */
    ONE = 1,
    /**
     * 二星
     */
    TWO = 2,
    /**
     * 三星
     */
    THREE = 3,
    /**
     * 四星
     */
    FOUR = 4,
    /**
     * 五星
     */
    FIVE = 5,
    /**
     * 六星
     */
    SIX = 6,
    /**
     * 七星
     */
    SEVEN = 7,
    /**
     * 八星
     */
    EIGHT = 8,
    /**
     * 九星
     */
    NINE = 9,
    /**
     * 十星
     */
    TEN = 10,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EClothersTag {
    /**
     * 防晒
     */
    FANG_SHAI = 1,
    /**
     * 舞者
     */
    WU_ZHE = 2,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EUseType {
    /**
     * 手动
     */
    MANUAL = 0,
    /**
     * 自动
     */
    AUTO = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EClothesHidePartType {
    /**
     * 胸部
     */
    CHEST = 0,
    /**
     * 手
     */
    HEAD = 1,
    /**
     * 脊柱上
     */
    SPINE_UPPER = 2,
    /**
     * 脊柱下
     */
    SPINE_LOWER = 3,
    /**
     * 臀部
     */
    HIP = 4,
    /**
     * 腿上
     */
    LEG_UPPER = 5,
    /**
     * 腿中
     */
    LEG_MIDDLE = 6,
    /**
     * 腿下
     */
    LEG_LOWER = 7,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EClothesPropertyType {
    /**
     * 简约
     */
    JIAN_YUE = 1,
    /**
     * 华丽
     */
    HUA_LI = 2,
    /**
     * 可爱
     */
    KE_AI = 3,
    /**
     * 成熟
     */
    CHENG_SHU = 4,
    /**
     * 活泼
     */
    HUO_PO = 5,
    /**
     * 优雅
     */
    YOU_YA = 6,
    /**
     * 清纯
     */
    QING_CHUN = 7,
    /**
     * 性感
     */
    XING_GAN = 8,
    /**
     * 清凉
     */
    QING_LIANG = 9,
    /**
     * 保暖
     */
    BAO_NUAN = 10,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Item_EItemFunctionType {
    /**
     * 更换手持物
     */
    REPLACE_HANDHELD = 0,
    /**
     * 使用设计图纸
     */
    USE_DESIGN_DRAWING = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Limit_ENamespace {
    ITEM_DAILY_OBTAIN = 1,
    TREASURE_DAILY_USE = 2,
    STORE_GOODS_LIMIT_BUY = 3,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Mail_EMailType {
    /**
     * 全局邮件
     */
    GLOBAL = 0,
    /**
     * 系统邮件
     */
    SYSTEM = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Role_EGenderType {
    /**
     * 男
     */
    MALE = 1,
    /**
     * 女
     */
    FEMALE = 2,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Role_EProfession {
    TEST_PROFESSION = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_DemoEnum {
    /**
     * aa
     */
    A = 1,
    /**
     * bb
     */
    B = 2,
    /**
     * cc
     */
    C = 4,
    /**
     * dd
     */
    D = 5,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_DemoFlag {
    A = 1,
    B = 2,
    D = 3,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_ETestUeType {
    /**
     * 白
     */
    WHITE = 0,
    BLACK = 1,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_ETestEmptyEnum {
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_ETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_ETestQuality {
    /**
     * 最高品质
     */
    A = 1,
    /**
     * 黑色的
     */
    B = 2,
    /**
     * 蓝色的
     */
    C = 3,
    /**
     * 最差品质
     */
    D = 4,
}


#[allow(dead_code)]
#[allow(non_camel_case_types)]
pub enum Test_ETestCurrency {
    /**
     * 重要
     */
    DIAMOND = 1,
    /**
     * 有用
     */
    GOLD = 2,
}



#[allow(non_camel_case_types)]
pub struct Ai_TbBlackboard {
    data_list: Vec<std::rc::Rc<Ai_Blackboard>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<Ai_Blackboard>>,
}

impl Ai_TbBlackboard{
    pub fn new(__js: &json::JsonValue) -> Result<Ai_TbBlackboard, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Ai_TbBlackboard {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Ai_Blackboard::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.name.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Ai_TbBlackboard) -> &std::collections::HashMap<String, std::rc::Rc<Ai_Blackboard>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Ai_TbBlackboard) -> &Vec<std::rc::Rc<Ai_Blackboard>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Ai_TbBlackboard, key: &String) -> std::option::Option<&std::rc::Rc<Ai_Blackboard>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Ai_Blackboard {
pub name: String,
pub desc: String,
pub parent_name: String,
pub keys: Vec<Ai_BlackboardKey>,
}

impl Ai_Blackboard {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Blackboard, LoadError> {
        let __b = Ai_Blackboard {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parent_name: match __js["parent_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            keys: { if !__js["keys"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["keys"].members() { __list__.push(Ai_BlackboardKey::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_BlackboardKey {
pub name: String,
pub desc: String,
pub is_static: bool,
pub r#type: i32,
pub type_class_name: String,
}

impl Ai_BlackboardKey {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_BlackboardKey, LoadError> {
        let __b = Ai_BlackboardKey {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            type_class_name: match __js["type_class_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Ai_TbBehaviorTree {
    data_list: Vec<std::rc::Rc<Ai_BehaviorTree>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Ai_BehaviorTree>>,
}

impl Ai_TbBehaviorTree{
    pub fn new(__js: &json::JsonValue) -> Result<Ai_TbBehaviorTree, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Ai_TbBehaviorTree {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Ai_BehaviorTree::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Ai_TbBehaviorTree) -> &std::collections::HashMap<i32, std::rc::Rc<Ai_BehaviorTree>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Ai_TbBehaviorTree) -> &Vec<std::rc::Rc<Ai_BehaviorTree>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Ai_TbBehaviorTree, key: &i32) -> std::option::Option<&std::rc::Rc<Ai_BehaviorTree>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Ai_BehaviorTree {
pub id: i32,
pub name: String,
pub desc: String,
pub blackboard_id: String,
pub root: Ai_ComposeNode,
}

impl Ai_BehaviorTree {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_BehaviorTree, LoadError> {
        let __b = Ai_BehaviorTree {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            blackboard_id: match __js["blackboard_id"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            root: Ai_ComposeNode::new(&__js["root"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_Node {
  UeSetDefaultFocus(Box<Ai_UeSetDefaultFocus>),
  ExecuteTimeStatistic(Box<Ai_ExecuteTimeStatistic>),
  ChooseTarget(Box<Ai_ChooseTarget>),
  KeepFaceTarget(Box<Ai_KeepFaceTarget>),
  GetOwnerPlayer(Box<Ai_GetOwnerPlayer>),
  UpdateDailyBehaviorProps(Box<Ai_UpdateDailyBehaviorProps>),
  UeLoop(Box<Ai_UeLoop>),
  UeCooldown(Box<Ai_UeCooldown>),
  UeTimeLimit(Box<Ai_UeTimeLimit>),
  UeBlackboard(Box<Ai_UeBlackboard>),
  UeForceSuccess(Box<Ai_UeForceSuccess>),
  IsAtLocation(Box<Ai_IsAtLocation>),
  DistanceLessThan(Box<Ai_DistanceLessThan>),
  Sequence(Box<Ai_Sequence>),
  Selector(Box<Ai_Selector>),
  SimpleParallel(Box<Ai_SimpleParallel>),
  UeWait(Box<Ai_UeWait>),
  UeWaitBlackboardTime(Box<Ai_UeWaitBlackboardTime>),
  MoveToTarget(Box<Ai_MoveToTarget>),
  ChooseSkill(Box<Ai_ChooseSkill>),
  MoveToRandomLocation(Box<Ai_MoveToRandomLocation>),
  MoveToLocation(Box<Ai_MoveToLocation>),
  DebugPrint(Box<Ai_DebugPrint>),
}

impl Ai_Node {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Node, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeSetDefaultFocus" => Ai_Node::UeSetDefaultFocus(Box::new(Ai_UeSetDefaultFocus::new(&__js)?)),
                "ExecuteTimeStatistic" => Ai_Node::ExecuteTimeStatistic(Box::new(Ai_ExecuteTimeStatistic::new(&__js)?)),
                "ChooseTarget" => Ai_Node::ChooseTarget(Box::new(Ai_ChooseTarget::new(&__js)?)),
                "KeepFaceTarget" => Ai_Node::KeepFaceTarget(Box::new(Ai_KeepFaceTarget::new(&__js)?)),
                "GetOwnerPlayer" => Ai_Node::GetOwnerPlayer(Box::new(Ai_GetOwnerPlayer::new(&__js)?)),
                "UpdateDailyBehaviorProps" => Ai_Node::UpdateDailyBehaviorProps(Box::new(Ai_UpdateDailyBehaviorProps::new(&__js)?)),
                "UeLoop" => Ai_Node::UeLoop(Box::new(Ai_UeLoop::new(&__js)?)),
                "UeCooldown" => Ai_Node::UeCooldown(Box::new(Ai_UeCooldown::new(&__js)?)),
                "UeTimeLimit" => Ai_Node::UeTimeLimit(Box::new(Ai_UeTimeLimit::new(&__js)?)),
                "UeBlackboard" => Ai_Node::UeBlackboard(Box::new(Ai_UeBlackboard::new(&__js)?)),
                "UeForceSuccess" => Ai_Node::UeForceSuccess(Box::new(Ai_UeForceSuccess::new(&__js)?)),
                "IsAtLocation" => Ai_Node::IsAtLocation(Box::new(Ai_IsAtLocation::new(&__js)?)),
                "DistanceLessThan" => Ai_Node::DistanceLessThan(Box::new(Ai_DistanceLessThan::new(&__js)?)),
                "Sequence" => Ai_Node::Sequence(Box::new(Ai_Sequence::new(&__js)?)),
                "Selector" => Ai_Node::Selector(Box::new(Ai_Selector::new(&__js)?)),
                "SimpleParallel" => Ai_Node::SimpleParallel(Box::new(Ai_SimpleParallel::new(&__js)?)),
                "UeWait" => Ai_Node::UeWait(Box::new(Ai_UeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => Ai_Node::UeWaitBlackboardTime(Box::new(Ai_UeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => Ai_Node::MoveToTarget(Box::new(Ai_MoveToTarget::new(&__js)?)),
                "ChooseSkill" => Ai_Node::ChooseSkill(Box::new(Ai_ChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => Ai_Node::MoveToRandomLocation(Box::new(Ai_MoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => Ai_Node::MoveToLocation(Box::new(Ai_MoveToLocation::new(&__js)?)),
                "DebugPrint" => Ai_Node::DebugPrint(Box::new(Ai_DebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_Service {
  UeSetDefaultFocus(Box<Ai_UeSetDefaultFocus>),
  ExecuteTimeStatistic(Box<Ai_ExecuteTimeStatistic>),
  ChooseTarget(Box<Ai_ChooseTarget>),
  KeepFaceTarget(Box<Ai_KeepFaceTarget>),
  GetOwnerPlayer(Box<Ai_GetOwnerPlayer>),
  UpdateDailyBehaviorProps(Box<Ai_UpdateDailyBehaviorProps>),
}

impl Ai_Service {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Service, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeSetDefaultFocus" => Ai_Service::UeSetDefaultFocus(Box::new(Ai_UeSetDefaultFocus::new(&__js)?)),
                "ExecuteTimeStatistic" => Ai_Service::ExecuteTimeStatistic(Box::new(Ai_ExecuteTimeStatistic::new(&__js)?)),
                "ChooseTarget" => Ai_Service::ChooseTarget(Box::new(Ai_ChooseTarget::new(&__js)?)),
                "KeepFaceTarget" => Ai_Service::KeepFaceTarget(Box::new(Ai_KeepFaceTarget::new(&__js)?)),
                "GetOwnerPlayer" => Ai_Service::GetOwnerPlayer(Box::new(Ai_GetOwnerPlayer::new(&__js)?)),
                "UpdateDailyBehaviorProps" => Ai_Service::UpdateDailyBehaviorProps(Box::new(Ai_UpdateDailyBehaviorProps::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeSetDefaultFocus {
pub id: i32,
pub node_name: String,
pub keyboard_key: String,
}

impl Ai_UeSetDefaultFocus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeSetDefaultFocus, LoadError> {
        let __b = Ai_UeSetDefaultFocus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            keyboard_key: match __js["keyboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_ExecuteTimeStatistic {
pub id: i32,
pub node_name: String,
}

impl Ai_ExecuteTimeStatistic {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_ExecuteTimeStatistic, LoadError> {
        let __b = Ai_ExecuteTimeStatistic {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_ChooseTarget {
pub id: i32,
pub node_name: String,
pub result_target_key: String,
}

impl Ai_ChooseTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_ChooseTarget, LoadError> {
        let __b = Ai_ChooseTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            result_target_key: match __js["result_target_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_KeepFaceTarget {
pub id: i32,
pub node_name: String,
pub target_actor_key: String,
}

impl Ai_KeepFaceTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_KeepFaceTarget, LoadError> {
        let __b = Ai_KeepFaceTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_GetOwnerPlayer {
pub id: i32,
pub node_name: String,
pub player_actor_key: String,
}

impl Ai_GetOwnerPlayer {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_GetOwnerPlayer, LoadError> {
        let __b = Ai_GetOwnerPlayer {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            player_actor_key: match __js["player_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UpdateDailyBehaviorProps {
pub id: i32,
pub node_name: String,
pub satiety_key: String,
pub energy_key: String,
pub mood_key: String,
pub satiety_lower_threshold_key: String,
pub satiety_upper_threshold_key: String,
pub energy_lower_threshold_key: String,
pub energy_upper_threshold_key: String,
pub mood_lower_threshold_key: String,
pub mood_upper_threshold_key: String,
}

impl Ai_UpdateDailyBehaviorProps {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UpdateDailyBehaviorProps, LoadError> {
        let __b = Ai_UpdateDailyBehaviorProps {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_key: match __js["satiety_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_key: match __js["energy_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_key: match __js["mood_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_lower_threshold_key: match __js["satiety_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            satiety_upper_threshold_key: match __js["satiety_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_lower_threshold_key: match __js["energy_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            energy_upper_threshold_key: match __js["energy_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_lower_threshold_key: match __js["mood_lower_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            mood_upper_threshold_key: match __js["mood_upper_threshold_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_Decorator {
  UeLoop(Box<Ai_UeLoop>),
  UeCooldown(Box<Ai_UeCooldown>),
  UeTimeLimit(Box<Ai_UeTimeLimit>),
  UeBlackboard(Box<Ai_UeBlackboard>),
  UeForceSuccess(Box<Ai_UeForceSuccess>),
  IsAtLocation(Box<Ai_IsAtLocation>),
  DistanceLessThan(Box<Ai_DistanceLessThan>),
}

impl Ai_Decorator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Decorator, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeLoop" => Ai_Decorator::UeLoop(Box::new(Ai_UeLoop::new(&__js)?)),
                "UeCooldown" => Ai_Decorator::UeCooldown(Box::new(Ai_UeCooldown::new(&__js)?)),
                "UeTimeLimit" => Ai_Decorator::UeTimeLimit(Box::new(Ai_UeTimeLimit::new(&__js)?)),
                "UeBlackboard" => Ai_Decorator::UeBlackboard(Box::new(Ai_UeBlackboard::new(&__js)?)),
                "UeForceSuccess" => Ai_Decorator::UeForceSuccess(Box::new(Ai_UeForceSuccess::new(&__js)?)),
                "IsAtLocation" => Ai_Decorator::IsAtLocation(Box::new(Ai_IsAtLocation::new(&__js)?)),
                "DistanceLessThan" => Ai_Decorator::DistanceLessThan(Box::new(Ai_DistanceLessThan::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeLoop {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub num_loops: i32,
pub infinite_loop: bool,
pub infinite_loop_timeout_time: f32,
}

impl Ai_UeLoop {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeLoop, LoadError> {
        let __b = Ai_UeLoop {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num_loops: match __js["num_loops"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            infinite_loop: match __js["infinite_loop"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            infinite_loop_timeout_time: match __js["infinite_loop_timeout_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeCooldown {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub cooldown_time: f32,
}

impl Ai_UeCooldown {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeCooldown, LoadError> {
        let __b = Ai_UeCooldown {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cooldown_time: match __js["cooldown_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeTimeLimit {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub limit_time: f32,
}

impl Ai_UeTimeLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeTimeLimit, LoadError> {
        let __b = Ai_UeTimeLimit {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            limit_time: match __js["limit_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeBlackboard {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub notify_observer: i32,
pub blackboard_key: String,
pub key_query: Ai_KeyQueryOperator,
}

impl Ai_UeBlackboard {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeBlackboard, LoadError> {
        let __b = Ai_UeBlackboard {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            notify_observer: match __js["notify_observer"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            blackboard_key: match __js["blackboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            key_query: Ai_KeyQueryOperator::new(&__js["key_query"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_KeyQueryOperator {
  IsSet(Box<Ai_IsSet>),
  IsNotSet(Box<Ai_IsNotSet>),
  BinaryOperator(Box<Ai_BinaryOperator>),
}

impl Ai_KeyQueryOperator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_KeyQueryOperator, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "IsSet" => Ai_KeyQueryOperator::IsSet(Box::new(Ai_IsSet::new(&__js)?)),
                "IsNotSet" => Ai_KeyQueryOperator::IsNotSet(Box::new(Ai_IsNotSet::new(&__js)?)),
                "BinaryOperator" => Ai_KeyQueryOperator::BinaryOperator(Box::new(Ai_BinaryOperator::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_IsSet {
}

impl Ai_IsSet {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_IsSet, LoadError> {
        let __b = Ai_IsSet {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_IsNotSet {
}

impl Ai_IsNotSet {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_IsNotSet, LoadError> {
        let __b = Ai_IsNotSet {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_BinaryOperator {
pub oper: i32,
pub data: Ai_KeyData,
}

impl Ai_BinaryOperator {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_BinaryOperator, LoadError> {
        let __b = Ai_BinaryOperator {
            oper: match __js["oper"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            data: Ai_KeyData::new(&__js["data"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_KeyData {
  FloatKeyData(Box<Ai_FloatKeyData>),
  IntKeyData(Box<Ai_IntKeyData>),
  StringKeyData(Box<Ai_StringKeyData>),
  BlackboardKeyData(Box<Ai_BlackboardKeyData>),
}

impl Ai_KeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_KeyData, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "FloatKeyData" => Ai_KeyData::FloatKeyData(Box::new(Ai_FloatKeyData::new(&__js)?)),
                "IntKeyData" => Ai_KeyData::IntKeyData(Box::new(Ai_IntKeyData::new(&__js)?)),
                "StringKeyData" => Ai_KeyData::StringKeyData(Box::new(Ai_StringKeyData::new(&__js)?)),
                "BlackboardKeyData" => Ai_KeyData::BlackboardKeyData(Box::new(Ai_BlackboardKeyData::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_FloatKeyData {
pub value: f32,
}

impl Ai_FloatKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_FloatKeyData, LoadError> {
        let __b = Ai_FloatKeyData {
            value: match __js["value"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_IntKeyData {
pub value: i32,
}

impl Ai_IntKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_IntKeyData, LoadError> {
        let __b = Ai_IntKeyData {
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_StringKeyData {
pub value: String,
}

impl Ai_StringKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_StringKeyData, LoadError> {
        let __b = Ai_StringKeyData {
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_BlackboardKeyData {
pub value: String,
}

impl Ai_BlackboardKeyData {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_BlackboardKeyData, LoadError> {
        let __b = Ai_BlackboardKeyData {
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeForceSuccess {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
}

impl Ai_UeForceSuccess {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeForceSuccess, LoadError> {
        let __b = Ai_UeForceSuccess {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_IsAtLocation {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub acceptable_radius: f32,
pub keyboard_key: String,
pub inverse_condition: bool,
}

impl Ai_IsAtLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_IsAtLocation, LoadError> {
        let __b = Ai_IsAtLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            keyboard_key: match __js["keyboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            inverse_condition: match __js["inverse_condition"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_DistanceLessThan {
pub id: i32,
pub node_name: String,
pub flow_abort_mode: i32,
pub actor1_key: String,
pub actor2_key: String,
pub distance: f32,
pub reverse_result: bool,
}

impl Ai_DistanceLessThan {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_DistanceLessThan, LoadError> {
        let __b = Ai_DistanceLessThan {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            flow_abort_mode: match __js["flow_abort_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            actor1_key: match __js["actor1_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            actor2_key: match __js["actor2_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            distance: match __js["distance"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            reverse_result: match __js["reverse_result"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_FlowNode {
  Sequence(Box<Ai_Sequence>),
  Selector(Box<Ai_Selector>),
  SimpleParallel(Box<Ai_SimpleParallel>),
  UeWait(Box<Ai_UeWait>),
  UeWaitBlackboardTime(Box<Ai_UeWaitBlackboardTime>),
  MoveToTarget(Box<Ai_MoveToTarget>),
  ChooseSkill(Box<Ai_ChooseSkill>),
  MoveToRandomLocation(Box<Ai_MoveToRandomLocation>),
  MoveToLocation(Box<Ai_MoveToLocation>),
  DebugPrint(Box<Ai_DebugPrint>),
}

impl Ai_FlowNode {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_FlowNode, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Sequence" => Ai_FlowNode::Sequence(Box::new(Ai_Sequence::new(&__js)?)),
                "Selector" => Ai_FlowNode::Selector(Box::new(Ai_Selector::new(&__js)?)),
                "SimpleParallel" => Ai_FlowNode::SimpleParallel(Box::new(Ai_SimpleParallel::new(&__js)?)),
                "UeWait" => Ai_FlowNode::UeWait(Box::new(Ai_UeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => Ai_FlowNode::UeWaitBlackboardTime(Box::new(Ai_UeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => Ai_FlowNode::MoveToTarget(Box::new(Ai_MoveToTarget::new(&__js)?)),
                "ChooseSkill" => Ai_FlowNode::ChooseSkill(Box::new(Ai_ChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => Ai_FlowNode::MoveToRandomLocation(Box::new(Ai_MoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => Ai_FlowNode::MoveToLocation(Box::new(Ai_MoveToLocation::new(&__js)?)),
                "DebugPrint" => Ai_FlowNode::DebugPrint(Box::new(Ai_DebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_ComposeNode {
  Sequence(Box<Ai_Sequence>),
  Selector(Box<Ai_Selector>),
  SimpleParallel(Box<Ai_SimpleParallel>),
}

impl Ai_ComposeNode {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_ComposeNode, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Sequence" => Ai_ComposeNode::Sequence(Box::new(Ai_Sequence::new(&__js)?)),
                "Selector" => Ai_ComposeNode::Selector(Box::new(Ai_Selector::new(&__js)?)),
                "SimpleParallel" => Ai_ComposeNode::SimpleParallel(Box::new(Ai_SimpleParallel::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_Sequence {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub children: Vec<Ai_FlowNode>,
}

impl Ai_Sequence {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Sequence, LoadError> {
        let __b = Ai_Sequence {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            children: { if !__js["children"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["children"].members() { __list__.push(Ai_FlowNode::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_Selector {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub children: Vec<Ai_FlowNode>,
}

impl Ai_Selector {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Selector, LoadError> {
        let __b = Ai_Selector {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            children: { if !__js["children"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["children"].members() { __list__.push(Ai_FlowNode::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_SimpleParallel {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub finish_mode: i32,
pub main_task: Ai_Task,
pub background_node: Ai_FlowNode,
}

impl Ai_SimpleParallel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_SimpleParallel, LoadError> {
        let __b = Ai_SimpleParallel {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            finish_mode: match __js["finish_mode"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            main_task: Ai_Task::new(&__js["main_task"])?,
            background_node: Ai_FlowNode::new(&__js["background_node"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Ai_Task {
  UeWait(Box<Ai_UeWait>),
  UeWaitBlackboardTime(Box<Ai_UeWaitBlackboardTime>),
  MoveToTarget(Box<Ai_MoveToTarget>),
  ChooseSkill(Box<Ai_ChooseSkill>),
  MoveToRandomLocation(Box<Ai_MoveToRandomLocation>),
  MoveToLocation(Box<Ai_MoveToLocation>),
  DebugPrint(Box<Ai_DebugPrint>),
}

impl Ai_Task {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_Task, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "UeWait" => Ai_Task::UeWait(Box::new(Ai_UeWait::new(&__js)?)),
                "UeWaitBlackboardTime" => Ai_Task::UeWaitBlackboardTime(Box::new(Ai_UeWaitBlackboardTime::new(&__js)?)),
                "MoveToTarget" => Ai_Task::MoveToTarget(Box::new(Ai_MoveToTarget::new(&__js)?)),
                "ChooseSkill" => Ai_Task::ChooseSkill(Box::new(Ai_ChooseSkill::new(&__js)?)),
                "MoveToRandomLocation" => Ai_Task::MoveToRandomLocation(Box::new(Ai_MoveToRandomLocation::new(&__js)?)),
                "MoveToLocation" => Ai_Task::MoveToLocation(Box::new(Ai_MoveToLocation::new(&__js)?)),
                "DebugPrint" => Ai_Task::DebugPrint(Box::new(Ai_DebugPrint::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeWait {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub wait_time: f32,
pub random_deviation: f32,
}

impl Ai_UeWait {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeWait, LoadError> {
        let __b = Ai_UeWait {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            wait_time: match __js["wait_time"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            random_deviation: match __js["random_deviation"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_UeWaitBlackboardTime {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub blackboard_key: String,
}

impl Ai_UeWaitBlackboardTime {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_UeWaitBlackboardTime, LoadError> {
        let __b = Ai_UeWaitBlackboardTime {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            blackboard_key: match __js["blackboard_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_MoveToTarget {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub target_actor_key: String,
pub acceptable_radius: f32,
}

impl Ai_MoveToTarget {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_MoveToTarget, LoadError> {
        let __b = Ai_MoveToTarget {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_ChooseSkill {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub target_actor_key: String,
pub result_skill_id_key: String,
}

impl Ai_ChooseSkill {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_ChooseSkill, LoadError> {
        let __b = Ai_ChooseSkill {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            target_actor_key: match __js["target_actor_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            result_skill_id_key: match __js["result_skill_id_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_MoveToRandomLocation {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub origin_position_key: String,
pub radius: f32,
}

impl Ai_MoveToRandomLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_MoveToRandomLocation, LoadError> {
        let __b = Ai_MoveToRandomLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            origin_position_key: match __js["origin_position_key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            radius: match __js["radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_MoveToLocation {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub location: Vector3,
pub acceptable_radius: f32,
}

impl Ai_MoveToLocation {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_MoveToLocation, LoadError> {
        let __b = Ai_MoveToLocation {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            location: Vector3::new(&__js["location"])?,
            acceptable_radius: match __js["acceptable_radius"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Ai_DebugPrint {
pub id: i32,
pub node_name: String,
pub decorators: Vec<Ai_Decorator>,
pub services: Vec<Ai_Service>,
pub ignore_restart_self: bool,
pub text: String,
}

impl Ai_DebugPrint {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Ai_DebugPrint, LoadError> {
        let __b = Ai_DebugPrint {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            node_name: match __js["node_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            decorators: { if !__js["decorators"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["decorators"].members() { __list__.push(Ai_Decorator::new(&__e)?); }   __list__},
            services: { if !__js["services"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["services"].members() { __list__.push(Ai_Service::new(&__e)?); }   __list__},
            ignore_restart_self: match __js["ignore_restart_self"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            text: match __js["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Blueprint_TbClazz {
    data_list: Vec<std::rc::Rc<Blueprint_Clazz>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<Blueprint_Clazz>>,
}

impl Blueprint_TbClazz{
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_TbClazz, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Blueprint_TbClazz {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Blueprint_Clazz::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            match &*__v2 {
                Blueprint_Clazz::Interface(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
                Blueprint_Clazz::NormalClazz(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
                Blueprint_Clazz::EnumClazz(__w__) => t.data_map.insert(__w__.name.clone(), __v2),
            };
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Blueprint_TbClazz) -> &std::collections::HashMap<String, std::rc::Rc<Blueprint_Clazz>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Blueprint_TbClazz) -> &Vec<std::rc::Rc<Blueprint_Clazz>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Blueprint_TbClazz, key: &String) -> std::option::Option<&std::rc::Rc<Blueprint_Clazz>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub enum Blueprint_Clazz {
  Interface(Box<Blueprint_Interface>),
  NormalClazz(Box<Blueprint_NormalClazz>),
  EnumClazz(Box<Blueprint_EnumClazz>),
}

impl Blueprint_Clazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_Clazz, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "Interface" => Blueprint_Clazz::Interface(Box::new(Blueprint_Interface::new(&__js)?)),
                "NormalClazz" => Blueprint_Clazz::NormalClazz(Box::new(Blueprint_NormalClazz::new(&__js)?)),
                "EnumClazz" => Blueprint_Clazz::EnumClazz(Box::new(Blueprint_EnumClazz::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Blueprint_Method {
  AbstraceMethod(Box<Blueprint_AbstraceMethod>),
  ExternalMethod(Box<Blueprint_ExternalMethod>),
  BlueprintMethod(Box<Blueprint_BlueprintMethod>),
}

impl Blueprint_Method {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_Method, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "AbstraceMethod" => Blueprint_Method::AbstraceMethod(Box::new(Blueprint_AbstraceMethod::new(&__js)?)),
                "ExternalMethod" => Blueprint_Method::ExternalMethod(Box::new(Blueprint_ExternalMethod::new(&__js)?)),
                "BlueprintMethod" => Blueprint_Method::BlueprintMethod(Box::new(Blueprint_BlueprintMethod::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_ParamInfo {
pub name: String,
pub r#type: String,
pub is_ref: bool,
}

impl Blueprint_ParamInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_ParamInfo, LoadError> {
        let __b = Blueprint_ParamInfo {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            r#type: match __js["type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_ref: match __js["is_ref"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_AbstraceMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<Blueprint_ParamInfo>,
}

impl Blueprint_AbstraceMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_AbstraceMethod, LoadError> {
        let __b = Blueprint_AbstraceMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(Blueprint_ParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_ExternalMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<Blueprint_ParamInfo>,
}

impl Blueprint_ExternalMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_ExternalMethod, LoadError> {
        let __b = Blueprint_ExternalMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(Blueprint_ParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_BlueprintMethod {
pub name: String,
pub desc: String,
pub is_static: bool,
pub return_type: String,
pub parameters: Vec<Blueprint_ParamInfo>,
}

impl Blueprint_BlueprintMethod {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_BlueprintMethod, LoadError> {
        let __b = Blueprint_BlueprintMethod {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            is_static: match __js["is_static"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            return_type: match __js["return_type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parameters: { if !__js["parameters"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parameters"].members() { __list__.push(Blueprint_ParamInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_Interface {
pub name: String,
pub desc: String,
pub parents: Vec<Blueprint_Clazz>,
pub methods: Vec<Blueprint_Method>,
}

impl Blueprint_Interface {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_Interface, LoadError> {
        let __b = Blueprint_Interface {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(Blueprint_Clazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(Blueprint_Method::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_NormalClazz {
pub name: String,
pub desc: String,
pub parents: Vec<Blueprint_Clazz>,
pub methods: Vec<Blueprint_Method>,
pub is_abstract: bool,
pub fields: Vec<Blueprint_Field>,
}

impl Blueprint_NormalClazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_NormalClazz, LoadError> {
        let __b = Blueprint_NormalClazz {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(Blueprint_Clazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(Blueprint_Method::new(&__e)?); }   __list__},
            is_abstract: match __js["is_abstract"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            fields: { if !__js["fields"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["fields"].members() { __list__.push(Blueprint_Field::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_Field {
pub name: String,
pub r#type: String,
pub desc: String,
}

impl Blueprint_Field {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_Field, LoadError> {
        let __b = Blueprint_Field {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            r#type: match __js["type"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_EnumClazz {
pub name: String,
pub desc: String,
pub parents: Vec<Blueprint_Clazz>,
pub methods: Vec<Blueprint_Method>,
pub enums: Vec<Blueprint_EnumField>,
}

impl Blueprint_EnumClazz {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_EnumClazz, LoadError> {
        let __b = Blueprint_EnumClazz {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            parents: { if !__js["parents"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["parents"].members() { __list__.push(Blueprint_Clazz::new(&__e)?); }   __list__},
            methods: { if !__js["methods"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["methods"].members() { __list__.push(Blueprint_Method::new(&__e)?); }   __list__},
            enums: { if !__js["enums"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["enums"].members() { __list__.push(Blueprint_EnumField::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Blueprint_EnumField {
pub name: String,
pub value: i32,
}

impl Blueprint_EnumField {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Blueprint_EnumField, LoadError> {
        let __b = Blueprint_EnumField {
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Bonus_TbDrop {
    data_list: Vec<std::rc::Rc<Bonus_DropInfo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Bonus_DropInfo>>,
}

impl Bonus_TbDrop{
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_TbDrop, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Bonus_TbDrop {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Bonus_DropInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Bonus_TbDrop) -> &std::collections::HashMap<i32, std::rc::Rc<Bonus_DropInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Bonus_TbDrop) -> &Vec<std::rc::Rc<Bonus_DropInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Bonus_TbDrop, key: &i32) -> std::option::Option<&std::rc::Rc<Bonus_DropInfo>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Bonus_DropInfo {
pub id: i32,
pub desc: String,
pub client_show_items: Vec<Bonus_ShowItemInfo>,
pub bonus: Bonus_Bonus,
}

impl Bonus_DropInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_DropInfo, LoadError> {
        let __b = Bonus_DropInfo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            client_show_items: { if !__js["client_show_items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["client_show_items"].members() { __list__.push(Bonus_ShowItemInfo::new(&__e)?); }   __list__},
            bonus: Bonus_Bonus::new(&__js["bonus"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_ShowItemInfo {
pub item_id: i32,
pub item_num: i64,
}

impl Bonus_ShowItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_ShowItemInfo, LoadError> {
        let __b = Bonus_ShowItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            item_num: match __js["item_num"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Bonus_Bonus {
  OneItem(Box<Bonus_OneItem>),
  OneItems(Box<Bonus_OneItems>),
  Item(Box<Bonus_Item>),
  Items(Box<Bonus_Items>),
  CoefficientItem(Box<Bonus_CoefficientItem>),
  WeightItems(Box<Bonus_WeightItems>),
  ProbabilityItems(Box<Bonus_ProbabilityItems>),
  MultiBonus(Box<Bonus_MultiBonus>),
  ProbabilityBonus(Box<Bonus_ProbabilityBonus>),
  WeightBonus(Box<Bonus_WeightBonus>),
  DropBonus(Box<Bonus_DropBonus>),
}

impl Bonus_Bonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_Bonus, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "OneItem" => Bonus_Bonus::OneItem(Box::new(Bonus_OneItem::new(&__js)?)),
                "OneItems" => Bonus_Bonus::OneItems(Box::new(Bonus_OneItems::new(&__js)?)),
                "Item" => Bonus_Bonus::Item(Box::new(Bonus_Item::new(&__js)?)),
                "Items" => Bonus_Bonus::Items(Box::new(Bonus_Items::new(&__js)?)),
                "CoefficientItem" => Bonus_Bonus::CoefficientItem(Box::new(Bonus_CoefficientItem::new(&__js)?)),
                "WeightItems" => Bonus_Bonus::WeightItems(Box::new(Bonus_WeightItems::new(&__js)?)),
                "ProbabilityItems" => Bonus_Bonus::ProbabilityItems(Box::new(Bonus_ProbabilityItems::new(&__js)?)),
                "MultiBonus" => Bonus_Bonus::MultiBonus(Box::new(Bonus_MultiBonus::new(&__js)?)),
                "ProbabilityBonus" => Bonus_Bonus::ProbabilityBonus(Box::new(Bonus_ProbabilityBonus::new(&__js)?)),
                "WeightBonus" => Bonus_Bonus::WeightBonus(Box::new(Bonus_WeightBonus::new(&__js)?)),
                "DropBonus" => Bonus_Bonus::DropBonus(Box::new(Bonus_DropBonus::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_OneItem {
pub item_id: i32,
}

impl Bonus_OneItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_OneItem, LoadError> {
        let __b = Bonus_OneItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_OneItems {
pub items: Vec<i32>,
}

impl Bonus_OneItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_OneItems, LoadError> {
        let __b = Bonus_OneItems {
            items: { if !__js["items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["items"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_Item {
pub item_id: i32,
pub amount: i32,
}

impl Bonus_Item {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_Item, LoadError> {
        let __b = Bonus_Item {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            amount: match __js["amount"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_Items {
pub item_list: Vec<Bonus_Item>,
}

impl Bonus_Items {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_Items, LoadError> {
        let __b = Bonus_Items {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(Bonus_Item::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_CoefficientItem {
pub bonus_id: i32,
pub bonus_list: Bonus_Items,
}

impl Bonus_CoefficientItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_CoefficientItem, LoadError> {
        let __b = Bonus_CoefficientItem {
            bonus_id: match __js["bonus_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bonus_list: Bonus_Items::new(&__js["bonus_list"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_WeightItems {
pub item_list: Vec<Bonus_WeightItemInfo>,
}

impl Bonus_WeightItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_WeightItems, LoadError> {
        let __b = Bonus_WeightItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(Bonus_WeightItemInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_WeightItemInfo {
pub item_id: i32,
pub num: i32,
pub weight: i32,
}

impl Bonus_WeightItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_WeightItemInfo, LoadError> {
        let __b = Bonus_WeightItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            weight: match __js["weight"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_ProbabilityItems {
pub item_list: Vec<Bonus_ProbabilityItemInfo>,
}

impl Bonus_ProbabilityItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_ProbabilityItems, LoadError> {
        let __b = Bonus_ProbabilityItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(Bonus_ProbabilityItemInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_ProbabilityItemInfo {
pub item_id: i32,
pub num: i32,
pub probability: f32,
}

impl Bonus_ProbabilityItemInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_ProbabilityItemInfo, LoadError> {
        let __b = Bonus_ProbabilityItemInfo {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            probability: match __js["probability"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_MultiBonus {
pub bonuses: Vec<Bonus_Bonus>,
}

impl Bonus_MultiBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_MultiBonus, LoadError> {
        let __b = Bonus_MultiBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(Bonus_Bonus::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_ProbabilityBonus {
pub bonuses: Vec<Bonus_ProbabilityBonusInfo>,
}

impl Bonus_ProbabilityBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_ProbabilityBonus, LoadError> {
        let __b = Bonus_ProbabilityBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(Bonus_ProbabilityBonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_ProbabilityBonusInfo {
pub bonus: Bonus_Bonus,
pub probability: f32,
}

impl Bonus_ProbabilityBonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_ProbabilityBonusInfo, LoadError> {
        let __b = Bonus_ProbabilityBonusInfo {
            bonus: Bonus_Bonus::new(&__js["bonus"])?,
            probability: match __js["probability"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_WeightBonus {
pub bonuses: Vec<Bonus_WeightBonusInfo>,
}

impl Bonus_WeightBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_WeightBonus, LoadError> {
        let __b = Bonus_WeightBonus {
            bonuses: { if !__js["bonuses"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonuses"].members() { __list__.push(Bonus_WeightBonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_WeightBonusInfo {
pub bonus: Bonus_Bonus,
pub weight: i32,
}

impl Bonus_WeightBonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_WeightBonusInfo, LoadError> {
        let __b = Bonus_WeightBonusInfo {
            bonus: Bonus_Bonus::new(&__js["bonus"])?,
            weight: match __js["weight"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Bonus_DropBonus {
pub id: i32,
}

impl Bonus_DropBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Bonus_DropBonus, LoadError> {
        let __b = Bonus_DropBonus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Common_TbGlobalConfig {
    data: Common_GlobalConfig,
}

impl Common_TbGlobalConfig{
    pub fn new(__js: &json::JsonValue) -> Result<Common_TbGlobalConfig, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match Common_GlobalConfig::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = Common_TbGlobalConfig {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&Common_TbGlobalConfig) -> &Common_GlobalConfig { &self.data }
}



#[allow(non_camel_case_types)]
pub struct Common_GlobalConfig {
pub bag_capacity: i32,
pub bag_capacity_special: i32,
pub bag_temp_expendable_capacity: i32,
pub bag_temp_tool_capacity: i32,
pub bag_init_capacity: i32,
pub quick_bag_capacity: i32,
pub cloth_bag_capacity: i32,
pub cloth_bag_init_capacity: i32,
pub cloth_bag_capacity_special: i32,
pub bag_init_items_drop_id: std::option::Option<i32>,
pub mail_box_capacity: i32,
pub damage_param_c: f32,
pub damage_param_e: f32,
pub damage_param_f: f32,
pub damage_param_d: f32,
pub role_speed: f32,
pub monster_speed: f32,
pub init_energy: i32,
pub init_viality: i32,
pub max_viality: i32,
pub per_viality_recovery_time: i32,
}

impl Common_GlobalConfig {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Common_GlobalConfig, LoadError> {
        let __b = Common_GlobalConfig {
            bag_capacity: match __js["bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_capacity_special: match __js["bag_capacity_special"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_temp_expendable_capacity: match __js["bag_temp_expendable_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_temp_tool_capacity: match __js["bag_temp_tool_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_init_capacity: match __js["bag_init_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quick_bag_capacity: match __js["quick_bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_capacity: match __js["cloth_bag_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_init_capacity: match __js["cloth_bag_init_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cloth_bag_capacity_special: match __js["cloth_bag_capacity_special"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bag_init_items_drop_id: if !__js["bag_init_items_drop_id"].is_null() { Some(match __js["bag_init_items_drop_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            mail_box_capacity: match __js["mail_box_capacity"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_c: match __js["damage_param_c"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_e: match __js["damage_param_e"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_f: match __js["damage_param_f"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            damage_param_d: match __js["damage_param_d"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            role_speed: match __js["role_speed"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            monster_speed: match __js["monster_speed"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            init_energy: match __js["init_energy"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            init_viality: match __js["init_viality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max_viality: match __js["max_viality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            per_viality_recovery_time: match __js["per_viality_recovery_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Common_TbDummy {
    data_list: Vec<std::rc::Rc<Common_Dummy>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Common_Dummy>>,
}

impl Common_TbDummy{
    pub fn new(__js: &json::JsonValue) -> Result<Common_TbDummy, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Common_TbDummy {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Common_Dummy::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Common_TbDummy) -> &std::collections::HashMap<i32, std::rc::Rc<Common_Dummy>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Common_TbDummy) -> &Vec<std::rc::Rc<Common_Dummy>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Common_TbDummy, key: &i32) -> std::option::Option<&std::rc::Rc<Common_Dummy>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Common_Dummy {
pub id: i32,
pub limit: Limit_LimitBase,
}

impl Common_Dummy {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Common_Dummy, LoadError> {
        let __b = Common_Dummy {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            limit: Limit_LimitBase::new(&__js["limit"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Limit_LimitBase {
  DailyLimit(Box<Limit_DailyLimit>),
  MultiDayLimit(Box<Limit_MultiDayLimit>),
  WeeklyLimit(Box<Limit_WeeklyLimit>),
  MonthlyLimit(Box<Limit_MonthlyLimit>),
  CoolDown(Box<Limit_CoolDown>),
  GroupCoolDown(Box<Limit_GroupCoolDown>),
}

impl Limit_LimitBase {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_LimitBase, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DailyLimit" => Limit_LimitBase::DailyLimit(Box::new(Limit_DailyLimit::new(&__js)?)),
                "MultiDayLimit" => Limit_LimitBase::MultiDayLimit(Box::new(Limit_MultiDayLimit::new(&__js)?)),
                "WeeklyLimit" => Limit_LimitBase::WeeklyLimit(Box::new(Limit_WeeklyLimit::new(&__js)?)),
                "MonthlyLimit" => Limit_LimitBase::MonthlyLimit(Box::new(Limit_MonthlyLimit::new(&__js)?)),
                "CoolDown" => Limit_LimitBase::CoolDown(Box::new(Limit_CoolDown::new(&__js)?)),
                "GroupCoolDown" => Limit_LimitBase::GroupCoolDown(Box::new(Limit_GroupCoolDown::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Limit_DailyLimitBase {
  DailyLimit(Box<Limit_DailyLimit>),
}

impl Limit_DailyLimitBase {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_DailyLimitBase, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DailyLimit" => Limit_DailyLimitBase::DailyLimit(Box::new(Limit_DailyLimit::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_DailyLimit {
pub num: i32,
}

impl Limit_DailyLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_DailyLimit, LoadError> {
        let __b = Limit_DailyLimit {
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_MultiDayLimit {
pub day: i32,
pub num: i32,
}

impl Limit_MultiDayLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_MultiDayLimit, LoadError> {
        let __b = Limit_MultiDayLimit {
            day: match __js["day"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_WeeklyLimit {
pub num: i32,
}

impl Limit_WeeklyLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_WeeklyLimit, LoadError> {
        let __b = Limit_WeeklyLimit {
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_MonthlyLimit {
pub num: i32,
}

impl Limit_MonthlyLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_MonthlyLimit, LoadError> {
        let __b = Limit_MonthlyLimit {
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_CoolDown {
pub duration: i32,
}

impl Limit_CoolDown {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_CoolDown, LoadError> {
        let __b = Limit_CoolDown {
            duration: match __js["duration"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Limit_GroupCoolDown {
pub group_id: i32,
pub duration: i32,
}

impl Limit_GroupCoolDown {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Limit_GroupCoolDown, LoadError> {
        let __b = Limit_GroupCoolDown {
            group_id: match __js["group_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            duration: match __js["duration"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Error_TbErrorInfo {
    data_list: Vec<std::rc::Rc<Error_ErrorInfo>>,
    data_map: std::collections::HashMap<String, std::rc::Rc<Error_ErrorInfo>>,
}

impl Error_TbErrorInfo{
    pub fn new(__js: &json::JsonValue) -> Result<Error_TbErrorInfo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Error_TbErrorInfo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Error_ErrorInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.code.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Error_TbErrorInfo) -> &std::collections::HashMap<String, std::rc::Rc<Error_ErrorInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Error_TbErrorInfo) -> &Vec<std::rc::Rc<Error_ErrorInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Error_TbErrorInfo, key: &String) -> std::option::Option<&std::rc::Rc<Error_ErrorInfo>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Error_ErrorInfo {
pub code: String,
pub desc: String,
pub style: Error_ErrorStyle,
}

impl Error_ErrorInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorInfo, LoadError> {
        let __b = Error_ErrorInfo {
            code: match __js["code"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            style: Error_ErrorStyle::new(&__js["style"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Error_ErrorStyle {
  ErrorStyleTip(Box<Error_ErrorStyleTip>),
  ErrorStyleMsgbox(Box<Error_ErrorStyleMsgbox>),
  ErrorStyleDlgOk(Box<Error_ErrorStyleDlgOk>),
  ErrorStyleDlgOkCancel(Box<Error_ErrorStyleDlgOkCancel>),
}

impl Error_ErrorStyle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorStyle, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "ErrorStyleTip" => Error_ErrorStyle::ErrorStyleTip(Box::new(Error_ErrorStyleTip::new(&__js)?)),
                "ErrorStyleMsgbox" => Error_ErrorStyle::ErrorStyleMsgbox(Box::new(Error_ErrorStyleMsgbox::new(&__js)?)),
                "ErrorStyleDlgOk" => Error_ErrorStyle::ErrorStyleDlgOk(Box::new(Error_ErrorStyleDlgOk::new(&__js)?)),
                "ErrorStyleDlgOkCancel" => Error_ErrorStyle::ErrorStyleDlgOkCancel(Box::new(Error_ErrorStyleDlgOkCancel::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Error_ErrorStyleTip {
}

impl Error_ErrorStyleTip {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorStyleTip, LoadError> {
        let __b = Error_ErrorStyleTip {
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Error_ErrorStyleMsgbox {
pub btn_name: String,
pub operation: i32,
}

impl Error_ErrorStyleMsgbox {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorStyleMsgbox, LoadError> {
        let __b = Error_ErrorStyleMsgbox {
            btn_name: match __js["btn_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            operation: match __js["operation"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Error_ErrorStyleDlgOk {
pub btn_name: String,
}

impl Error_ErrorStyleDlgOk {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorStyleDlgOk, LoadError> {
        let __b = Error_ErrorStyleDlgOk {
            btn_name: match __js["btn_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Error_ErrorStyleDlgOkCancel {
pub btn1_name: String,
pub btn2_name: String,
}

impl Error_ErrorStyleDlgOkCancel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_ErrorStyleDlgOkCancel, LoadError> {
        let __b = Error_ErrorStyleDlgOkCancel {
            btn1_name: match __js["btn1_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            btn2_name: match __js["btn2_name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Error_TbCodeInfo {
    data_list: Vec<std::rc::Rc<Error_CodeInfo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Error_CodeInfo>>,
}

impl Error_TbCodeInfo{
    pub fn new(__js: &json::JsonValue) -> Result<Error_TbCodeInfo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Error_TbCodeInfo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Error_CodeInfo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.code.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Error_TbCodeInfo) -> &std::collections::HashMap<i32, std::rc::Rc<Error_CodeInfo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Error_TbCodeInfo) -> &Vec<std::rc::Rc<Error_CodeInfo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Error_TbCodeInfo, key: &i32) -> std::option::Option<&std::rc::Rc<Error_CodeInfo>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Error_CodeInfo {
pub code: i32,
pub key: String,
}

impl Error_CodeInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Error_CodeInfo, LoadError> {
        let __b = Error_CodeInfo {
            code: match __js["code"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            key: match __js["key"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


/**
 * 道具表
 */
#[allow(non_camel_case_types)]
pub struct Item_TbItem {
    data_list: Vec<std::rc::Rc<Item_Item>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Item_Item>>,
}

impl Item_TbItem{
    pub fn new(__js: &json::JsonValue) -> Result<Item_TbItem, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Item_TbItem {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Item_Item::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Item_TbItem) -> &std::collections::HashMap<i32, std::rc::Rc<Item_Item>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Item_TbItem) -> &Vec<std::rc::Rc<Item_Item>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Item_TbItem, key: &i32) -> std::option::Option<&std::rc::Rc<Item_Item>> { self.data_map.get(key) }
}



/**
 * 道具
 */
#[allow(non_camel_case_types)]
pub struct Item_Item {
pub id: i32,
pub name: String,
pub major_type: i32,
pub minor_type: i32,
pub max_pile_num: i32,
pub quality: i32,
pub icon: String,
pub icon_backgroud: String,
pub icon_mask: String,
pub desc: String,
pub show_order: i32,
pub quantifier: String,
pub show_in_bag: bool,
pub min_show_level: i32,
pub batch_usable: bool,
pub progress_time_when_use: f32,
pub show_hint_when_use: bool,
pub droppable: bool,
pub price: std::option::Option<i32>,
pub use_type: i32,
pub level_up_id: std::option::Option<i32>,
}

impl Item_Item {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_Item, LoadError> {
        let __b = Item_Item {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            major_type: match __js["major_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            minor_type: match __js["minor_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max_pile_num: match __js["max_pile_num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quality: match __js["quality"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            icon: match __js["icon"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            icon_backgroud: match __js["icon_backgroud"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            icon_mask: match __js["icon_mask"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            desc: match __js["desc"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            show_order: match __js["show_order"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            quantifier: match __js["quantifier"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            show_in_bag: match __js["show_in_bag"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            min_show_level: match __js["min_show_level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            batch_usable: match __js["batch_usable"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            progress_time_when_use: match __js["progress_time_when_use"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            show_hint_when_use: match __js["show_hint_when_use"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            droppable: match __js["droppable"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            price: if !__js["price"].is_null() { Some(match __js["price"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            use_type: match __js["use_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            level_up_id: if !__js["level_up_id"].is_null() { Some(match __js["level_up_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Item_TbItemFunc {
    data_list: Vec<std::rc::Rc<Item_ItemFunction>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Item_ItemFunction>>,
}

impl Item_TbItemFunc{
    pub fn new(__js: &json::JsonValue) -> Result<Item_TbItemFunc, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Item_TbItemFunc {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Item_ItemFunction::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.minor_type.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Item_TbItemFunc) -> &std::collections::HashMap<i32, std::rc::Rc<Item_ItemFunction>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Item_TbItemFunc) -> &Vec<std::rc::Rc<Item_ItemFunction>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Item_TbItemFunc, key: &i32) -> std::option::Option<&std::rc::Rc<Item_ItemFunction>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Item_ItemFunction {
pub minor_type: i32,
pub func_type: i32,
pub method: String,
pub close_bag_ui: bool,
}

impl Item_ItemFunction {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_ItemFunction, LoadError> {
        let __b = Item_ItemFunction {
            minor_type: match __js["minor_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            func_type: match __js["func_type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            method: match __js["method"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            close_bag_ui: match __js["close_bag_ui"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Item_TbItemExtra {
    data_list: Vec<std::rc::Rc<Item_ItemExtra>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Item_ItemExtra>>,
}

impl Item_TbItemExtra{
    pub fn new(__js: &json::JsonValue) -> Result<Item_TbItemExtra, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Item_TbItemExtra {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Item_ItemExtra::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            match &*__v2 {
                Item_ItemExtra::TreasureBox(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                Item_ItemExtra::InteractionItem(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                Item_ItemExtra::Clothes(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                Item_ItemExtra::DesignDrawing(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
                Item_ItemExtra::Dymmy(__w__) => t.data_map.insert(__w__.id.clone(), __v2),
            };
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Item_TbItemExtra) -> &std::collections::HashMap<i32, std::rc::Rc<Item_ItemExtra>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Item_TbItemExtra) -> &Vec<std::rc::Rc<Item_ItemExtra>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Item_TbItemExtra, key: &i32) -> std::option::Option<&std::rc::Rc<Item_ItemExtra>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub enum Item_ItemExtra {
  TreasureBox(Box<Item_TreasureBox>),
  InteractionItem(Box<Item_InteractionItem>),
  Clothes(Box<Item_Clothes>),
  DesignDrawing(Box<Item_DesignDrawing>),
  Dymmy(Box<Item_Dymmy>),
}

impl Item_ItemExtra {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_ItemExtra, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "TreasureBox" => Item_ItemExtra::TreasureBox(Box::new(Item_TreasureBox::new(&__js)?)),
                "InteractionItem" => Item_ItemExtra::InteractionItem(Box::new(Item_InteractionItem::new(&__js)?)),
                "Clothes" => Item_ItemExtra::Clothes(Box::new(Item_Clothes::new(&__js)?)),
                "DesignDrawing" => Item_ItemExtra::DesignDrawing(Box::new(Item_DesignDrawing::new(&__js)?)),
                "Dymmy" => Item_ItemExtra::Dymmy(Box::new(Item_Dymmy::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_TreasureBox {
pub id: i32,
pub key_item_id: std::option::Option<i32>,
pub open_level: Condition_MinLevel,
pub use_on_obtain: bool,
pub drop_ids: Vec<i32>,
pub choose_list: Vec<Item_ChooseOneBonus>,
}

impl Item_TreasureBox {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_TreasureBox, LoadError> {
        let __b = Item_TreasureBox {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            key_item_id: if !__js["key_item_id"].is_null() { Some(match __js["key_item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            open_level: Condition_MinLevel::new(&__js["open_level"])?,
            use_on_obtain: match __js["use_on_obtain"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            drop_ids: { if !__js["drop_ids"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["drop_ids"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            choose_list: { if !__js["choose_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["choose_list"].members() { __list__.push(Item_ChooseOneBonus::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Condition_Condition {
  TimeRange(Box<Condition_TimeRange>),
  MultiRoleCondition(Box<Condition_MultiRoleCondition>),
  GenderLimit(Box<Condition_GenderLimit>),
  MinLevel(Box<Condition_MinLevel>),
  MaxLevel(Box<Condition_MaxLevel>),
  MinMaxLevel(Box<Condition_MinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<Condition_ClothesPropertyScoreGreaterThan>),
  ContainsItem(Box<Condition_ContainsItem>),
}

impl Condition_Condition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_Condition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "TimeRange" => Condition_Condition::TimeRange(Box::new(Condition_TimeRange::new(&__js)?)),
                "MultiRoleCondition" => Condition_Condition::MultiRoleCondition(Box::new(Condition_MultiRoleCondition::new(&__js)?)),
                "GenderLimit" => Condition_Condition::GenderLimit(Box::new(Condition_GenderLimit::new(&__js)?)),
                "MinLevel" => Condition_Condition::MinLevel(Box::new(Condition_MinLevel::new(&__js)?)),
                "MaxLevel" => Condition_Condition::MaxLevel(Box::new(Condition_MaxLevel::new(&__js)?)),
                "MinMaxLevel" => Condition_Condition::MinMaxLevel(Box::new(Condition_MinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => Condition_Condition::ClothesPropertyScoreGreaterThan(Box::new(Condition_ClothesPropertyScoreGreaterThan::new(&__js)?)),
                "ContainsItem" => Condition_Condition::ContainsItem(Box::new(Condition_ContainsItem::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_TimeRange {
pub date_time_range: Common_DateTimeRange,
}

impl Condition_TimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_TimeRange, LoadError> {
        let __b = Condition_TimeRange {
            date_time_range: Common_DateTimeRange::new(&__js["date_time_range"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Common_DateTimeRange {
pub start_time: std::option::Option<i32>,
pub end_time: std::option::Option<i32>,
}

impl Common_DateTimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Common_DateTimeRange, LoadError> {
        let __b = Common_DateTimeRange {
            start_time: if !__js["start_time"].is_null() { Some(match __js["start_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            end_time: if !__js["end_time"].is_null() { Some(match __js["end_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Condition_RoleCondition {
  MultiRoleCondition(Box<Condition_MultiRoleCondition>),
  GenderLimit(Box<Condition_GenderLimit>),
  MinLevel(Box<Condition_MinLevel>),
  MaxLevel(Box<Condition_MaxLevel>),
  MinMaxLevel(Box<Condition_MinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<Condition_ClothesPropertyScoreGreaterThan>),
  ContainsItem(Box<Condition_ContainsItem>),
}

impl Condition_RoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_RoleCondition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "MultiRoleCondition" => Condition_RoleCondition::MultiRoleCondition(Box::new(Condition_MultiRoleCondition::new(&__js)?)),
                "GenderLimit" => Condition_RoleCondition::GenderLimit(Box::new(Condition_GenderLimit::new(&__js)?)),
                "MinLevel" => Condition_RoleCondition::MinLevel(Box::new(Condition_MinLevel::new(&__js)?)),
                "MaxLevel" => Condition_RoleCondition::MaxLevel(Box::new(Condition_MaxLevel::new(&__js)?)),
                "MinMaxLevel" => Condition_RoleCondition::MinMaxLevel(Box::new(Condition_MinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => Condition_RoleCondition::ClothesPropertyScoreGreaterThan(Box::new(Condition_ClothesPropertyScoreGreaterThan::new(&__js)?)),
                "ContainsItem" => Condition_RoleCondition::ContainsItem(Box::new(Condition_ContainsItem::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_MultiRoleCondition {
pub conditions: Vec<Condition_RoleCondition>,
}

impl Condition_MultiRoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_MultiRoleCondition, LoadError> {
        let __b = Condition_MultiRoleCondition {
            conditions: { if !__js["conditions"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["conditions"].members() { __list__.push(Condition_RoleCondition::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Condition_BoolRoleCondition {
  GenderLimit(Box<Condition_GenderLimit>),
  MinLevel(Box<Condition_MinLevel>),
  MaxLevel(Box<Condition_MaxLevel>),
  MinMaxLevel(Box<Condition_MinMaxLevel>),
  ClothesPropertyScoreGreaterThan(Box<Condition_ClothesPropertyScoreGreaterThan>),
}

impl Condition_BoolRoleCondition {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_BoolRoleCondition, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "GenderLimit" => Condition_BoolRoleCondition::GenderLimit(Box::new(Condition_GenderLimit::new(&__js)?)),
                "MinLevel" => Condition_BoolRoleCondition::MinLevel(Box::new(Condition_MinLevel::new(&__js)?)),
                "MaxLevel" => Condition_BoolRoleCondition::MaxLevel(Box::new(Condition_MaxLevel::new(&__js)?)),
                "MinMaxLevel" => Condition_BoolRoleCondition::MinMaxLevel(Box::new(Condition_MinMaxLevel::new(&__js)?)),
                "ClothesPropertyScoreGreaterThan" => Condition_BoolRoleCondition::ClothesPropertyScoreGreaterThan(Box::new(Condition_ClothesPropertyScoreGreaterThan::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_GenderLimit {
pub gender: i32,
}

impl Condition_GenderLimit {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_GenderLimit, LoadError> {
        let __b = Condition_GenderLimit {
            gender: match __js["gender"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_MinLevel {
pub level: i32,
}

impl Condition_MinLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_MinLevel, LoadError> {
        let __b = Condition_MinLevel {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_MaxLevel {
pub level: i32,
}

impl Condition_MaxLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_MaxLevel, LoadError> {
        let __b = Condition_MaxLevel {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_MinMaxLevel {
pub min: i32,
pub max: i32,
}

impl Condition_MinMaxLevel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_MinMaxLevel, LoadError> {
        let __b = Condition_MinMaxLevel {
            min: match __js["min"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            max: match __js["max"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_ClothesPropertyScoreGreaterThan {
pub prop: i32,
pub value: i32,
}

impl Condition_ClothesPropertyScoreGreaterThan {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_ClothesPropertyScoreGreaterThan, LoadError> {
        let __b = Condition_ClothesPropertyScoreGreaterThan {
            prop: match __js["prop"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Condition_ContainsItem {
pub item_id: i32,
pub num: i32,
pub reverse: bool,
}

impl Condition_ContainsItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Condition_ContainsItem, LoadError> {
        let __b = Condition_ContainsItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            reverse: match __js["reverse"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_ChooseOneBonus {
pub drop_id: i32,
pub is_unique: bool,
}

impl Item_ChooseOneBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_ChooseOneBonus, LoadError> {
        let __b = Item_ChooseOneBonus {
            drop_id: match __js["drop_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            is_unique: match __js["is_unique"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_InteractionItem {
pub id: i32,
pub attack_num: std::option::Option<i32>,
pub holding_static_mesh: String,
pub holding_static_mesh_mat: String,
}

impl Item_InteractionItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_InteractionItem, LoadError> {
        let __b = Item_InteractionItem {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            attack_num: if !__js["attack_num"].is_null() { Some(match __js["attack_num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            holding_static_mesh: match __js["holding_static_mesh"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            holding_static_mesh_mat: match __js["holding_static_mesh_mat"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_Clothes {
pub id: i32,
pub attack: i32,
pub hp: i64,
pub energy_limit: i32,
pub energy_resume: i32,
}

impl Item_Clothes {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_Clothes, LoadError> {
        let __b = Item_Clothes {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            attack: match __js["attack"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            hp: match __js["hp"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            energy_limit: match __js["energy_limit"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            energy_resume: match __js["energy_resume"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_DesignDrawing {
pub id: i32,
pub learn_component_id: Vec<i32>,
}

impl Item_DesignDrawing {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_DesignDrawing, LoadError> {
        let __b = Item_DesignDrawing {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            learn_component_id: { if !__js["learn_component_id"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["learn_component_id"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Item_Dymmy {
pub id: i32,
pub cost: Cost_Cost,
}

impl Item_Dymmy {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Item_Dymmy, LoadError> {
        let __b = Item_Dymmy {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            cost: Cost_Cost::new(&__js["cost"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Cost_Cost {
  CostCurrency(Box<Cost_CostCurrency>),
  CostCurrencies(Box<Cost_CostCurrencies>),
  CostOneItem(Box<Cost_CostOneItem>),
  CostItem(Box<Cost_CostItem>),
  CostItems(Box<Cost_CostItems>),
}

impl Cost_Cost {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_Cost, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "CostCurrency" => Cost_Cost::CostCurrency(Box::new(Cost_CostCurrency::new(&__js)?)),
                "CostCurrencies" => Cost_Cost::CostCurrencies(Box::new(Cost_CostCurrencies::new(&__js)?)),
                "CostOneItem" => Cost_Cost::CostOneItem(Box::new(Cost_CostOneItem::new(&__js)?)),
                "CostItem" => Cost_Cost::CostItem(Box::new(Cost_CostItem::new(&__js)?)),
                "CostItems" => Cost_Cost::CostItems(Box::new(Cost_CostItems::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Cost_CostCurrency {
pub r#type: i32,
pub num: i32,
}

impl Cost_CostCurrency {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_CostCurrency, LoadError> {
        let __b = Cost_CostCurrency {
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            num: match __js["num"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Cost_CostCurrencies {
pub currencies: Vec<Cost_CostCurrency>,
}

impl Cost_CostCurrencies {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_CostCurrencies, LoadError> {
        let __b = Cost_CostCurrencies {
            currencies: { if !__js["currencies"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["currencies"].members() { __list__.push(Cost_CostCurrency::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Cost_CostOneItem {
pub item_id: i32,
}

impl Cost_CostOneItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_CostOneItem, LoadError> {
        let __b = Cost_CostOneItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Cost_CostItem {
pub item_id: i32,
pub amount: i32,
}

impl Cost_CostItem {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_CostItem, LoadError> {
        let __b = Cost_CostItem {
            item_id: match __js["item_id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            amount: match __js["amount"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Cost_CostItems {
pub item_list: Vec<Cost_CostItem>,
}

impl Cost_CostItems {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Cost_CostItems, LoadError> {
        let __b = Cost_CostItems {
            item_list: { if !__js["item_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["item_list"].members() { __list__.push(Cost_CostItem::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct L10n_TbL10NDemo {
    data_list: Vec<std::rc::Rc<L10n_L10NDemo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<L10n_L10NDemo>>,
}

impl L10n_TbL10NDemo{
    pub fn new(__js: &json::JsonValue) -> Result<L10n_TbL10NDemo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = L10n_TbL10NDemo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match L10n_L10NDemo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&L10n_TbL10NDemo) -> &std::collections::HashMap<i32, std::rc::Rc<L10n_L10NDemo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&L10n_TbL10NDemo) -> &Vec<std::rc::Rc<L10n_L10NDemo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&L10n_TbL10NDemo, key: &i32) -> std::option::Option<&std::rc::Rc<L10n_L10NDemo>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct L10n_L10NDemo {
pub id: i32,
pub text: String,
}

impl L10n_L10NDemo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<L10n_L10NDemo, LoadError> {
        let __b = L10n_L10NDemo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            text: { if !__js["text"]["key"].is_string() { return Err(LoadError{}); } match __js["text"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct L10n_TbPatchDemo {
    data_list: Vec<std::rc::Rc<L10n_PatchDemo>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<L10n_PatchDemo>>,
}

impl L10n_TbPatchDemo{
    pub fn new(__js: &json::JsonValue) -> Result<L10n_TbPatchDemo, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = L10n_TbPatchDemo {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match L10n_PatchDemo::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&L10n_TbPatchDemo) -> &std::collections::HashMap<i32, std::rc::Rc<L10n_PatchDemo>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&L10n_TbPatchDemo) -> &Vec<std::rc::Rc<L10n_PatchDemo>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&L10n_TbPatchDemo, key: &i32) -> std::option::Option<&std::rc::Rc<L10n_PatchDemo>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct L10n_PatchDemo {
pub id: i32,
pub value: i32,
}

impl L10n_PatchDemo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<L10n_PatchDemo, LoadError> {
        let __b = L10n_PatchDemo {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Mail_TbSystemMail {
    data_list: Vec<std::rc::Rc<Mail_SystemMail>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Mail_SystemMail>>,
}

impl Mail_TbSystemMail{
    pub fn new(__js: &json::JsonValue) -> Result<Mail_TbSystemMail, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Mail_TbSystemMail {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Mail_SystemMail::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Mail_TbSystemMail) -> &std::collections::HashMap<i32, std::rc::Rc<Mail_SystemMail>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Mail_TbSystemMail) -> &Vec<std::rc::Rc<Mail_SystemMail>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Mail_TbSystemMail, key: &i32) -> std::option::Option<&std::rc::Rc<Mail_SystemMail>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Mail_SystemMail {
pub id: i32,
pub title: String,
pub sender: String,
pub content: String,
pub award: Vec<i32>,
}

impl Mail_SystemMail {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Mail_SystemMail, LoadError> {
        let __b = Mail_SystemMail {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            title: match __js["title"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            sender: match __js["sender"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            content: match __js["content"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            award: { if !__js["award"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["award"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Mail_TbGlobalMail {
    data_list: Vec<std::rc::Rc<Mail_GlobalMail>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Mail_GlobalMail>>,
}

impl Mail_TbGlobalMail{
    pub fn new(__js: &json::JsonValue) -> Result<Mail_TbGlobalMail, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Mail_TbGlobalMail {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Mail_GlobalMail::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Mail_TbGlobalMail) -> &std::collections::HashMap<i32, std::rc::Rc<Mail_GlobalMail>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Mail_TbGlobalMail) -> &Vec<std::rc::Rc<Mail_GlobalMail>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Mail_TbGlobalMail, key: &i32) -> std::option::Option<&std::rc::Rc<Mail_GlobalMail>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Mail_GlobalMail {
pub id: i32,
pub title: String,
pub sender: String,
pub content: String,
pub award: Vec<i32>,
pub all_server: bool,
pub server_list: Vec<i32>,
pub platform: String,
pub channel: String,
pub min_max_level: Condition_MinMaxLevel,
pub register_time: Condition_TimeRange,
pub mail_time: Condition_TimeRange,
}

impl Mail_GlobalMail {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Mail_GlobalMail, LoadError> {
        let __b = Mail_GlobalMail {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            title: match __js["title"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            sender: match __js["sender"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            content: match __js["content"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            award: { if !__js["award"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["award"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            all_server: match __js["all_server"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            server_list: { if !__js["server_list"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["server_list"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            platform: match __js["platform"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            channel: match __js["channel"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            min_max_level: Condition_MinMaxLevel::new(&__js["min_max_level"])?,
            register_time: Condition_TimeRange::new(&__js["register_time"])?,
            mail_time: Condition_TimeRange::new(&__js["mail_time"])?,
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Role_TbRoleLevelExpAttr {
    data_list: Vec<std::rc::Rc<Role_LevelExpAttr>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Role_LevelExpAttr>>,
}

impl Role_TbRoleLevelExpAttr{
    pub fn new(__js: &json::JsonValue) -> Result<Role_TbRoleLevelExpAttr, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Role_TbRoleLevelExpAttr {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Role_LevelExpAttr::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.level.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Role_TbRoleLevelExpAttr) -> &std::collections::HashMap<i32, std::rc::Rc<Role_LevelExpAttr>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Role_TbRoleLevelExpAttr) -> &Vec<std::rc::Rc<Role_LevelExpAttr>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Role_TbRoleLevelExpAttr, key: &i32) -> std::option::Option<&std::rc::Rc<Role_LevelExpAttr>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Role_LevelExpAttr {
pub level: i32,
pub need_exp: i64,
pub clothes_attrs: Vec<i32>,
}

impl Role_LevelExpAttr {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Role_LevelExpAttr, LoadError> {
        let __b = Role_LevelExpAttr {
            level: match __js["level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            need_exp: match __js["need_exp"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            clothes_attrs: { if !__js["clothes_attrs"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["clothes_attrs"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Role_TbRoleLevelBonusCoefficient {
    data_list: Vec<std::rc::Rc<Role_LevelBonus>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Role_LevelBonus>>,
}

impl Role_TbRoleLevelBonusCoefficient{
    pub fn new(__js: &json::JsonValue) -> Result<Role_TbRoleLevelBonusCoefficient, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Role_TbRoleLevelBonusCoefficient {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Role_LevelBonus::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Role_TbRoleLevelBonusCoefficient) -> &std::collections::HashMap<i32, std::rc::Rc<Role_LevelBonus>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Role_TbRoleLevelBonusCoefficient) -> &Vec<std::rc::Rc<Role_LevelBonus>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Role_TbRoleLevelBonusCoefficient, key: &i32) -> std::option::Option<&std::rc::Rc<Role_LevelBonus>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Role_LevelBonus {
pub id: i32,
pub distinct_bonus_infos: Vec<Role_DistinctBonusInfos>,
}

impl Role_LevelBonus {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Role_LevelBonus, LoadError> {
        let __b = Role_LevelBonus {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            distinct_bonus_infos: { if !__js["distinct_bonus_infos"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["distinct_bonus_infos"].members() { __list__.push(Role_DistinctBonusInfos::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Role_DistinctBonusInfos {
pub effective_level: i32,
pub bonus_info: Vec<Role_BonusInfo>,
}

impl Role_DistinctBonusInfos {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Role_DistinctBonusInfos, LoadError> {
        let __b = Role_DistinctBonusInfos {
            effective_level: match __js["effective_level"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            bonus_info: { if !__js["bonus_info"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["bonus_info"].members() { __list__.push(Role_BonusInfo::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Role_BonusInfo {
pub r#type: i32,
pub coefficient: f32,
}

impl Role_BonusInfo {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Role_BonusInfo, LoadError> {
        let __b = Role_BonusInfo {
            r#type: match __js["type"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            coefficient: match __js["coefficient"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Tag_TbTestTag {
    data_list: Vec<std::rc::Rc<Tag_TestTag>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Tag_TestTag>>,
}

impl Tag_TbTestTag{
    pub fn new(__js: &json::JsonValue) -> Result<Tag_TbTestTag, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Tag_TbTestTag {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Tag_TestTag::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Tag_TbTestTag) -> &std::collections::HashMap<i32, std::rc::Rc<Tag_TestTag>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Tag_TbTestTag) -> &Vec<std::rc::Rc<Tag_TestTag>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Tag_TbTestTag, key: &i32) -> std::option::Option<&std::rc::Rc<Tag_TestTag>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Tag_TestTag {
pub id: i32,
pub value: String,
}

impl Tag_TestTag {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Tag_TestTag, LoadError> {
        let __b = Tag_TestTag {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            value: match __js["value"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbFullTypes {
    data_list: Vec<std::rc::Rc<Test_DemoType2>>,
    data_map: std::collections::HashMap<i16, std::rc::Rc<Test_DemoType2>>,
}

impl Test_TbFullTypes{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbFullTypes, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbFullTypes {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoType2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x3.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbFullTypes) -> &std::collections::HashMap<i16, std::rc::Rc<Test_DemoType2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbFullTypes) -> &Vec<std::rc::Rc<Test_DemoType2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbFullTypes, key: &i16) -> std::option::Option<&std::rc::Rc<Test_DemoType2>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_DemoType2 {
pub x4: i32,
pub x1: bool,
pub x2: u8,
pub x3: i16,
pub x5: i64,
pub x6: f32,
pub x7: f64,
pub x8_0: i16,
pub x8: i32,
pub x9: i64,
pub x10: String,
pub x12: Test_DemoType1,
pub x13: i32,
pub x14: Test_DemoDynamic,
pub s1: String,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
pub t1: i32,
pub k1: Vec<i32>,
pub k2: Vec<i32>,
pub k5: std::collections::HashSet<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<Test_DemoE2>,
pub k15: Vec<Test_DemoDynamic>,
}

impl Test_DemoType2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoType2, LoadError> {
        let __b = Test_DemoType2 {
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_u8() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x7: match __js["x7"].as_f64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8_0: match __js["x8_0"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x9: match __js["x9"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x12: Test_DemoType1::new(&__js["x12"])?,
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: Test_DemoDynamic::new(&__js["x14"])?,
            s1: { if !__js["s1"]["key"].is_string() { return Err(LoadError{}); } match __js["s1"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k2: { if !__js["k2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k2"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k5: { if !__js["k5"].is_array() { return Err(LoadError{}); } let mut __set__ = std::collections::HashSet::new(); for __e in __js["k5"].members() { __set__.insert(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __set__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(Test_DemoE2::new(&__e)?); }   __list__},
            k15: { if !__js["k15"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k15"].members() { __list__.push(Test_DemoDynamic::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DemoType1 {
pub x1: i32,
}

impl Test_DemoType1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoType1, LoadError> {
        let __b = Test_DemoType1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Test_DemoDynamic {
  DemoD2(Box<Test_DemoD2>),
  DemoE1(Box<Test_DemoE1>),
  DemoD5(Box<Test_DemoD5>),
}

impl Test_DemoDynamic {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoDynamic, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DemoD2" => Test_DemoDynamic::DemoD2(Box::new(Test_DemoD2::new(&__js)?)),
                "DemoE1" => Test_DemoDynamic::DemoE1(Box::new(Test_DemoE1::new(&__js)?)),
                "DemoD5" => Test_DemoDynamic::DemoD5(Box::new(Test_DemoD5::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DemoD2 {
pub x1: i32,
pub x2: i32,
}

impl Test_DemoD2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoD2, LoadError> {
        let __b = Test_DemoD2 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub enum Test_DemoD3 {
  DemoE1(Box<Test_DemoE1>),
}

impl Test_DemoD3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoD3, LoadError> {
        let __b = match __js["__type__"].as_str() {
            Some(type_name) => match type_name {
                "DemoE1" => Test_DemoD3::DemoE1(Box::new(Test_DemoE1::new(&__js)?)),
                _ => return Err(LoadError{})
                },
            None => return Err(LoadError{})
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DemoE1 {
pub x1: i32,
pub x3: i32,
pub x4: i32,
}

impl Test_DemoE1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoE1, LoadError> {
        let __b = Test_DemoE1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DemoD5 {
pub x1: i32,
pub time: Test_DateTimeRange,
}

impl Test_DemoD5 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoD5, LoadError> {
        let __b = Test_DemoD5 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            time: Test_DateTimeRange::new(&__js["time"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DateTimeRange {
pub start_time: i32,
pub end_time: i32,
}

impl Test_DateTimeRange {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DateTimeRange, LoadError> {
        let __b = Test_DateTimeRange {
            start_time: match __js["start_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            end_time: match __js["end_time"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_DemoE2 {
pub y1: std::option::Option<i32>,
pub y2: bool,
}

impl Test_DemoE2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoE2, LoadError> {
        let __b = Test_DemoE2 {
            y1: if !__js["y1"].is_null() { Some(match __js["y1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            y2: match __js["y2"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbSingleton {
    data: Test_DemoSingletonType,
}

impl Test_TbSingleton{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbSingleton, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match Test_DemoSingletonType::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = Test_TbSingleton {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&Test_TbSingleton) -> &Test_DemoSingletonType { &self.data }
}



#[allow(non_camel_case_types)]
pub struct Test_DemoSingletonType {
pub id: i32,
pub name: String,
pub date: Test_DemoDynamic,
}

impl Test_DemoSingletonType {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoSingletonType, LoadError> {
        let __b = Test_DemoSingletonType {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: { if !__js["name"]["key"].is_string() { return Err(LoadError{}); } match __js["name"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            date: Test_DemoDynamic::new(&__js["date"])?,
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDataFromMisc {
    data_list: Vec<std::rc::Rc<Test_DemoType2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoType2>>,
}

impl Test_TbDataFromMisc{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDataFromMisc, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDataFromMisc {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoType2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDataFromMisc) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoType2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDataFromMisc) -> &Vec<std::rc::Rc<Test_DemoType2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDataFromMisc, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoType2>> { self.data_map.get(key) }
}

#[allow(non_camel_case_types)]
pub struct Test_TbMultiRowRecord {
    data_list: Vec<std::rc::Rc<Test_MultiRowRecord>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_MultiRowRecord>>,
}

impl Test_TbMultiRowRecord{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbMultiRowRecord, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbMultiRowRecord {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_MultiRowRecord::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbMultiRowRecord) -> &std::collections::HashMap<i32, std::rc::Rc<Test_MultiRowRecord>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbMultiRowRecord) -> &Vec<std::rc::Rc<Test_MultiRowRecord>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbMultiRowRecord, key: &i32) -> std::option::Option<&std::rc::Rc<Test_MultiRowRecord>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_MultiRowRecord {
pub id: i32,
pub name: String,
pub one_rows: Vec<Test_MultiRowType1>,
pub multi_rows1: Vec<Test_MultiRowType1>,
pub multi_rows2: Vec<Test_MultiRowType1>,
pub multi_rows4: std::collections::HashMap<i32, Test_MultiRowType2>,
pub multi_rows5: Vec<Test_MultiRowType3>,
pub multi_rows6: std::collections::HashMap<i32, Test_MultiRowType2>,
pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl Test_MultiRowRecord {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_MultiRowRecord, LoadError> {
        let __b = Test_MultiRowRecord {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            one_rows: { if !__js["one_rows"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["one_rows"].members() { __list__.push(Test_MultiRowType1::new(&__e)?); }   __list__},
            multi_rows1: { if !__js["multi_rows1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows1"].members() { __list__.push(Test_MultiRowType1::new(&__e)?); }   __list__},
            multi_rows2: { if !__js["multi_rows2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows2"].members() { __list__.push(Test_MultiRowType1::new(&__e)?); }   __list__},
            multi_rows4: { if !__js["multi_rows4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows4"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, Test_MultiRowType2::new(&__e[1])?); }   __map__},
            multi_rows5: { if !__js["multi_rows5"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["multi_rows5"].members() { __list__.push(Test_MultiRowType3::new(&__e)?); }   __list__},
            multi_rows6: { if !__js["multi_rows6"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows6"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, Test_MultiRowType2::new(&__e[1])?); }   __map__},
            multi_rows7: { if !__js["multi_rows7"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["multi_rows7"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_MultiRowType1 {
pub id: i32,
pub x: i32,
}

impl Test_MultiRowType1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_MultiRowType1, LoadError> {
        let __b = Test_MultiRowType1 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_MultiRowType2 {
pub id: i32,
pub x: i32,
pub y: f32,
}

impl Test_MultiRowType2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_MultiRowType2, LoadError> {
        let __b = Test_MultiRowType2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x: match __js["x"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y: match __js["y"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_MultiRowType3 {
pub id: i32,
pub items: Vec<Test_MultiRowType1>,
}

impl Test_MultiRowType3 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_MultiRowType3, LoadError> {
        let __b = Test_MultiRowType3 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            items: { if !__js["items"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["items"].members() { __list__.push(Test_MultiRowType1::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbMultiRowTitle {
    data_list: Vec<std::rc::Rc<Test_MultiRowTitle>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_MultiRowTitle>>,
}

impl Test_TbMultiRowTitle{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbMultiRowTitle, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbMultiRowTitle {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_MultiRowTitle::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbMultiRowTitle) -> &std::collections::HashMap<i32, std::rc::Rc<Test_MultiRowTitle>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbMultiRowTitle) -> &Vec<std::rc::Rc<Test_MultiRowTitle>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbMultiRowTitle, key: &i32) -> std::option::Option<&std::rc::Rc<Test_MultiRowTitle>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_MultiRowTitle {
pub id: i32,
pub name: String,
pub x1: Test_H1,
pub x2: Vec<Test_H2>,
pub x3: Vec<Test_H2>,
}

impl Test_MultiRowTitle {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_MultiRowTitle, LoadError> {
        let __b = Test_MultiRowTitle {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x1: Test_H1::new(&__js["x1"])?,
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x2"].members() { __list__.push(Test_H2::new(&__e)?); }   __list__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["x3"].members() { __list__.push(Test_H2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_H1 {
pub y2: Test_H2,
pub y3: i32,
}

impl Test_H1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_H1, LoadError> {
        let __b = Test_H1 {
            y2: Test_H2::new(&__js["y2"])?,
            y3: match __js["y3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_H2 {
pub z2: i32,
pub z3: i32,
}

impl Test_H2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_H2, LoadError> {
        let __b = Test_H2 {
            z2: match __js["z2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            z3: match __js["z3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestNull {
    data_list: Vec<std::rc::Rc<Test_TestNull>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestNull>>,
}

impl Test_TbTestNull{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestNull, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestNull {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestNull::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestNull) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestNull>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestNull) -> &Vec<std::rc::Rc<Test_TestNull>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestNull, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestNull>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_TestNull {
pub id: i32,
pub x1: std::option::Option<i32>,
pub x2: std::option::Option<i32>,
pub x3: std::option::Option<Test_DemoType1>,
pub x4: std::option::Option<Test_DemoDynamic>,
pub s1: std::option::Option<String>,
pub s2: std::option::Option<String>,
}

impl Test_TestNull {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestNull, LoadError> {
        let __b = Test_TestNull {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: if !__js["x1"].is_null() { Some(match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            x2: if !__js["x2"].is_null() { Some(match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }) } else { None },
            x3: if !__js["x3"].is_null() { Some(Test_DemoType1::new(&__js["x3"])?) } else { None },
            x4: if !__js["x4"].is_null() { Some(Test_DemoDynamic::new(&__js["x4"])?) } else { None },
            s1: if !__js["s1"].is_null() { Some(match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }) } else { None },
            s2: if !__js["s2"].is_null() { Some({ if !__js["s2"]["key"].is_string() { return Err(LoadError{}); } match __js["s2"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } }) } else { None },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDemoPrimitive {
    data_list: Vec<std::rc::Rc<Test_DemoPrimitiveTypesTable>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoPrimitiveTypesTable>>,
}

impl Test_TbDemoPrimitive{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoPrimitive, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoPrimitive {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoPrimitiveTypesTable::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x4.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoPrimitive) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoPrimitiveTypesTable>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoPrimitive) -> &Vec<std::rc::Rc<Test_DemoPrimitiveTypesTable>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoPrimitive, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoPrimitiveTypesTable>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_DemoPrimitiveTypesTable {
pub x1: bool,
pub x2: u8,
pub x3: i16,
pub x4: i32,
pub x5: i64,
pub x6: f32,
pub x7: f64,
pub s1: String,
pub s2: String,
pub v2: Vector2,
pub v3: Vector3,
pub v4: Vector4,
pub t1: i32,
}

impl Test_DemoPrimitiveTypesTable {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoPrimitiveTypesTable, LoadError> {
        let __b = Test_DemoPrimitiveTypesTable {
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_u8() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i16() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x7: match __js["x7"].as_f64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s1: match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            s2: { if !__js["s2"]["key"].is_string() { return Err(LoadError{}); } match __js["s2"]["text"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) } },
            v2: Vector2::new(&__js["v2"])?,
            v3: Vector3::new(&__js["v3"])?,
            v4: Vector4::new(&__js["v4"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestString {
    data_list: Vec<std::rc::Rc<Test_TestString>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestString>>,
}

impl Test_TbTestString{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestString, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestString {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestString::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestString) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestString>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestString) -> &Vec<std::rc::Rc<Test_TestString>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestString, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestString>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_TestString {
pub id: i32,
pub s1: String,
pub cs1: Test_CompactString,
pub cs2: Test_CompactString,
}

impl Test_TestString {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestString, LoadError> {
        let __b = Test_TestString {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s1: match __js["s1"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            cs1: Test_CompactString::new(&__js["cs1"])?,
            cs2: Test_CompactString::new(&__js["cs2"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_CompactString {
pub id: i32,
pub s2: String,
pub s3: String,
}

impl Test_CompactString {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_CompactString, LoadError> {
        let __b = Test_CompactString {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            s2: match __js["s2"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            s3: match __js["s3"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDemoGroup {
    data_list: Vec<std::rc::Rc<Test_DemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>>,
}

impl Test_TbDemoGroup{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoGroup, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoGroup {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoGroup) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoGroup) -> &Vec<std::rc::Rc<Test_DemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoGroup, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoGroup>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_DemoGroup {
pub id: i32,
pub x1: i32,
pub x2: i32,
pub x3: i32,
pub x4: i32,
pub x5: Test_InnerGroup,
}

impl Test_DemoGroup {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DemoGroup, LoadError> {
        let __b = Test_DemoGroup {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: Test_InnerGroup::new(&__js["x5"])?,
        };
        Ok(__b)
    }
}




#[allow(non_camel_case_types)]
pub struct Test_InnerGroup {
pub y1: i32,
pub y2: i32,
pub y3: i32,
pub y4: i32,
}

impl Test_InnerGroup {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_InnerGroup, LoadError> {
        let __b = Test_InnerGroup {
            y1: match __js["y1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y2: match __js["y2"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y3: match __js["y3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            y4: match __js["y4"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDemoGroup_C {
    data_list: Vec<std::rc::Rc<Test_DemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>>,
}

impl Test_TbDemoGroup_C{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoGroup_C, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoGroup_C {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoGroup_C) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoGroup_C) -> &Vec<std::rc::Rc<Test_DemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoGroup_C, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoGroup>> { self.data_map.get(key) }
}

#[allow(non_camel_case_types)]
pub struct Test_TbDemoGroup_S {
    data_list: Vec<std::rc::Rc<Test_DemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>>,
}

impl Test_TbDemoGroup_S{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoGroup_S, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoGroup_S {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoGroup_S) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoGroup_S) -> &Vec<std::rc::Rc<Test_DemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoGroup_S, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoGroup>> { self.data_map.get(key) }
}

#[allow(non_camel_case_types)]
pub struct Test_TbDemoGroup_E {
    data_list: Vec<std::rc::Rc<Test_DemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>>,
}

impl Test_TbDemoGroup_E{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoGroup_E, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoGroup_E {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoGroup_E) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoGroup_E) -> &Vec<std::rc::Rc<Test_DemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoGroup_E, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoGroup>> { self.data_map.get(key) }
}

#[allow(non_camel_case_types)]
pub struct Test_TbTestGlobal {
    data: Test_TestGlobal,
}

impl Test_TbTestGlobal{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestGlobal, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match Test_TestGlobal::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = Test_TbTestGlobal {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&Test_TbTestGlobal) -> &Test_TestGlobal { &self.data }
}



#[allow(non_camel_case_types)]
pub struct Test_TestGlobal {
pub unlock_equip: i32,
pub unlock_hero: i32,
}

impl Test_TestGlobal {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestGlobal, LoadError> {
        let __b = Test_TestGlobal {
            unlock_equip: match __js["unlock_equip"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            unlock_hero: match __js["unlock_hero"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDetectCsvEncoding {
    data_list: Vec<std::rc::Rc<Test_DetectEncoding>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DetectEncoding>>,
}

impl Test_TbDetectCsvEncoding{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDetectCsvEncoding, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDetectCsvEncoding {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DetectEncoding::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDetectCsvEncoding) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DetectEncoding>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDetectCsvEncoding) -> &Vec<std::rc::Rc<Test_DetectEncoding>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDetectCsvEncoding, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DetectEncoding>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_DetectEncoding {
pub id: i32,
pub name: String,
}

impl Test_DetectEncoding {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DetectEncoding, LoadError> {
        let __b = Test_DetectEncoding {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            name: match __js["name"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDefineFromExcel {
    data_list: Vec<std::rc::Rc<Test_DefineFromExcel>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DefineFromExcel>>,
}

impl Test_TbDefineFromExcel{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDefineFromExcel, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDefineFromExcel {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DefineFromExcel::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDefineFromExcel) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DefineFromExcel>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDefineFromExcel) -> &Vec<std::rc::Rc<Test_DefineFromExcel>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDefineFromExcel, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DefineFromExcel>> { self.data_map.get(key) }
}



/**
 * 
 */
#[allow(non_camel_case_types)]
pub struct Test_DefineFromExcel {
pub id: i32,
pub x1: bool,
pub x5: i64,
pub x6: f32,
pub x8: i32,
pub x10: String,
pub x13: i32,
pub x14: Test_DemoDynamic,
pub v2: Vector2,
pub t1: i32,
pub k1: Vec<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<Test_DemoE2>,
}

impl Test_DefineFromExcel {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DefineFromExcel, LoadError> {
        let __b = Test_DefineFromExcel {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: Test_DemoDynamic::new(&__js["x14"])?,
            v2: Vector2::new(&__js["v2"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(Test_DemoE2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDefineFromExcelOne {
    data: Test_DefineFromExcelOne,
}

impl Test_TbDefineFromExcelOne{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDefineFromExcelOne, LoadError> {
        if !__js.is_array() || __js.len() != 1 {
            return Err(LoadError{});
        }
        let __v = match Test_DefineFromExcelOne::new(&__js[0]) {
            Ok(x) => x,
            Err(err) => return Err(err),
        };
        let t = Test_TbDefineFromExcelOne {
            data: __v,
        };
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data(self:&Test_TbDefineFromExcelOne) -> &Test_DefineFromExcelOne { &self.data }
}



/**
 * 
 */
#[allow(non_camel_case_types)]
pub struct Test_DefineFromExcelOne {
pub unlock_equip: i32,
pub unlock_hero: i32,
pub default_avatar: String,
pub default_item: String,
}

impl Test_DefineFromExcelOne {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DefineFromExcelOne, LoadError> {
        let __b = Test_DefineFromExcelOne {
            unlock_equip: match __js["unlock_equip"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            unlock_hero: match __js["unlock_hero"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            default_avatar: match __js["default_avatar"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            default_item: match __js["default_item"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestJson2 {
    data_list: Vec<std::rc::Rc<Test_TestJson2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestJson2>>,
}

impl Test_TbTestJson2{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestJson2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestJson2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestJson2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestJson2) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestJson2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestJson2) -> &Vec<std::rc::Rc<Test_TestJson2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestJson2, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestJson2>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_TestJson2 {
pub id: i32,
pub m1: std::collections::HashMap<i32, i32>,
pub m2: std::collections::HashMap<i64, i32>,
pub m3: std::collections::HashMap<String, i32>,
pub m4: std::collections::HashMap<String, Test_DemoType1>,
}

impl Test_TestJson2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestJson2, LoadError> {
        let __b = Test_TestJson2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            m1: { if !__js["m1"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["m1"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            m2: { if !__js["m2"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["m2"].members() { __map__.insert(match __e[0].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            m3: { if !__js["m3"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["m3"].members() { __map__.insert(match __e[0].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            m4: { if !__js["m4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["m4"].members() { __map__.insert(match __e[0].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }, Test_DemoType1::new(&__e[1])?); }   __map__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestIndex {
    data_list: Vec<std::rc::Rc<Test_TestIndex>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestIndex>>,
}

impl Test_TbTestIndex{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestIndex, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestIndex {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestIndex::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestIndex) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestIndex>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestIndex) -> &Vec<std::rc::Rc<Test_TestIndex>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestIndex, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestIndex>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_TestIndex {
pub id: i32,
pub eles: Vec<Test_DemoType1>,
}

impl Test_TestIndex {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestIndex, LoadError> {
        let __b = Test_TestIndex {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            eles: { if !__js["eles"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["eles"].members() { __list__.push(Test_DemoType1::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestMap {
    data_list: Vec<std::rc::Rc<Test_TestMap>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestMap>>,
}

impl Test_TbTestMap{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestMap, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestMap {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestMap::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestMap) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestMap>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestMap) -> &Vec<std::rc::Rc<Test_TestMap>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestMap, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestMap>> { self.data_map.get(key) }
}



#[allow(non_camel_case_types)]
pub struct Test_TestMap {
pub id: i32,
pub x1: std::collections::HashMap<i32, i32>,
pub x2: std::collections::HashMap<i64, i32>,
pub x3: std::collections::HashMap<String, i32>,
pub x4: std::collections::HashMap<i32, i32>,
}

impl Test_TestMap {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestMap, LoadError> {
        let __b = Test_TestMap {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: { if !__js["x1"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x1"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x2: { if !__js["x2"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x2"].members() { __map__.insert(match __e[0].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x3: { if !__js["x3"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x3"].members() { __map__.insert(match __e[0].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            x4: { if !__js["x4"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["x4"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbDemoGroupDefineFromExcel {
    data_list: Vec<std::rc::Rc<Test_DemoGroup>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>>,
}

impl Test_TbDemoGroupDefineFromExcel{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDemoGroupDefineFromExcel, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDemoGroupDefineFromExcel {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DemoGroup::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDemoGroupDefineFromExcel) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DemoGroup>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDemoGroupDefineFromExcel) -> &Vec<std::rc::Rc<Test_DemoGroup>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDemoGroupDefineFromExcel, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DemoGroup>> { self.data_map.get(key) }
}

#[allow(non_camel_case_types)]
pub struct Test_TbDefineFromExcel2 {
    data_list: Vec<std::rc::Rc<Test_DefineFromExcel2>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_DefineFromExcel2>>,
}

impl Test_TbDefineFromExcel2{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbDefineFromExcel2, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbDefineFromExcel2 {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_DefineFromExcel2::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.id.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbDefineFromExcel2) -> &std::collections::HashMap<i32, std::rc::Rc<Test_DefineFromExcel2>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbDefineFromExcel2) -> &Vec<std::rc::Rc<Test_DefineFromExcel2>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbDefineFromExcel2, key: &i32) -> std::option::Option<&std::rc::Rc<Test_DefineFromExcel2>> { self.data_map.get(key) }
}



/**
 * 
 */
#[allow(non_camel_case_types)]
pub struct Test_DefineFromExcel2 {
pub id: i32,
pub x1: bool,
pub x5: i64,
pub x6: f32,
pub x8: i32,
pub x10: String,
pub x13: i32,
pub x14: Test_DemoDynamic,
pub v2: Vector2,
pub t1: i32,
pub k1: Vec<i32>,
pub k8: std::collections::HashMap<i32, i32>,
pub k9: Vec<Test_DemoE2>,
}

impl Test_DefineFromExcel2 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_DefineFromExcel2, LoadError> {
        let __b = Test_DefineFromExcel2 {
            id: match __js["id"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x1: match __js["x1"].as_bool() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x5: match __js["x5"].as_i64() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x6: match __js["x6"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x8: match __js["x8"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x10: match __js["x10"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x13: match __js["x13"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x14: Test_DemoDynamic::new(&__js["x14"])?,
            v2: Vector2::new(&__js["v2"])?,
            t1: match __js["t1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            k1: { if !__js["k1"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k1"].members() { __list__.push(match __e.as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __list__},
            k8: { if !__js["k8"].is_array() { return Err(LoadError{}); } let mut __map__ = std::collections::HashMap::new(); for __e in __js["k8"].members() { __map__.insert(match __e[0].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }, match __e[1].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) }); }   __map__},
            k9: { if !__js["k9"].is_array() { return Err(LoadError{}); } let mut __list__ = vec![]; for __e in __js["k9"].members() { __list__.push(Test_DemoE2::new(&__e)?); }   __list__},
        };
        Ok(__b)
    }
}


#[allow(non_camel_case_types)]
pub struct Test_TbTestExcelBean {
    data_list: Vec<std::rc::Rc<Test_TestExcelBean1>>,
    data_map: std::collections::HashMap<i32, std::rc::Rc<Test_TestExcelBean1>>,
}

impl Test_TbTestExcelBean{
    pub fn new(__js: &json::JsonValue) -> Result<Test_TbTestExcelBean, LoadError> {
        if !__js.is_array() {
            return Err(LoadError{});
        }
        let mut t = Test_TbTestExcelBean {
            data_list : Vec::new(),
            data_map: std::collections::HashMap::new(),
        };
        
        for __e in __js.members() {
            let __v = std::rc::Rc::new(match Test_TestExcelBean1::new(__e) {
                Ok(x) => x,
                Err(err) => return Err(err),
            });
            let __v2 = std::rc::Rc::clone(&__v);
            t.data_list.push(__v);
            t.data_map.insert(__v2.x1.clone(), __v2);
        }
        Ok(t)
    }
    #[allow(dead_code)]
    pub fn get_data_map(self:&Test_TbTestExcelBean) -> &std::collections::HashMap<i32, std::rc::Rc<Test_TestExcelBean1>> { &self.data_map }
    #[allow(dead_code)]
    pub fn get_data_list(self:&Test_TbTestExcelBean) -> &Vec<std::rc::Rc<Test_TestExcelBean1>> { &self.data_list }
    #[allow(dead_code)]
    pub fn get(self:&Test_TbTestExcelBean, key: &i32) -> std::option::Option<&std::rc::Rc<Test_TestExcelBean1>> { self.data_map.get(key) }
}



/**
 * 这是个测试excel结构
 */
#[allow(non_camel_case_types)]
pub struct Test_TestExcelBean1 {
pub x1: i32,
pub x2: String,
pub x3: i32,
pub x4: f32,
}

impl Test_TestExcelBean1 {
    #[allow(dead_code)]
    pub fn new(__js: &json::JsonValue) -> Result<Test_TestExcelBean1, LoadError> {
        let __b = Test_TestExcelBean1 {
            x1: match __js["x1"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x2: match __js["x2"].as_str() { Some(__x__) => __x__.to_string(), None => return Err(LoadError{}) },
            x3: match __js["x3"].as_i32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
            x4: match __js["x4"].as_f32() { Some(__x__) => __x__, None => return Err(LoadError{}) },
        };
        Ok(__b)
    }
}



type JsonLoader = fn(&str) -> Result<json::JsonValue, LoadError>;

#[allow(non_camel_case_types)]
pub struct Tables {

    pub tbblackboard: Ai_TbBlackboard,

    pub tbbehaviortree: Ai_TbBehaviorTree,

    pub tbclazz: Blueprint_TbClazz,

    pub tbdrop: Bonus_TbDrop,

    pub tbglobalconfig: Common_TbGlobalConfig,

    pub tbdummy: Common_TbDummy,

    pub tberrorinfo: Error_TbErrorInfo,

    pub tbcodeinfo: Error_TbCodeInfo,

    /**
     * 道具表
     */
    pub tbitem: Item_TbItem,

    pub tbitemfunc: Item_TbItemFunc,

    pub tbitemextra: Item_TbItemExtra,

    pub tbl10ndemo: L10n_TbL10NDemo,

    pub tbpatchdemo: L10n_TbPatchDemo,

    pub tbsystemmail: Mail_TbSystemMail,

    pub tbglobalmail: Mail_TbGlobalMail,

    pub tbrolelevelexpattr: Role_TbRoleLevelExpAttr,

    pub tbrolelevelbonuscoefficient: Role_TbRoleLevelBonusCoefficient,

    pub tbtesttag: Tag_TbTestTag,

    pub tbfulltypes: Test_TbFullTypes,

    pub tbsingleton: Test_TbSingleton,

    pub tbdatafrommisc: Test_TbDataFromMisc,

    pub tbmultirowrecord: Test_TbMultiRowRecord,

    pub tbmultirowtitle: Test_TbMultiRowTitle,

    pub tbtestnull: Test_TbTestNull,

    pub tbdemoprimitive: Test_TbDemoPrimitive,

    pub tbteststring: Test_TbTestString,

    pub tbdemogroup: Test_TbDemoGroup,

    pub tbdemogroup_c: Test_TbDemoGroup_C,

    pub tbdemogroup_s: Test_TbDemoGroup_S,

    pub tbdemogroup_e: Test_TbDemoGroup_E,

    pub tbtestglobal: Test_TbTestGlobal,

    pub tbdetectcsvencoding: Test_TbDetectCsvEncoding,

    pub tbdefinefromexcel: Test_TbDefineFromExcel,

    pub tbdefinefromexcelone: Test_TbDefineFromExcelOne,

    pub tbtestjson2: Test_TbTestJson2,

    pub tbtestindex: Test_TbTestIndex,

    pub tbtestmap: Test_TbTestMap,

    pub tbdemogroupdefinefromexcel: Test_TbDemoGroupDefineFromExcel,

    pub tbdefinefromexcel2: Test_TbDefineFromExcel2,

    pub tbtestexcelbean: Test_TbTestExcelBean,
}

impl Tables {
    #[allow(dead_code)]
    pub fn new(loader: JsonLoader) -> std::result::Result<Tables, LoadError> {
        let tables = Tables {
            tbblackboard: Ai_TbBlackboard::new(&loader("ai_tbblackboard")?)?,
            tbbehaviortree: Ai_TbBehaviorTree::new(&loader("ai_tbbehaviortree")?)?,
            tbclazz: Blueprint_TbClazz::new(&loader("blueprint_tbclazz")?)?,
            tbdrop: Bonus_TbDrop::new(&loader("bonus_tbdrop")?)?,
            tbglobalconfig: Common_TbGlobalConfig::new(&loader("common_tbglobalconfig")?)?,
            tbdummy: Common_TbDummy::new(&loader("common_tbdummy")?)?,
            tberrorinfo: Error_TbErrorInfo::new(&loader("error_tberrorinfo")?)?,
            tbcodeinfo: Error_TbCodeInfo::new(&loader("error_tbcodeinfo")?)?,
            tbitem: Item_TbItem::new(&loader("item_tbitem")?)?,
            tbitemfunc: Item_TbItemFunc::new(&loader("item_tbitemfunc")?)?,
            tbitemextra: Item_TbItemExtra::new(&loader("item_tbitemextra")?)?,
            tbl10ndemo: L10n_TbL10NDemo::new(&loader("l10n_tbl10ndemo")?)?,
            tbpatchdemo: L10n_TbPatchDemo::new(&loader("l10n_tbpatchdemo")?)?,
            tbsystemmail: Mail_TbSystemMail::new(&loader("mail_tbsystemmail")?)?,
            tbglobalmail: Mail_TbGlobalMail::new(&loader("mail_tbglobalmail")?)?,
            tbrolelevelexpattr: Role_TbRoleLevelExpAttr::new(&loader("role_tbrolelevelexpattr")?)?,
            tbrolelevelbonuscoefficient: Role_TbRoleLevelBonusCoefficient::new(&loader("role_tbrolelevelbonuscoefficient")?)?,
            tbtesttag: Tag_TbTestTag::new(&loader("tag_tbtesttag")?)?,
            tbfulltypes: Test_TbFullTypes::new(&loader("test_tbfulltypes")?)?,
            tbsingleton: Test_TbSingleton::new(&loader("test_tbsingleton")?)?,
            tbdatafrommisc: Test_TbDataFromMisc::new(&loader("test_tbdatafrommisc")?)?,
            tbmultirowrecord: Test_TbMultiRowRecord::new(&loader("test_tbmultirowrecord")?)?,
            tbmultirowtitle: Test_TbMultiRowTitle::new(&loader("test_tbmultirowtitle")?)?,
            tbtestnull: Test_TbTestNull::new(&loader("test_tbtestnull")?)?,
            tbdemoprimitive: Test_TbDemoPrimitive::new(&loader("test_tbdemoprimitive")?)?,
            tbteststring: Test_TbTestString::new(&loader("test_tbteststring")?)?,
            tbdemogroup: Test_TbDemoGroup::new(&loader("test_tbdemogroup")?)?,
            tbdemogroup_c: Test_TbDemoGroup_C::new(&loader("test_tbdemogroup_c")?)?,
            tbdemogroup_s: Test_TbDemoGroup_S::new(&loader("test_tbdemogroup_s")?)?,
            tbdemogroup_e: Test_TbDemoGroup_E::new(&loader("test_tbdemogroup_e")?)?,
            tbtestglobal: Test_TbTestGlobal::new(&loader("test_tbtestglobal")?)?,
            tbdetectcsvencoding: Test_TbDetectCsvEncoding::new(&loader("test_tbdetectcsvencoding")?)?,
            tbdefinefromexcel: Test_TbDefineFromExcel::new(&loader("test_tbdefinefromexcel")?)?,
            tbdefinefromexcelone: Test_TbDefineFromExcelOne::new(&loader("test_tbdefinefromexcelone")?)?,
            tbtestjson2: Test_TbTestJson2::new(&loader("test_tbtestjson2")?)?,
            tbtestindex: Test_TbTestIndex::new(&loader("test_tbtestindex")?)?,
            tbtestmap: Test_TbTestMap::new(&loader("test_tbtestmap")?)?,
            tbdemogroupdefinefromexcel: Test_TbDemoGroupDefineFromExcel::new(&loader("test_tbdemogroupdefinefromexcel")?)?,
            tbdefinefromexcel2: Test_TbDefineFromExcel2::new(&loader("test_tbdefinefromexcel2")?)?,
            tbtestexcelbean: Test_TbTestExcelBean::new(&loader("test_tbtestexcelbean")?)?,
        };
        return Ok(tables);
    }
}
