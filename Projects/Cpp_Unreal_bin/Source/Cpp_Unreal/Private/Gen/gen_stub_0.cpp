
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{
    bool ai::Blackboard::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if(!BYTEBUF_READ_STRING(_buf, parentName)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); keys.reserve(n);for(int i = 0 ; i < n ; i++) { ai::BlackboardKey* _e;  if(!ai::BlackboardKey::deserializeBlackboardKey(_buf, _e)) return false; keys.push_back(_e);}}

        return true;
    }

    bool ai::Blackboard::deserializeBlackboard(ByteBuf& _buf, ai::Blackboard*& _out)
    {
        _out = new ai::Blackboard();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::BlackboardKey::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        {int _temp_; if(!_buf.readInt(_temp_)) return false; type = ai::EKeyType(_temp_); }
        if(!BYTEBUF_READ_STRING(_buf, typeClassName)) return false;

        return true;
    }

    bool ai::BlackboardKey::deserializeBlackboardKey(ByteBuf& _buf, ai::BlackboardKey*& _out)
    {
        _out = new ai::BlackboardKey();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::BehaviorTree::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if(!BYTEBUF_READ_STRING(_buf, blackboardId)) return false;
        if(!ai::ComposeNode::deserializeComposeNode(_buf, root)) return false;

        return true;
    }

    bool ai::BehaviorTree::deserializeBehaviorTree(ByteBuf& _buf, ai::BehaviorTree*& _out)
    {
        _out = new ai::BehaviorTree();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::Node::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, nodeName)) return false;

        return true;
    }

    bool ai::Node::deserializeNode(ByteBuf& _buf, ai::Node*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::ID: { _out = new ai::UeSetDefaultFocus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ExecuteTimeStatistic::ID: { _out = new ai::ExecuteTimeStatistic(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ChooseTarget::ID: { _out = new ai::ChooseTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::KeepFaceTarget::ID: { _out = new ai::KeepFaceTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::GetOwnerPlayer::ID: { _out = new ai::GetOwnerPlayer(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UpdateDailyBehaviorProps::ID: { _out = new ai::UpdateDailyBehaviorProps(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeLoop::ID: { _out = new ai::UeLoop(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeCooldown::ID: { _out = new ai::UeCooldown(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeTimeLimit::ID: { _out = new ai::UeTimeLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeBlackboard::ID: { _out = new ai::UeBlackboard(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeForceSuccess::ID: { _out = new ai::UeForceSuccess(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::IsAtLocation::ID: { _out = new ai::IsAtLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::DistanceLessThan::ID: { _out = new ai::DistanceLessThan(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::Sequence::ID: { _out = new ai::Sequence(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::Selector::ID: { _out = new ai::Selector(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::SimpleParallel::ID: { _out = new ai::SimpleParallel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeWait::ID: { _out = new ai::UeWait(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out = new ai::UeWaitBlackboardTime(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToTarget::ID: { _out = new ai::MoveToTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ChooseSkill::ID: { _out = new ai::ChooseSkill(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToRandomLocation::ID: { _out = new ai::MoveToRandomLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToLocation::ID: { _out = new ai::MoveToLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::DebugPrint::ID: { _out = new ai::DebugPrint(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::Service::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::Service::deserializeService(ByteBuf& _buf, ai::Service*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::ID: { _out = new ai::UeSetDefaultFocus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ExecuteTimeStatistic::ID: { _out = new ai::ExecuteTimeStatistic(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ChooseTarget::ID: { _out = new ai::ChooseTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::KeepFaceTarget::ID: { _out = new ai::KeepFaceTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::GetOwnerPlayer::ID: { _out = new ai::GetOwnerPlayer(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UpdateDailyBehaviorProps::ID: { _out = new ai::UpdateDailyBehaviorProps(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::UeSetDefaultFocus::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, keyboardKey)) return false;

        return true;
    }

    bool ai::UeSetDefaultFocus::deserializeUeSetDefaultFocus(ByteBuf& _buf, ai::UeSetDefaultFocus*& _out)
    {
        _out = new ai::UeSetDefaultFocus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::ExecuteTimeStatistic::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ExecuteTimeStatistic::deserializeExecuteTimeStatistic(ByteBuf& _buf, ai::ExecuteTimeStatistic*& _out)
    {
        _out = new ai::ExecuteTimeStatistic();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::ChooseTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, resultTargetKey)) return false;

        return true;
    }

    bool ai::ChooseTarget::deserializeChooseTarget(ByteBuf& _buf, ai::ChooseTarget*& _out)
    {
        _out = new ai::ChooseTarget();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::KeepFaceTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, targetActorKey)) return false;

        return true;
    }

    bool ai::KeepFaceTarget::deserializeKeepFaceTarget(ByteBuf& _buf, ai::KeepFaceTarget*& _out)
    {
        _out = new ai::KeepFaceTarget();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::GetOwnerPlayer::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, playerActorKey)) return false;

        return true;
    }

    bool ai::GetOwnerPlayer::deserializeGetOwnerPlayer(ByteBuf& _buf, ai::GetOwnerPlayer*& _out)
    {
        _out = new ai::GetOwnerPlayer();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UpdateDailyBehaviorProps::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, satietyKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, energyKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, moodKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, satietyLowerThresholdKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, satietyUpperThresholdKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, energyLowerThresholdKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, energyUpperThresholdKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, moodLowerThresholdKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, moodUpperThresholdKey)) return false;

        return true;
    }

    bool ai::UpdateDailyBehaviorProps::deserializeUpdateDailyBehaviorProps(ByteBuf& _buf, ai::UpdateDailyBehaviorProps*& _out)
    {
        _out = new ai::UpdateDailyBehaviorProps();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::Decorator::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; flowAbortMode = ai::EFlowAbortMode(_temp_); }

        return true;
    }

    bool ai::Decorator::deserializeDecorator(ByteBuf& _buf, ai::Decorator*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeLoop::ID: { _out = new ai::UeLoop(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeCooldown::ID: { _out = new ai::UeCooldown(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeTimeLimit::ID: { _out = new ai::UeTimeLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeBlackboard::ID: { _out = new ai::UeBlackboard(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeForceSuccess::ID: { _out = new ai::UeForceSuccess(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::IsAtLocation::ID: { _out = new ai::IsAtLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::DistanceLessThan::ID: { _out = new ai::DistanceLessThan(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::UeLoop::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(numLoops)) return false;
        if (!_buf.readBool(infiniteLoop)) return false;
        if(!_buf.readFloat(infiniteLoopTimeoutTime)) return false;

        return true;
    }

    bool ai::UeLoop::deserializeUeLoop(ByteBuf& _buf, ai::UeLoop*& _out)
    {
        _out = new ai::UeLoop();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UeCooldown::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(cooldownTime)) return false;

        return true;
    }

    bool ai::UeCooldown::deserializeUeCooldown(ByteBuf& _buf, ai::UeCooldown*& _out)
    {
        _out = new ai::UeCooldown();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UeTimeLimit::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(limitTime)) return false;

        return true;
    }

    bool ai::UeTimeLimit::deserializeUeTimeLimit(ByteBuf& _buf, ai::UeTimeLimit*& _out)
    {
        _out = new ai::UeTimeLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UeBlackboard::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; notifyObserver = ai::ENotifyObserverMode(_temp_); }
        if(!BYTEBUF_READ_STRING(_buf, blackboardKey)) return false;
        if(!ai::KeyQueryOperator::deserializeKeyQueryOperator(_buf, keyQuery)) return false;

        return true;
    }

    bool ai::UeBlackboard::deserializeUeBlackboard(ByteBuf& _buf, ai::UeBlackboard*& _out)
    {
        _out = new ai::UeBlackboard();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::KeyQueryOperator::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyQueryOperator::deserializeKeyQueryOperator(ByteBuf& _buf, ai::KeyQueryOperator*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::IsSet::ID: { _out = new ai::IsSet(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::IsNotSet::ID: { _out = new ai::IsNotSet(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::BinaryOperator::ID: { _out = new ai::BinaryOperator(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::IsSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsSet::deserializeIsSet(ByteBuf& _buf, ai::IsSet*& _out)
    {
        _out = new ai::IsSet();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::IsNotSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsNotSet::deserializeIsNotSet(ByteBuf& _buf, ai::IsNotSet*& _out)
    {
        _out = new ai::IsNotSet();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::BinaryOperator::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; oper = ai::EOperator(_temp_); }
        if(!ai::KeyData::deserializeKeyData(_buf, data)) return false;

        return true;
    }

    bool ai::BinaryOperator::deserializeBinaryOperator(ByteBuf& _buf, ai::BinaryOperator*& _out)
    {
        _out = new ai::BinaryOperator();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::KeyData::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyData::deserializeKeyData(ByteBuf& _buf, ai::KeyData*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::FloatKeyData::ID: { _out = new ai::FloatKeyData(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::IntKeyData::ID: { _out = new ai::IntKeyData(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::StringKeyData::ID: { _out = new ai::StringKeyData(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::BlackboardKeyData::ID: { _out = new ai::BlackboardKeyData(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::FloatKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(value)) return false;

        return true;
    }

    bool ai::FloatKeyData::deserializeFloatKeyData(ByteBuf& _buf, ai::FloatKeyData*& _out)
    {
        _out = new ai::FloatKeyData();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::IntKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool ai::IntKeyData::deserializeIntKeyData(ByteBuf& _buf, ai::IntKeyData*& _out)
    {
        _out = new ai::IntKeyData();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::StringKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, value)) return false;

        return true;
    }

    bool ai::StringKeyData::deserializeStringKeyData(ByteBuf& _buf, ai::StringKeyData*& _out)
    {
        _out = new ai::StringKeyData();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::BlackboardKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, value)) return false;

        return true;
    }

    bool ai::BlackboardKeyData::deserializeBlackboardKeyData(ByteBuf& _buf, ai::BlackboardKeyData*& _out)
    {
        _out = new ai::BlackboardKeyData();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UeForceSuccess::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::UeForceSuccess::deserializeUeForceSuccess(ByteBuf& _buf, ai::UeForceSuccess*& _out)
    {
        _out = new ai::UeForceSuccess();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::IsAtLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(acceptableRadius)) return false;
        if(!BYTEBUF_READ_STRING(_buf, keyboardKey)) return false;
        if (!_buf.readBool(inverseCondition)) return false;

        return true;
    }

    bool ai::IsAtLocation::deserializeIsAtLocation(ByteBuf& _buf, ai::IsAtLocation*& _out)
    {
        _out = new ai::IsAtLocation();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::DistanceLessThan::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, actor1Key)) return false;
        if(!BYTEBUF_READ_STRING(_buf, actor2Key)) return false;
        if(!_buf.readFloat(distance)) return false;
        if (!_buf.readBool(reverseResult)) return false;

        return true;
    }

    bool ai::DistanceLessThan::deserializeDistanceLessThan(ByteBuf& _buf, ai::DistanceLessThan*& _out)
    {
        _out = new ai::DistanceLessThan();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::FlowNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); decorators.reserve(n);for(int i = 0 ; i < n ; i++) { ai::Decorator* _e;  if(!ai::Decorator::deserializeDecorator(_buf, _e)) return false; decorators.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); services.reserve(n);for(int i = 0 ; i < n ; i++) { ai::Service* _e;  if(!ai::Service::deserializeService(_buf, _e)) return false; services.push_back(_e);}}

        return true;
    }

    bool ai::FlowNode::deserializeFlowNode(ByteBuf& _buf, ai::FlowNode*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::ID: { _out = new ai::Sequence(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::Selector::ID: { _out = new ai::Selector(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::SimpleParallel::ID: { _out = new ai::SimpleParallel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeWait::ID: { _out = new ai::UeWait(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out = new ai::UeWaitBlackboardTime(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToTarget::ID: { _out = new ai::MoveToTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ChooseSkill::ID: { _out = new ai::ChooseSkill(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToRandomLocation::ID: { _out = new ai::MoveToRandomLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToLocation::ID: { _out = new ai::MoveToLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::DebugPrint::ID: { _out = new ai::DebugPrint(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::ComposeNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ComposeNode::deserializeComposeNode(ByteBuf& _buf, ai::ComposeNode*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::ID: { _out = new ai::Sequence(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::Selector::ID: { _out = new ai::Selector(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::SimpleParallel::ID: { _out = new ai::SimpleParallel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::Sequence::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); children.reserve(n);for(int i = 0 ; i < n ; i++) { ai::FlowNode* _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Sequence::deserializeSequence(ByteBuf& _buf, ai::Sequence*& _out)
    {
        _out = new ai::Sequence();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::Selector::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); children.reserve(n);for(int i = 0 ; i < n ; i++) { ai::FlowNode* _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Selector::deserializeSelector(ByteBuf& _buf, ai::Selector*& _out)
    {
        _out = new ai::Selector();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::SimpleParallel::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; finishMode = ai::EFinishMode(_temp_); }
        if(!ai::Task::deserializeTask(_buf, mainTask)) return false;
        if(!ai::FlowNode::deserializeFlowNode(_buf, backgroundNode)) return false;

        return true;
    }

    bool ai::SimpleParallel::deserializeSimpleParallel(ByteBuf& _buf, ai::SimpleParallel*& _out)
    {
        _out = new ai::SimpleParallel();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::Task::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(ignoreRestartSelf)) return false;

        return true;
    }

    bool ai::Task::deserializeTask(ByteBuf& _buf, ai::Task*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeWait::ID: { _out = new ai::UeWait(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out = new ai::UeWaitBlackboardTime(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToTarget::ID: { _out = new ai::MoveToTarget(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::ChooseSkill::ID: { _out = new ai::ChooseSkill(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToRandomLocation::ID: { _out = new ai::MoveToRandomLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::MoveToLocation::ID: { _out = new ai::MoveToLocation(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case ai::DebugPrint::ID: { _out = new ai::DebugPrint(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool ai::UeWait::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(waitTime)) return false;
        if(!_buf.readFloat(randomDeviation)) return false;

        return true;
    }

    bool ai::UeWait::deserializeUeWait(ByteBuf& _buf, ai::UeWait*& _out)
    {
        _out = new ai::UeWait();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::UeWaitBlackboardTime::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, blackboardKey)) return false;

        return true;
    }

    bool ai::UeWaitBlackboardTime::deserializeUeWaitBlackboardTime(ByteBuf& _buf, ai::UeWaitBlackboardTime*& _out)
    {
        _out = new ai::UeWaitBlackboardTime();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::MoveToTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, targetActorKey)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToTarget::deserializeMoveToTarget(ByteBuf& _buf, ai::MoveToTarget*& _out)
    {
        _out = new ai::MoveToTarget();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::ChooseSkill::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, targetActorKey)) return false;
        if(!BYTEBUF_READ_STRING(_buf, resultSkillIdKey)) return false;

        return true;
    }

    bool ai::ChooseSkill::deserializeChooseSkill(ByteBuf& _buf, ai::ChooseSkill*& _out)
    {
        _out = new ai::ChooseSkill();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::MoveToRandomLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, originPositionKey)) return false;
        if(!_buf.readFloat(radius)) return false;

        return true;
    }

    bool ai::MoveToRandomLocation::deserializeMoveToRandomLocation(ByteBuf& _buf, ai::MoveToRandomLocation*& _out)
    {
        _out = new ai::MoveToRandomLocation();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::MoveToLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readVector3(location)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToLocation::deserializeMoveToLocation(ByteBuf& _buf, ai::MoveToLocation*& _out)
    {
        _out = new ai::MoveToLocation();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool ai::DebugPrint::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, text)) return false;

        return true;
    }

    bool ai::DebugPrint::deserializeDebugPrint(ByteBuf& _buf, ai::DebugPrint*& _out)
    {
        _out = new ai::DebugPrint();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::Clazz::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); parents.reserve(n);for(int i = 0 ; i < n ; i++) { blueprint::Clazz* _e;  if(!blueprint::Clazz::deserializeClazz(_buf, _e)) return false; parents.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); methods.reserve(n);for(int i = 0 ; i < n ; i++) { blueprint::Method* _e;  if(!blueprint::Method::deserializeMethod(_buf, _e)) return false; methods.push_back(_e);}}

        return true;
    }

    bool blueprint::Clazz::deserializeClazz(ByteBuf& _buf, blueprint::Clazz*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::Interface::ID: { _out = new blueprint::Interface(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case blueprint::NormalClazz::ID: { _out = new blueprint::NormalClazz(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case blueprint::EnumClazz::ID: { _out = new blueprint::EnumClazz(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool blueprint::Method::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        if(!BYTEBUF_READ_STRING(_buf, returnType)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); parameters.reserve(n);for(int i = 0 ; i < n ; i++) { blueprint::ParamInfo* _e;  if(!blueprint::ParamInfo::deserializeParamInfo(_buf, _e)) return false; parameters.push_back(_e);}}

        return true;
    }

    bool blueprint::Method::deserializeMethod(ByteBuf& _buf, blueprint::Method*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::AbstraceMethod::ID: { _out = new blueprint::AbstraceMethod(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case blueprint::ExternalMethod::ID: { _out = new blueprint::ExternalMethod(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case blueprint::BlueprintMethod::ID: { _out = new blueprint::BlueprintMethod(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool blueprint::ParamInfo::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, type)) return false;
        if (!_buf.readBool(isRef)) return false;

        return true;
    }

    bool blueprint::ParamInfo::deserializeParamInfo(ByteBuf& _buf, blueprint::ParamInfo*& _out)
    {
        _out = new blueprint::ParamInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::AbstraceMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::AbstraceMethod::deserializeAbstraceMethod(ByteBuf& _buf, blueprint::AbstraceMethod*& _out)
    {
        _out = new blueprint::AbstraceMethod();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::ExternalMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::ExternalMethod::deserializeExternalMethod(ByteBuf& _buf, blueprint::ExternalMethod*& _out)
    {
        _out = new blueprint::ExternalMethod();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::BlueprintMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::BlueprintMethod::deserializeBlueprintMethod(ByteBuf& _buf, blueprint::BlueprintMethod*& _out)
    {
        _out = new blueprint::BlueprintMethod();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::Interface::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::Interface::deserializeInterface(ByteBuf& _buf, blueprint::Interface*& _out)
    {
        _out = new blueprint::Interface();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::NormalClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(isAbstract)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); fields.reserve(n);for(int i = 0 ; i < n ; i++) { blueprint::Field* _e;  if(!blueprint::Field::deserializeField(_buf, _e)) return false; fields.push_back(_e);}}

        return true;
    }

    bool blueprint::NormalClazz::deserializeNormalClazz(ByteBuf& _buf, blueprint::NormalClazz*& _out)
    {
        _out = new blueprint::NormalClazz();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::Field::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, type)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;

        return true;
    }

    bool blueprint::Field::deserializeField(ByteBuf& _buf, blueprint::Field*& _out)
    {
        _out = new blueprint::Field();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::EnumClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); enums.reserve(n);for(int i = 0 ; i < n ; i++) { blueprint::EnumField* _e;  if(!blueprint::EnumField::deserializeEnumField(_buf, _e)) return false; enums.push_back(_e);}}

        return true;
    }

    bool blueprint::EnumClazz::deserializeEnumClazz(ByteBuf& _buf, blueprint::EnumClazz*& _out)
    {
        _out = new blueprint::EnumClazz();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool blueprint::EnumField::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool blueprint::EnumField::deserializeEnumField(ByteBuf& _buf, blueprint::EnumField*& _out)
    {
        _out = new blueprint::EnumField();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::DropInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); clientShowItems.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::ShowItemInfo* _e;  if(!bonus::ShowItemInfo::deserializeShowItemInfo(_buf, _e)) return false; clientShowItems.push_back(_e);}}
        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;

        return true;
    }

    bool bonus::DropInfo::deserializeDropInfo(ByteBuf& _buf, bonus::DropInfo*& _out)
    {
        _out = new bonus::DropInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::ShowItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readLong(itemNum)) return false;

        return true;
    }

    bool bonus::ShowItemInfo::deserializeShowItemInfo(ByteBuf& _buf, bonus::ShowItemInfo*& _out)
    {
        _out = new bonus::ShowItemInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::Bonus::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool bonus::Bonus::deserializeBonus(ByteBuf& _buf, bonus::Bonus*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case bonus::OneItem::ID: { _out = new bonus::OneItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::OneItems::ID: { _out = new bonus::OneItems(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::Item::ID: { _out = new bonus::Item(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::Items::ID: { _out = new bonus::Items(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::CoefficientItem::ID: { _out = new bonus::CoefficientItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::WeightItems::ID: { _out = new bonus::WeightItems(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::ProbabilityItems::ID: { _out = new bonus::ProbabilityItems(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::MultiBonus::ID: { _out = new bonus::MultiBonus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::ProbabilityBonus::ID: { _out = new bonus::ProbabilityBonus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::WeightBonus::ID: { _out = new bonus::WeightBonus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case bonus::DropBonus::ID: { _out = new bonus::DropBonus(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool bonus::OneItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool bonus::OneItem::deserializeOneItem(ByteBuf& _buf, bonus::OneItem*& _out)
    {
        _out = new bonus::OneItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::OneItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());items.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;if(!_buf.readInt(_e)) return false; items.push_back(_e);}}

        return true;
    }

    bool bonus::OneItems::deserializeOneItems(ByteBuf& _buf, bonus::OneItems*& _out)
    {
        _out = new bonus::OneItems();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::Item::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool bonus::Item::deserializeItem(ByteBuf& _buf, bonus::Item*& _out)
    {
        _out = new bonus::Item();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::Items::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::Item* _e;if(!bonus::Item::deserializeItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::Items::deserializeItems(ByteBuf& _buf, bonus::Items*& _out)
    {
        _out = new bonus::Items();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::CoefficientItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(bonusId)) return false;
        if(!bonus::Items::deserializeItems(_buf, bonusList)) return false;

        return true;
    }

    bool bonus::CoefficientItem::deserializeCoefficientItem(ByteBuf& _buf, bonus::CoefficientItem*& _out)
    {
        _out = new bonus::CoefficientItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::WeightItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::WeightItemInfo* _e;if(!bonus::WeightItemInfo::deserializeWeightItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::WeightItems::deserializeWeightItems(ByteBuf& _buf, bonus::WeightItems*& _out)
    {
        _out = new bonus::WeightItems();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::WeightItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightItemInfo::deserializeWeightItemInfo(ByteBuf& _buf, bonus::WeightItemInfo*& _out)
    {
        _out = new bonus::WeightItemInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::ProbabilityItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::ProbabilityItemInfo* _e;if(!bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityItems::deserializeProbabilityItems(ByteBuf& _buf, bonus::ProbabilityItems*& _out)
    {
        _out = new bonus::ProbabilityItems();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::ProbabilityItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(ByteBuf& _buf, bonus::ProbabilityItemInfo*& _out)
    {
        _out = new bonus::ProbabilityItemInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::MultiBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::Bonus* _e;if(!bonus::Bonus::deserializeBonus(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::MultiBonus::deserializeMultiBonus(ByteBuf& _buf, bonus::MultiBonus*& _out)
    {
        _out = new bonus::MultiBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::ProbabilityBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::ProbabilityBonusInfo* _e;if(!bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityBonus::deserializeProbabilityBonus(ByteBuf& _buf, bonus::ProbabilityBonus*& _out)
    {
        _out = new bonus::ProbabilityBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::ProbabilityBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(ByteBuf& _buf, bonus::ProbabilityBonusInfo*& _out)
    {
        _out = new bonus::ProbabilityBonusInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::WeightBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { bonus::WeightBonusInfo* _e;if(!bonus::WeightBonusInfo::deserializeWeightBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::WeightBonus::deserializeWeightBonus(ByteBuf& _buf, bonus::WeightBonus*& _out)
    {
        _out = new bonus::WeightBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::WeightBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightBonusInfo::deserializeWeightBonusInfo(ByteBuf& _buf, bonus::WeightBonusInfo*& _out)
    {
        _out = new bonus::WeightBonusInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool bonus::DropBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool bonus::DropBonus::deserializeDropBonus(ByteBuf& _buf, bonus::DropBonus*& _out)
    {
        _out = new bonus::DropBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool common::GlobalConfig::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(bagCapacity)) return false;
        if(!_buf.readInt(bagCapacitySpecial)) return false;
        if(!_buf.readInt(bagTempExpendableCapacity)) return false;
        if(!_buf.readInt(bagTempToolCapacity)) return false;
        if(!_buf.readInt(bagInitCapacity)) return false;
        if(!_buf.readInt(quickBagCapacity)) return false;
        if(!_buf.readInt(clothBagCapacity)) return false;
        if(!_buf.readInt(clothBagInitCapacity)) return false;
        if(!_buf.readInt(clothBagCapacitySpecial)) return false;
        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(bagInitItemsDropId)) return false; } else { bagInitItemsDropId = {}; } }
        if(!_buf.readInt(mailBoxCapacity)) return false;
        if(!_buf.readFloat(damageParamC)) return false;
        if(!_buf.readFloat(damageParamE)) return false;
        if(!_buf.readFloat(damageParamF)) return false;
        if(!_buf.readFloat(damageParamD)) return false;
        if(!_buf.readFloat(roleSpeed)) return false;
        if(!_buf.readFloat(monsterSpeed)) return false;
        if(!_buf.readInt(initEnergy)) return false;
        if(!_buf.readInt(initViality)) return false;
        if(!_buf.readInt(maxViality)) return false;
        if(!_buf.readInt(perVialityRecoveryTime)) return false;

        return true;
    }

    bool common::GlobalConfig::deserializeGlobalConfig(ByteBuf& _buf, common::GlobalConfig*& _out)
    {
        _out = new common::GlobalConfig();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool common::Dummy::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!limit::LimitBase::deserializeLimitBase(_buf, limit)) return false;

        return true;
    }

    bool common::Dummy::deserializeDummy(ByteBuf& _buf, common::Dummy*& _out)
    {
        _out = new common::Dummy();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::LimitBase::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool limit::LimitBase::deserializeLimitBase(ByteBuf& _buf, limit::LimitBase*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case limit::DailyLimit::ID: { _out = new limit::DailyLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case limit::MultiDayLimit::ID: { _out = new limit::MultiDayLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case limit::WeeklyLimit::ID: { _out = new limit::WeeklyLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case limit::MonthlyLimit::ID: { _out = new limit::MonthlyLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case limit::CoolDown::ID: { _out = new limit::CoolDown(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case limit::GroupCoolDown::ID: { _out = new limit::GroupCoolDown(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool limit::DailyLimitBase::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool limit::DailyLimitBase::deserializeDailyLimitBase(ByteBuf& _buf, limit::DailyLimitBase*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case limit::DailyLimit::ID: { _out = new limit::DailyLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool limit::DailyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::DailyLimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::DailyLimit::deserializeDailyLimit(ByteBuf& _buf, limit::DailyLimit*& _out)
    {
        _out = new limit::DailyLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::MultiDayLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(day)) return false;
        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::MultiDayLimit::deserializeMultiDayLimit(ByteBuf& _buf, limit::MultiDayLimit*& _out)
    {
        _out = new limit::MultiDayLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::WeeklyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::WeeklyLimit::deserializeWeeklyLimit(ByteBuf& _buf, limit::WeeklyLimit*& _out)
    {
        _out = new limit::WeeklyLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::MonthlyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::MonthlyLimit::deserializeMonthlyLimit(ByteBuf& _buf, limit::MonthlyLimit*& _out)
    {
        _out = new limit::MonthlyLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::CoolDown::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(duration)) return false;

        return true;
    }

    bool limit::CoolDown::deserializeCoolDown(ByteBuf& _buf, limit::CoolDown*& _out)
    {
        _out = new limit::CoolDown();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool limit::GroupCoolDown::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(groupId)) return false;
        if(!_buf.readInt(duration)) return false;

        return true;
    }

    bool limit::GroupCoolDown::deserializeGroupCoolDown(ByteBuf& _buf, limit::GroupCoolDown*& _out)
    {
        _out = new limit::GroupCoolDown();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::ErrorInfo::deserialize(ByteBuf& _buf)
    {

        if(!BYTEBUF_READ_STRING(_buf, code)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if(!error::ErrorStyle::deserializeErrorStyle(_buf, style)) return false;

        return true;
    }

    bool error::ErrorInfo::deserializeErrorInfo(ByteBuf& _buf, error::ErrorInfo*& _out)
    {
        _out = new error::ErrorInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::ErrorStyle::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool error::ErrorStyle::deserializeErrorStyle(ByteBuf& _buf, error::ErrorStyle*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case error::ErrorStyleTip::ID: { _out = new error::ErrorStyleTip(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case error::ErrorStyleMsgbox::ID: { _out = new error::ErrorStyleMsgbox(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case error::ErrorStyleDlgOk::ID: { _out = new error::ErrorStyleDlgOk(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case error::ErrorStyleDlgOkCancel::ID: { _out = new error::ErrorStyleDlgOkCancel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool error::ErrorStyleTip::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool error::ErrorStyleTip::deserializeErrorStyleTip(ByteBuf& _buf, error::ErrorStyleTip*& _out)
    {
        _out = new error::ErrorStyleTip();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::ErrorStyleMsgbox::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, btnName)) return false;
        {int _temp_; if(!_buf.readInt(_temp_)) return false; operation = error::EOperation(_temp_); }

        return true;
    }

    bool error::ErrorStyleMsgbox::deserializeErrorStyleMsgbox(ByteBuf& _buf, error::ErrorStyleMsgbox*& _out)
    {
        _out = new error::ErrorStyleMsgbox();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::ErrorStyleDlgOk::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, btnName)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOk::deserializeErrorStyleDlgOk(ByteBuf& _buf, error::ErrorStyleDlgOk*& _out)
    {
        _out = new error::ErrorStyleDlgOk();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::ErrorStyleDlgOkCancel::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!BYTEBUF_READ_STRING(_buf, btn1Name)) return false;
        if(!BYTEBUF_READ_STRING(_buf, btn2Name)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOkCancel::deserializeErrorStyleDlgOkCancel(ByteBuf& _buf, error::ErrorStyleDlgOkCancel*& _out)
    {
        _out = new error::ErrorStyleDlgOkCancel();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool error::CodeInfo::deserialize(ByteBuf& _buf)
    {

        {int _temp_; if(!_buf.readInt(_temp_)) return false; code = error::EErrorCode(_temp_); }
        if(!BYTEBUF_READ_STRING(_buf, key)) return false;

        return true;
    }

    bool error::CodeInfo::deserializeCodeInfo(ByteBuf& _buf, error::CodeInfo*& _out)
    {
        _out = new error::CodeInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool item::Item::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, name)) return false;
        {int _temp_; if(!_buf.readInt(_temp_)) return false; majorType = item::EMajorType(_temp_); }
        {int _temp_; if(!_buf.readInt(_temp_)) return false; minorType = item::EMinorType(_temp_); }
        if(!_buf.readInt(maxPileNum)) return false;
        {int _temp_; if(!_buf.readInt(_temp_)) return false; quality = item::EItemQuality(_temp_); }
        if(!BYTEBUF_READ_STRING(_buf, icon)) return false;
        if(!BYTEBUF_READ_STRING(_buf, iconBackgroud)) return false;
        if(!BYTEBUF_READ_STRING(_buf, iconMask)) return false;
        if(!BYTEBUF_READ_STRING(_buf, desc)) return false;
        if(!_buf.readInt(showOrder)) return false;
        if(!BYTEBUF_READ_STRING(_buf, quantifier)) return false;
        if (!_buf.readBool(showInBag)) return false;
        if(!_buf.readInt(minShowLevel)) return false;
        if (!_buf.readBool(batchUsable)) return false;
        if(!_buf.readFloat(progressTimeWhenUse)) return false;
        if (!_buf.readBool(showHintWhenUse)) return false;
        if (!_buf.readBool(droppable)) return false;
        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(price)) return false; } else { price = {}; } }
        {int _temp_; if(!_buf.readInt(_temp_)) return false; useType = item::EUseType(_temp_); }
        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(levelUpId)) return false; } else { levelUpId = {}; } }

        return true;
    }

    bool item::Item::deserializeItem(ByteBuf& _buf, item::Item*& _out)
    {
        _out = new item::Item();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool item::ItemFunction::deserialize(ByteBuf& _buf)
    {

        {int _temp_; if(!_buf.readInt(_temp_)) return false; minorType = item::EMinorType(_temp_); }
        {int _temp_; if(!_buf.readInt(_temp_)) return false; funcType = item::EItemFunctionType(_temp_); }
        if(!BYTEBUF_READ_STRING(_buf, method)) return false;
        if (!_buf.readBool(closeBagUi)) return false;

        return true;
    }

    bool item::ItemFunction::deserializeItemFunction(ByteBuf& _buf, item::ItemFunction*& _out)
    {
        _out = new item::ItemFunction();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool item::ItemExtra::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool item::ItemExtra::deserializeItemExtra(ByteBuf& _buf, item::ItemExtra*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case item::TreasureBox::ID: { _out = new item::TreasureBox(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case item::InteractionItem::ID: { _out = new item::InteractionItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case item::Clothes::ID: { _out = new item::Clothes(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case item::DesignDrawing::ID: { _out = new item::DesignDrawing(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case item::Dymmy::ID: { _out = new item::Dymmy(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool item::TreasureBox::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(keyItemId)) return false; } else { keyItemId = {}; } }
        if(!condition::MinLevel::deserializeMinLevel(_buf, openLevel)) return false;
        if (!_buf.readBool(useOnObtain)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); dropIds.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; dropIds.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); chooseList.reserve(n);for(int i = 0 ; i < n ; i++) { item::ChooseOneBonus* _e;  if(!item::ChooseOneBonus::deserializeChooseOneBonus(_buf, _e)) return false; chooseList.push_back(_e);}}

        return true;
    }

    bool item::TreasureBox::deserializeTreasureBox(ByteBuf& _buf, item::TreasureBox*& _out)
    {
        _out = new item::TreasureBox();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool condition::Condition::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool condition::Condition::deserializeCondition(ByteBuf& _buf, condition::Condition*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::TimeRange::ID: { _out = new condition::TimeRange(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MultiRoleCondition::ID: { _out = new condition::MultiRoleCondition(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::GenderLimit::ID: { _out = new condition::GenderLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinLevel::ID: { _out = new condition::MinLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MaxLevel::ID: { _out = new condition::MaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinMaxLevel::ID: { _out = new condition::MinMaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out = new condition::ClothesPropertyScoreGreaterThan(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::ContainsItem::ID: { _out = new condition::ContainsItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool condition::TimeRange::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }

        if(!common::DateTimeRange::deserializeDateTimeRange(_buf, dateTimeRange)) return false;

        return true;
    }

    bool condition::TimeRange::deserializeTimeRange(ByteBuf& _buf, condition::TimeRange*& _out)
    {
        _out = new condition::TimeRange();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool common::DateTimeRange::deserialize(ByteBuf& _buf)
    {

        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(startTime)) return false; } else { startTime = {}; } }
        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(endTime)) return false; } else { endTime = {}; } }

        return true;
    }

    bool common::DateTimeRange::deserializeDateTimeRange(ByteBuf& _buf, common::DateTimeRange*& _out)
    {
        _out = new common::DateTimeRange();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool condition::RoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::RoleCondition::deserializeRoleCondition(ByteBuf& _buf, condition::RoleCondition*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::MultiRoleCondition::ID: { _out = new condition::MultiRoleCondition(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::GenderLimit::ID: { _out = new condition::GenderLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinLevel::ID: { _out = new condition::MinLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MaxLevel::ID: { _out = new condition::MaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinMaxLevel::ID: { _out = new condition::MinMaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out = new condition::ClothesPropertyScoreGreaterThan(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::ContainsItem::ID: { _out = new condition::ContainsItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool condition::MultiRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());conditions.reserve(n);for(int i = 0 ; i < n ; i++) { condition::RoleCondition* _e;if(!condition::RoleCondition::deserializeRoleCondition(_buf, _e)) return false; conditions.push_back(_e);}}

        return true;
    }

    bool condition::MultiRoleCondition::deserializeMultiRoleCondition(ByteBuf& _buf, condition::MultiRoleCondition*& _out)
    {
        _out = new condition::MultiRoleCondition();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool condition::BoolRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::BoolRoleCondition::deserializeBoolRoleCondition(ByteBuf& _buf, condition::BoolRoleCondition*& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::GenderLimit::ID: { _out = new condition::GenderLimit(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinLevel::ID: { _out = new condition::MinLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MaxLevel::ID: { _out = new condition::MaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::MinMaxLevel::ID: { _out = new condition::MinMaxLevel(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out = new condition::ClothesPropertyScoreGreaterThan(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    }
    bool condition::GenderLimit::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; gender = role::EGenderType(_temp_); }

        return true;
    }

    bool condition::GenderLimit::deserializeGenderLimit(ByteBuf& _buf, condition::GenderLimit*& _out)
    {
        _out = new condition::GenderLimit();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool condition::MinLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MinLevel::deserializeMinLevel(ByteBuf& _buf, condition::MinLevel*& _out)
    {
        _out = new condition::MinLevel();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
    bool condition::MaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MaxLevel::deserializeMaxLevel(ByteBuf& _buf, condition::MaxLevel*& _out)
    {
        _out = new condition::MaxLevel();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    }
}
