
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{
    bool condition::MinMaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(min)) return false;
        if(!_buf.readInt(max)) return false;

        return true;
    }

    bool condition::MinMaxLevel::deserializeMinMaxLevel(ByteBuf& _buf, condition::MinMaxLevel*& _out)
    {
    
        _out = new condition::MinMaxLevel();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool condition::ClothesPropertyScoreGreaterThan::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; prop = item::EClothesPropertyType(_temp_); }
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool condition::ClothesPropertyScoreGreaterThan::deserializeClothesPropertyScoreGreaterThan(ByteBuf& _buf, condition::ClothesPropertyScoreGreaterThan*& _out)
    {
    
        _out = new condition::ClothesPropertyScoreGreaterThan();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool condition::ContainsItem::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if (!_buf.readBool(reverse)) return false;

        return true;
    }

    bool condition::ContainsItem::deserializeContainsItem(ByteBuf& _buf, condition::ContainsItem*& _out)
    {
    
        _out = new condition::ContainsItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool item::ChooseOneBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(dropId)) return false;
        if (!_buf.readBool(isUnique)) return false;

        return true;
    }

    bool item::ChooseOneBonus::deserializeChooseOneBonus(ByteBuf& _buf, item::ChooseOneBonus*& _out)
    {
    
        _out = new item::ChooseOneBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool item::InteractionItem::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _read_succ_; if(!_buf.readBool(_read_succ_)){return false;}  if(_read_succ_) { if(!_buf.readInt(attackNum)) return false; } else { attackNum = {}; } }
        if(!BYTEBUF_READ_STRING(_buf, holdingStaticMesh)) return false;
        if(!BYTEBUF_READ_STRING(_buf, holdingStaticMeshMat)) return false;

        return true;
    }

    bool item::InteractionItem::deserializeInteractionItem(ByteBuf& _buf, item::InteractionItem*& _out)
    {
    
        _out = new item::InteractionItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool item::Clothes::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(attack)) return false;
        if(!_buf.readLong(hp)) return false;
        if(!_buf.readInt(energyLimit)) return false;
        if(!_buf.readInt(energyResume)) return false;

        return true;
    }

    bool item::Clothes::deserializeClothes(ByteBuf& _buf, item::Clothes*& _out)
    {
    
        _out = new item::Clothes();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool item::DesignDrawing::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); learnComponentId.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; learnComponentId.push_back(_e);}}

        return true;
    }

    bool item::DesignDrawing::deserializeDesignDrawing(ByteBuf& _buf, item::DesignDrawing*& _out)
    {
    
        _out = new item::DesignDrawing();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool item::Dymmy::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        if(!cost::Cost::deserializeCost(_buf, cost)) return false;

        return true;
    }

    bool item::Dymmy::deserializeDymmy(ByteBuf& _buf, item::Dymmy*& _out)
    {
    
        _out = new item::Dymmy();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool cost::Cost::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool cost::Cost::deserializeCost(ByteBuf& _buf, cost::Cost*& _out)
    {
    
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case 0 : { _out = nullptr; return true; }
            case cost::CostCurrency::ID: { _out = new cost::CostCurrency(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case cost::CostCurrencies::ID: { _out = new cost::CostCurrencies(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case cost::CostOneItem::ID: { _out = new cost::CostOneItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case cost::CostItem::ID: { _out = new cost::CostItem(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            case cost::CostItems::ID: { _out = new cost::CostItems(); if (_out->deserialize(_buf)) { return true; } else { delete _out; _out = nullptr; return false;} }
            default: { _out = nullptr; return false;}
        }
    
    }
    bool cost::CostCurrency::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {int _temp_; if(!_buf.readInt(_temp_)) return false; type = item::ECurrencyType(_temp_); }
        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool cost::CostCurrency::deserializeCostCurrency(ByteBuf& _buf, cost::CostCurrency*& _out)
    {
    
        _out = new cost::CostCurrency();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool cost::CostCurrencies::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); currencies.reserve(n);for(int i = 0 ; i < n ; i++) { cost::CostCurrency* _e;  if(!cost::CostCurrency::deserializeCostCurrency(_buf, _e)) return false; currencies.push_back(_e);}}

        return true;
    }

    bool cost::CostCurrencies::deserializeCostCurrencies(ByteBuf& _buf, cost::CostCurrencies*& _out)
    {
    
        _out = new cost::CostCurrencies();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool cost::CostOneItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool cost::CostOneItem::deserializeCostOneItem(ByteBuf& _buf, cost::CostOneItem*& _out)
    {
    
        _out = new cost::CostOneItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool cost::CostItem::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool cost::CostItem::deserializeCostItem(ByteBuf& _buf, cost::CostItem*& _out)
    {
    
        _out = new cost::CostItem();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool cost::CostItems::deserialize(ByteBuf& _buf)
    {
        if (!cost::Cost::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { cost::CostItem* _e;if(!cost::CostItem::deserializeCostItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool cost::CostItems::deserializeCostItems(ByteBuf& _buf, cost::CostItems*& _out)
    {
    
        _out = new cost::CostItems();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool l10n::L10NDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(text)) return false;

        return true;
    }

    bool l10n::L10NDemo::deserializeL10NDemo(ByteBuf& _buf, l10n::L10NDemo*& _out)
    {
    
        _out = new l10n::L10NDemo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool l10n::PatchDemo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool l10n::PatchDemo::deserializePatchDemo(ByteBuf& _buf, l10n::PatchDemo*& _out)
    {
    
        _out = new l10n::PatchDemo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool mail::SystemMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, title)) return false;
        if(!BYTEBUF_READ_STRING(_buf, sender)) return false;
        if(!BYTEBUF_READ_STRING(_buf, content)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); award.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}

        return true;
    }

    bool mail::SystemMail::deserializeSystemMail(ByteBuf& _buf, mail::SystemMail*& _out)
    {
    
        _out = new mail::SystemMail();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool mail::GlobalMail::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, title)) return false;
        if(!BYTEBUF_READ_STRING(_buf, sender)) return false;
        if(!BYTEBUF_READ_STRING(_buf, content)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); award.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; award.push_back(_e);}}
        if (!_buf.readBool(allServer)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); serverList.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; serverList.push_back(_e);}}
        if(!BYTEBUF_READ_STRING(_buf, platform)) return false;
        if(!BYTEBUF_READ_STRING(_buf, channel)) return false;
        if(!condition::MinMaxLevel::deserializeMinMaxLevel(_buf, minMaxLevel)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, registerTime)) return false;
        if(!condition::TimeRange::deserializeTimeRange(_buf, mailTime)) return false;

        return true;
    }

    bool mail::GlobalMail::deserializeGlobalMail(ByteBuf& _buf, mail::GlobalMail*& _out)
    {
    
        _out = new mail::GlobalMail();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool role::LevelExpAttr::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(level)) return false;
        if(!_buf.readLong(needExp)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); clothesAttrs.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; clothesAttrs.push_back(_e);}}

        return true;
    }

    bool role::LevelExpAttr::deserializeLevelExpAttr(ByteBuf& _buf, role::LevelExpAttr*& _out)
    {
    
        _out = new role::LevelExpAttr();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool role::LevelBonus::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); distinctBonusInfos.reserve(n);for(int i = 0 ; i < n ; i++) { role::DistinctBonusInfos* _e;  if(!role::DistinctBonusInfos::deserializeDistinctBonusInfos(_buf, _e)) return false; distinctBonusInfos.push_back(_e);}}

        return true;
    }

    bool role::LevelBonus::deserializeLevelBonus(ByteBuf& _buf, role::LevelBonus*& _out)
    {
    
        _out = new role::LevelBonus();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool role::DistinctBonusInfos::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(effectiveLevel)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); bonusInfo.reserve(n);for(int i = 0 ; i < n ; i++) { role::BonusInfo* _e;  if(!role::BonusInfo::deserializeBonusInfo(_buf, _e)) return false; bonusInfo.push_back(_e);}}

        return true;
    }

    bool role::DistinctBonusInfos::deserializeDistinctBonusInfos(ByteBuf& _buf, role::DistinctBonusInfos*& _out)
    {
    
        _out = new role::DistinctBonusInfos();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool role::BonusInfo::deserialize(ByteBuf& _buf)
    {

        {int _temp_; if(!_buf.readInt(_temp_)) return false; type = item::ECurrencyType(_temp_); }
        if(!_buf.readFloat(coefficient)) return false;

        return true;
    }

    bool role::BonusInfo::deserializeBonusInfo(ByteBuf& _buf, role::BonusInfo*& _out)
    {
    
        _out = new role::BonusInfo();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
    bool tag::TestTag::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!BYTEBUF_READ_STRING(_buf, value)) return false;

        return true;
    }

    bool tag::TestTag::deserializeTestTag(ByteBuf& _buf, tag::TestTag*& _out)
    {
    
        _out = new tag::TestTag();
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            delete _out;
            _out = nullptr;
            return false;
        }
    
    }
}
