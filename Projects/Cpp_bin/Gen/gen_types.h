
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once
#include <functional>
#include <memory>

#include "bright/serialization/ByteBuf.h"
#include "bright/CfgBean.hpp"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{



namespace ai {
/**

*/
enum class EExecutor
{
    /**
    
    */
    CLIENT = 0,
    /**
    
    */
    SERVER = 1,
};
}


namespace ai {
/**

*/
enum class EKeyType
{
    /**
    
    */
    BOOL = 1,
    /**
    
    */
    INT = 2,
    /**
    
    */
    FLOAT = 3,
    /**
    
    */
    STRING = 4,
    /**
    
    */
    VECTOR = 5,
    /**
    
    */
    ROTATOR = 6,
    /**
    
    */
    NAME = 7,
    /**
    
    */
    CLASS = 8,
    /**
    
    */
    ENUM = 9,
    /**
    
    */
    OBJECT = 10,
};
}


namespace ai {
/**

*/
enum class EFlowAbortMode
{
    /**
    
    */
    NONE = 0,
    /**
    
    */
    LOWER_PRIORITY = 1,
    /**
    
    */
    SELF = 2,
    /**
    
    */
    BOTH = 3,
};
}


namespace ai {
/**

*/
enum class EFinishMode
{
    /**
    
    */
    IMMEDIATE = 0,
    /**
    
    */
    DELAYED = 1,
};
}


namespace ai {
/**

*/
enum class ENotifyObserverMode
{
    /**
    
    */
    ON_VALUE_CHANGE = 0,
    /**
    
    */
    ON_RESULT_CHANGE = 1,
};
}


namespace ai {
/**

*/
enum class EOperator
{
    /**
    
    */
    IS_EQUAL_TO = 0,
    /**
    
    */
    IS_NOT_EQUAL_TO = 1,
    /**
    
    */
    IS_LESS_THAN = 2,
    /**
    
    */
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    /**
    
    */
    IS_GREAT_THAN = 4,
    /**
    
    */
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    /**
    
    */
    CONTAINS = 6,
    /**
    
    */
    NOT_CONTAINS = 7,
};
}


namespace common {
/**

*/
enum class EBoolOperator
{
    /**
    
    */
    AND = 0,
    /**
    
    */
    OR = 1,
};
}


namespace error {
/**

*/
enum class EOperation
{
    /**
    
    */
    LOGOUT = 0,
    /**
    
    */
    RESTART = 1,
};
}


namespace error {
/**

*/
enum class EErrorCode
{
    /**
    
    */
    OK = 0,
    /**
    
    */
    SERVER_NOT_EXISTS = 1,
    /**
    
    */
    HAS_BIND_SERVER = 2,
    /**
    
    */
    AUTH_FAIL = 3,
    /**
    
    */
    NOT_BIND_SERVER = 4,
    /**
    
    */
    SERVER_ACCESS_FAIL = 5,
    /**
    
    */
    EXAMPLE_FLASH = 6,
    /**
    
    */
    EXAMPLE_MSGBOX = 7,
    /**
    
    */
    EXAMPLE_DLG_OK = 8,
    /**
    
    */
    EXAMPLE_DLG_OK_CANCEL = 9,
    /**
    
    */
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    /**
    
    */
    ROLE_CREATE_NAME_EMPTY = 101,
    /**
    
    */
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    /**
    
    */
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    /**
    
    */
    ROLE_CREATE_INVALID_PROFESSION = 104,
    /**
    
    */
    ROLE_CREATE_INVALID_GENDER = 105,
    /**
    
    */
    ROLE_NOT_OWNED_BY_USER = 106,
    /**
    
    */
    ROLE_LEVEL_NOT_ARRIVE = 107,
    /**
    
    */
    PARAM_ILLEGAL = 200,
    /**
    
    */
    TEMP_BAG_NOT_EMPTY = 201,
    /**
    
    */
    ITEM_CAN_NOT_USE = 202,
    /**
    
    */
    CURRENCY_NOT_ENOUGH = 203,
    /**
    
    */
    BAG_IS_FULL = 204,
    /**
    
    */
    ITEM_NOT_ENOUGH = 205,
    /**
    
    */
    ITEM_IN_BAG = 206,
    /**
    
    */
    GENDER_NOT_MATCH = 300,
    /**
    
    */
    LEVEL_TOO_LOW = 301,
    /**
    
    */
    LEVEL_TOO_HIGH = 302,
    /**
    
    */
    EXCEED_LIMIT = 303,
    /**
    
    */
    OVER_TIME = 304,
    /**
    
    */
    SERVER_ERROR = 305,
    /**
    
    */
    SKILL_NOT_IN_LIST = 400,
    /**
    
    */
    SKILL_NOT_COOLDOWN = 401,
    /**
    
    */
    SKILL_TARGET_NOT_EXIST = 402,
    /**
    
    */
    SKILL_ANOTHER_CASTING = 403,
    /**
    
    */
    SKILL_OUT_OF_DISTANCE = 404,
    /**
    
    */
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    /**
    
    */
    SKILL_INVALID_DIRECTION = 406,
    /**
    
    */
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    /**
    
    */
    SKILL_ENERGY_NOT_ENOUGH = 408,
    /**
    
    */
    DIALOG_NODE_NOT_CHOOSEN = 500,
    /**
    
    */
    DIALOG_NOT_FINISH = 501,
    /**
    
    */
    DIALOG_HAS_FINISH = 502,
    /**
    
    */
    QUEST_STAGE_NOT_FINISHED = 503,
    /**
    
    */
    QUEST_NOT_DOING = 504,
    /**
    
    */
    QUEST_STAGE_NOT_DOING = 505,
    /**
    
    */
    QUEST_HAS_ACCEPTED = 506,
    /**
    
    */
    MAP_OBJECT_NOT_EXIST = 600,
    /**
    
    */
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    /**
    
    */
    HAS_NOT_EQUIP = 602,
    /**
    
    */
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    /**
    
    */
    NOT_AVAILABLE_SUIT_ID = 604,
    /**
    
    */
    NO_INTERACTION_COMPONENT = 605,
    /**
    
    */
    HAS_INTERACTED = 606,
    /**
    
    */
    VIALITY_NOT_ENOUGH = 607,
    /**
    
    */
    PLAYER_SESSION_NOT_EXIST = 608,
    /**
    
    */
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    /**
    
    */
    MAP_NOT_EXIST = 610,
    /**
    
    */
    MAIL_TYPE_ERROR = 700,
    /**
    
    */
    MAIL_NOT_EXITST = 701,
    /**
    
    */
    MAIL_HAVE_DELETED = 702,
    /**
    
    */
    MAIL_AWARD_HAVE_RECEIVED = 703,
    /**
    
    */
    MAIL_OPERATE_TYPE_ERROR = 704,
    /**
    
    */
    MAIL_CONDITION_NOT_MEET = 705,
    /**
    
    */
    MAIL_STATE_ERROR = 706,
    /**
    
    */
    MAIL_NO_AWARD = 707,
    /**
    
    */
    MAIL_BOX_IS_FULL = 708,
    /**
    
    */
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    /**
    
    */
    NOT_WEAR_CLOTHES = 801,
    /**
    
    */
    NOT_WEAR_SUIT = 802,
    /**
    
    */
    SUIT_NOT_UNLOCK = 900,
    /**
    
    */
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    /**
    
    */
    SUIT_STATE_ERROR = 902,
    /**
    
    */
    SUIT_COMPONENT_STATE_ERROR = 903,
    /**
    
    */
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    /**
    
    */
    STORE_NOT_ENABLED = 1000,
    /**
    
    */
    SHELF_NOT_ENABLED = 1001,
    /**
    
    */
    GOODS_NOT_ENABLED = 1002,
    /**
    
    */
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    /**
    
    */
    RETRY = 1100,
    /**
    
    */
    NOT_COOLDOWN = 1101,
    /**
    
    */
    SELFIE_UNLOCK = 1200,
    /**
    
    */
    SELFIE_ALREADY_UNLOCK = 1201,
    /**
    
    */
    SELFIE_LACK_STARTS = 1202,
    /**
    
    */
    SELFIE_HAD_REWARD = 1203,
};
}


namespace item {
/**
道具品质
*/
enum class EItemQuality
{
    /**
    白
    */
    WHITE = 0,
    /**
    
    */
    GREEN = 1,
    /**
    
    */
    BLUE = 2,
    /**
    
    */
    PURPLE = 3,
    /**
    
    */
    GOLDEN = 4,
};
}


namespace item {
/**

*/
enum class ECurrencyType
{
    /**
    
    */
    DIAMOND = 1,
    /**
    
    */
    GOLD = 2,
    /**
    
    */
    SILVER = 3,
    /**
    
    */
    EXP = 4,
    /**
    
    */
    POWER_POINT = 5,
};
}


namespace item {
/**

*/
enum class EMajorType
{
    /**
    
    */
    CURRENCY = 1,
    /**
    
    */
    CLOTH = 2,
    /**
    
    */
    QUEST = 3,
    /**
    
    */
    CONSUMABLES = 4,
    /**
    
    */
    TREASURE_BOX = 5,
    /**
    
    */
    ACHIEVEMENT_AND_TITLE = 6,
    /**
    
    */
    HEAD_FRAME = 7,
    /**
    
    */
    VOICE = 8,
    /**
    
    */
    ACTION = 9,
    /**
    
    */
    EXPANSION = 10,
    /**
    
    */
    MATERIAL = 11,
};
}


namespace item {
/**

*/
enum class EMinorType
{
    /**
    
    */
    DIAMOND = 101,
    /**
    
    */
    GOLD = 102,
    /**
    
    */
    SILVER = 103,
    /**
    
    */
    EXP = 104,
    /**
    
    */
    POWER_POINT = 105,
    /**
    
    */
    HAIR_STYLE = 210,
    /**
    
    */
    COAT = 220,
    /**
    
    */
    UPPER_JACKET = 230,
    /**
    
    */
    TROUSERS = 241,
    /**
    
    */
    SKIRT = 242,
    /**
    
    */
    SOCKS = 250,
    /**
    
    */
    SHOES = 260,
    /**
    
    */
    HAIR_ACCESSORY = 271,
    /**
    
    */
    HAT = 272,
    /**
    
    */
    EARRING = 273,
    /**
    
    */
    NECKLACE = 274,
    /**
    
    */
    BRACELET = 275,
    /**
    
    */
    HAIR_CLASP = 276,
    /**
    
    */
    GLOVE = 277,
    /**
    
    */
    HANDHELD_OBJECT = 278,
    /**
    
    */
    SPECIAL = 279,
    /**
    
    */
    BASE_COSMETIC = 281,
    /**
    
    */
    EYEBROW_COSMETIC = 282,
    /**
    
    */
    EYELASH = 283,
    /**
    
    */
    COSMETIC_CONTACT_LENSES = 284,
    /**
    
    */
    LIP_COSMETIC = 285,
    /**
    
    */
    SKIN_COLOR = 286,
    /**
    
    */
    ONE_PIECE_DRESS = 290,
    /**
    
    */
    SWITCH_CLOTHES_SCENE = 291,
    /**
    
    */
    QUEST = 301,
    /**
    
    */
    CAST = 401,
    /**
    
    */
    SWORD = 421,
    /**
    
    */
    BOW_ARROW = 422,
    /**
    
    */
    WANDS = 423,
    /**
    
    */
    SPECIAL_TOOL = 424,
    /**
    
    */
    FOOD = 403,
    /**
    
    */
    TREASURE_BOX = 501,
    /**
    
    */
    KEY = 502,
    /**
    
    */
    MULTI_CHOOSE_TREASURE_BOX = 503,
    /**
    
    */
    ACHIEVEMENT = 601,
    /**
    
    */
    TITLE = 602,
    /**
    
    */
    AVATAR_FRAME = 701,
    /**
    
    */
    VOICE = 801,
    /**
    
    */
    IDLE_POSE = 901,
    /**
    
    */
    PHOTO_POSE = 902,
    /**
    
    */
    BAG = 1001,
    /**
    
    */
    FRIEND_CAPACITY = 1002,
    /**
    
    */
    CONSTRUCTION_MATERIAL = 1101,
    /**
    
    */
    DESIGN_DRAWING = 1102,
};
}


namespace item {
/**

*/
enum class EClothersStarQualityType
{
    /**
    
    */
    ONE = 1,
    /**
    
    */
    TWO = 2,
    /**
    
    */
    THREE = 3,
    /**
    
    */
    FOUR = 4,
    /**
    
    */
    FIVE = 5,
    /**
    
    */
    SIX = 6,
    /**
    
    */
    SEVEN = 7,
    /**
    
    */
    EIGHT = 8,
    /**
    
    */
    NINE = 9,
    /**
    
    */
    TEN = 10,
};
}


namespace item {
/**

*/
enum class EClothersTag
{
    /**
    
    */
    FANG_SHAI = 1,
    /**
    
    */
    WU_ZHE = 2,
};
}


namespace item {
/**

*/
enum class EUseType
{
    /**
    
    */
    MANUAL = 0,
    /**
    
    */
    AUTO = 1,
};
}


namespace item {
/**

*/
enum class EClothesHidePartType
{
    /**
    
    */
    CHEST = 0,
    /**
    
    */
    HEAD = 1,
    /**
    
    */
    SPINE_UPPER = 2,
    /**
    
    */
    SPINE_LOWER = 3,
    /**
    
    */
    HIP = 4,
    /**
    
    */
    LEG_UPPER = 5,
    /**
    
    */
    LEG_MIDDLE = 6,
    /**
    
    */
    LEG_LOWER = 7,
};
}


namespace item {
/**

*/
enum class EClothesPropertyType
{
    /**
    
    */
    JIAN_YUE = 1,
    /**
    
    */
    HUA_LI = 2,
    /**
    
    */
    KE_AI = 3,
    /**
    
    */
    CHENG_SHU = 4,
    /**
    
    */
    HUO_PO = 5,
    /**
    
    */
    YOU_YA = 6,
    /**
    
    */
    QING_CHUN = 7,
    /**
    
    */
    XING_GAN = 8,
    /**
    
    */
    QING_LIANG = 9,
    /**
    
    */
    BAO_NUAN = 10,
};
}


namespace item {
/**

*/
enum class EItemFunctionType
{
    /**
    
    */
    REPLACE_HANDHELD = 0,
    /**
    
    */
    USE_DESIGN_DRAWING = 1,
};
}


namespace limit {
/**

*/
enum class ENamespace
{
    /**
    
    */
    ITEM_DAILY_OBTAIN = 1,
    /**
    
    */
    TREASURE_DAILY_USE = 2,
    /**
    
    */
    STORE_GOODS_LIMIT_BUY = 3,
};
}


namespace mail {
/**

*/
enum class EMailType
{
    /**
    
    */
    GLOBAL = 0,
    /**
    
    */
    SYSTEM = 1,
};
}


namespace role {
/**

*/
enum class EGenderType
{
    /**
    
    */
    MALE = 1,
    /**
    
    */
    FEMALE = 2,
};
}


namespace role {
/**

*/
enum class EProfession
{
    /**
    
    */
    TEST_PROFESSION = 1,
};
}


namespace test {
/**

*/
enum class DemoEnum
{
    /**
    
    */
    A = 1,
    /**
    
    */
    B = 2,
    /**
    
    */
    C = 4,
    /**
    
    */
    D = 5,
};
}


namespace test {
/**

*/
enum class ETestUeType
{
    /**
    
    */
    WHITE = 0,
    /**
    
    */
    BLACK = 1,
};
}


namespace test {
/**

*/
enum class ETestEmptyEnum
{
};
}


namespace test {
/**

*/
enum class ETestEmptyEnum2
{
    /**
    
    */
    SMALL_THAN_256 = 255,
    /**
    
    */
    X_256 = 256,
    /**
    
    */
    X_257 = 257,
};
}


namespace test {
/**

*/
enum class ETestQuality
{
    /**
    最高品质
    */
    A = 1,
    /**
    黑色的
    */
    B = 2,
    /**
    蓝色的
    */
    C = 3,
    /**
    最差品质
    */
    D = 4,
};
}


namespace test {
/**

*/
enum class ETestCurrency
{
    /**
    重要
    */
    DIAMOND = 1,
    /**
    有用
    */
    GOLD = 2,
};
}


namespace role {
/**

*/
struct Consts
{
    /**
    
    */
    static constexpr int32_t MAX_NAME_LENGTH = 20;
    /**
    
    */
    static constexpr int32_t MAX_USER_ROLE_NUM = 10;
};
}



namespace test {
/**

*/
struct DemoConst
{
    /**
    
    */
    static constexpr int32_t x1 = 0;
    /**
    
    */
    static constexpr int64_t x2 = 3242L;
    /**
    
    */
    static constexpr float x3 = 444.3f;
    /**
    
    */
    static constexpr double x4 = 55.3;
};
}


namespace ai { class Blackboard; } 
namespace ai { class BlackboardKey; } 
namespace ai { class BehaviorTree; } 
namespace ai { class Node; } 
namespace ai { class Service; } 
namespace ai { class UeSetDefaultFocus; } 
namespace ai { class ExecuteTimeStatistic; } 
namespace ai { class ChooseTarget; } 
namespace ai { class KeepFaceTarget; } 
namespace ai { class GetOwnerPlayer; } 
namespace ai { class UpdateDailyBehaviorProps; } 
namespace ai { class Decorator; } 
namespace ai { class UeLoop; } 
namespace ai { class UeCooldown; } 
namespace ai { class UeTimeLimit; } 
namespace ai { class UeBlackboard; } 
namespace ai { class KeyQueryOperator; } 
namespace ai { class IsSet; } 
namespace ai { class IsNotSet; } 
namespace ai { class BinaryOperator; } 
namespace ai { class KeyData; } 
namespace ai { class FloatKeyData; } 
namespace ai { class IntKeyData; } 
namespace ai { class StringKeyData; } 
namespace ai { class BlackboardKeyData; } 
namespace ai { class UeForceSuccess; } 
namespace ai { class IsAtLocation; } 
namespace ai { class DistanceLessThan; } 
namespace ai { class FlowNode; } 
namespace ai { class ComposeNode; } 
namespace ai { class Sequence; } 
namespace ai { class Selector; } 
namespace ai { class SimpleParallel; } 
namespace ai { class Task; } 
namespace ai { class UeWait; } 
namespace ai { class UeWaitBlackboardTime; } 
namespace ai { class MoveToTarget; } 
namespace ai { class ChooseSkill; } 
namespace ai { class MoveToRandomLocation; } 
namespace ai { class MoveToLocation; } 
namespace ai { class DebugPrint; } 
namespace blueprint { class Clazz; } 
namespace blueprint { class Method; } 
namespace blueprint { class ParamInfo; } 
namespace blueprint { class AbstraceMethod; } 
namespace blueprint { class ExternalMethod; } 
namespace blueprint { class BlueprintMethod; } 
namespace blueprint { class Interface; } 
namespace blueprint { class NormalClazz; } 
namespace blueprint { class Field; } 
namespace blueprint { class EnumClazz; } 
namespace blueprint { class EnumField; } 
namespace bonus { class DropInfo; } 
namespace bonus { class ShowItemInfo; } 
namespace bonus { class Bonus; } 
namespace bonus { class OneItem; } 
namespace bonus { class OneItems; } 
namespace bonus { class Item; } 
namespace bonus { class Items; } 
namespace bonus { class CoefficientItem; } 
namespace bonus { class WeightItems; } 
namespace bonus { class WeightItemInfo; } 
namespace bonus { class ProbabilityItems; } 
namespace bonus { class ProbabilityItemInfo; } 
namespace bonus { class MultiBonus; } 
namespace bonus { class ProbabilityBonus; } 
namespace bonus { class ProbabilityBonusInfo; } 
namespace bonus { class WeightBonus; } 
namespace bonus { class WeightBonusInfo; } 
namespace bonus { class DropBonus; } 
namespace common { class GlobalConfig; } 
namespace common { class Dummy; } 
namespace limit { class LimitBase; } 
namespace limit { class DailyLimitBase; } 
namespace limit { class DailyLimit; } 
namespace limit { class MultiDayLimit; } 
namespace limit { class WeeklyLimit; } 
namespace limit { class MonthlyLimit; } 
namespace limit { class CoolDown; } 
namespace limit { class GroupCoolDown; } 
namespace error { class ErrorInfo; } 
namespace error { class ErrorStyle; } 
namespace error { class ErrorStyleTip; } 
namespace error { class ErrorStyleMsgbox; } 
namespace error { class ErrorStyleDlgOk; } 
namespace error { class ErrorStyleDlgOkCancel; } 
namespace error { class CodeInfo; } 
namespace item { class Item; } 
namespace item { class ItemFunction; } 
namespace item { class ItemExtra; } 
namespace item { class TreasureBox; } 
namespace condition { class Condition; } 
namespace condition { class TimeRange; } 
namespace common { class DateTimeRange; } 
namespace condition { class RoleCondition; } 
namespace condition { class MultiRoleCondition; } 
namespace condition { class BoolRoleCondition; } 
namespace condition { class GenderLimit; } 
namespace condition { class MinLevel; } 
namespace condition { class MaxLevel; } 
namespace condition { class MinMaxLevel; } 
namespace condition { class ClothesPropertyScoreGreaterThan; } 
namespace condition { class ContainsItem; } 
namespace item { class ChooseOneBonus; } 
namespace item { class InteractionItem; } 
namespace item { class Clothes; } 
namespace item { class DesignDrawing; } 
namespace item { class Dymmy; } 
namespace cost { class Cost; } 
namespace cost { class CostCurrency; } 
namespace cost { class CostCurrencies; } 
namespace cost { class CostOneItem; } 
namespace cost { class CostItem; } 
namespace cost { class CostItems; } 
namespace l10n { class L10NDemo; } 
namespace l10n { class PatchDemo; } 
namespace mail { class SystemMail; } 
namespace mail { class GlobalMail; } 
namespace role { class LevelExpAttr; } 
namespace role { class LevelBonus; } 
namespace role { class DistinctBonusInfos; } 
namespace role { class BonusInfo; } 
namespace tag { class TestTag; } 
namespace test { class DemoType2; } 
namespace test { class DemoType1; } 
namespace test { class DemoDynamic; } 
namespace test { class DemoD2; } 
namespace test { class DemoD3; } 
namespace test { class DemoE1; } 
namespace test { class DemoD5; } 
namespace test { class DateTimeRange; } 
namespace test { class DemoE2; } 
namespace test { class DemoSingletonType; } 
namespace test { class MultiRowRecord; } 
namespace test { class MultiRowType1; } 
namespace test { class MultiRowType2; } 
namespace test { class MultiRowType3; } 
namespace test { class MultiRowTitle; } 
namespace test { class H1; } 
namespace test { class H2; } 
namespace test { class TestNull; } 
namespace test { class DemoPrimitiveTypesTable; } 
namespace test { class TestString; } 
namespace test { class CompactString; } 
namespace test { class DemoGroup; } 
namespace test { class InnerGroup; } 
namespace test { class TestGlobal; } 
namespace test { class DetectEncoding; } 
namespace test { class DefineFromExcel; } 
namespace test { class DefineFromExcelOne; } 
namespace test { class DefineFromExcel2; } 
namespace test { class TestExcelBean1; } 

namespace ai {





/**

 */
class Blackboard : public  bright::CfgBean 
{
    public:

    static bool deserializeBlackboard(ByteBuf& _buf, std::shared_ptr<Blackboard>& _out);

    Blackboard()
    { 

    }

    Blackboard(std::string name, std::string desc, std::string parent_name, std::vector<std::shared_ptr<ai::BlackboardKey>> keys ) 
    {

        this->name = name;
        this->desc = desc;
        this->parentName = parent_name;
        this->keys = keys;
    }
    virtual ~Blackboard() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string desc;
    /**
     
     */
    std::string parentName;
    std::shared_ptr<ai::Blackboard> parentName_Ref;
    /**
     
     */
    std::vector<std::shared_ptr<ai::BlackboardKey>> keys;

    static constexpr int ID = 1576193005;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class BlackboardKey : public  bright::CfgBean 
{
    public:

    static bool deserializeBlackboardKey(ByteBuf& _buf, std::shared_ptr<BlackboardKey>& _out);

    BlackboardKey()
    { 

    }

    BlackboardKey(std::string name, std::string desc, bool is_static, ai::EKeyType type, std::string type_class_name ) 
    {

        this->name = name;
        this->desc = desc;
        this->isStatic = is_static;
        this->type = type;
        this->typeClassName = type_class_name;
    }
    virtual ~BlackboardKey() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string desc;
    /**
     
     */
    bool isStatic;
    /**
     
     */
    ai::EKeyType type;
    /**
     
     */
    std::string typeClassName;

    static constexpr int ID = -511559886;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class BehaviorTree : public  bright::CfgBean 
{
    public:

    static bool deserializeBehaviorTree(ByteBuf& _buf, std::shared_ptr<BehaviorTree>& _out);

    BehaviorTree()
    { 

    }

    BehaviorTree(int32_t id, std::string name, std::string desc, std::string blackboard_id, std::shared_ptr<ai::ComposeNode> root ) 
    {

        this->id = id;
        this->name = name;
        this->desc = desc;
        this->blackboardId = blackboard_id;
        this->root = root;
    }
    virtual ~BehaviorTree() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string name;
    /**
     
     */
    std::string desc;
    /**
     
     */
    std::string blackboardId;
    std::shared_ptr<ai::Blackboard> blackboardId_Ref;
    /**
     
     */
    std::shared_ptr<ai::ComposeNode> root;

    static constexpr int ID = 159552822;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Node : public  bright::CfgBean 
{
    public:

    static bool deserializeNode(ByteBuf& _buf, std::shared_ptr<Node>& _out);

    Node()
    { 

    }

    Node(int32_t id, std::string node_name ) 
    {

        this->id = id;
        this->nodeName = node_name;
    }
    virtual ~Node() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string nodeName;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Service : public  ai::Node 
{
    public:

    static bool deserializeService(ByteBuf& _buf, std::shared_ptr<Service>& _out);

    Service()
    { 

    }

    Service(int32_t id, std::string node_name ) 
            : ai::Node(id, node_name)
    {

    }
    virtual ~Service() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeSetDefaultFocus : public  ai::Service 
{
    public:

    static bool deserializeUeSetDefaultFocus(ByteBuf& _buf, std::shared_ptr<UeSetDefaultFocus>& _out);

    UeSetDefaultFocus()
    { 

    }

    UeSetDefaultFocus(int32_t id, std::string node_name, std::string keyboard_key ) 
            : ai::Service(id, node_name)
    {

        this->keyboardKey = keyboard_key;
    }
    virtual ~UeSetDefaultFocus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string keyboardKey;

    static constexpr int ID = 1812449155;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class ExecuteTimeStatistic : public  ai::Service 
{
    public:

    static bool deserializeExecuteTimeStatistic(ByteBuf& _buf, std::shared_ptr<ExecuteTimeStatistic>& _out);

    ExecuteTimeStatistic()
    { 

    }

    ExecuteTimeStatistic(int32_t id, std::string node_name ) 
            : ai::Service(id, node_name)
    {

    }
    virtual ~ExecuteTimeStatistic() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 990693812;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class ChooseTarget : public  ai::Service 
{
    public:

    static bool deserializeChooseTarget(ByteBuf& _buf, std::shared_ptr<ChooseTarget>& _out);

    ChooseTarget()
    { 

    }

    ChooseTarget(int32_t id, std::string node_name, std::string result_target_key ) 
            : ai::Service(id, node_name)
    {

        this->resultTargetKey = result_target_key;
    }
    virtual ~ChooseTarget() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string resultTargetKey;

    static constexpr int ID = 1601247918;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class KeepFaceTarget : public  ai::Service 
{
    public:

    static bool deserializeKeepFaceTarget(ByteBuf& _buf, std::shared_ptr<KeepFaceTarget>& _out);

    KeepFaceTarget()
    { 

    }

    KeepFaceTarget(int32_t id, std::string node_name, std::string target_actor_key ) 
            : ai::Service(id, node_name)
    {

        this->targetActorKey = target_actor_key;
    }
    virtual ~KeepFaceTarget() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string targetActorKey;

    static constexpr int ID = 1195270745;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class GetOwnerPlayer : public  ai::Service 
{
    public:

    static bool deserializeGetOwnerPlayer(ByteBuf& _buf, std::shared_ptr<GetOwnerPlayer>& _out);

    GetOwnerPlayer()
    { 

    }

    GetOwnerPlayer(int32_t id, std::string node_name, std::string player_actor_key ) 
            : ai::Service(id, node_name)
    {

        this->playerActorKey = player_actor_key;
    }
    virtual ~GetOwnerPlayer() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string playerActorKey;

    static constexpr int ID = -999247644;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UpdateDailyBehaviorProps : public  ai::Service 
{
    public:

    static bool deserializeUpdateDailyBehaviorProps(ByteBuf& _buf, std::shared_ptr<UpdateDailyBehaviorProps>& _out);

    UpdateDailyBehaviorProps()
    { 

    }

    UpdateDailyBehaviorProps(int32_t id, std::string node_name, std::string satiety_key, std::string energy_key, std::string mood_key, std::string satiety_lower_threshold_key, std::string satiety_upper_threshold_key, std::string energy_lower_threshold_key, std::string energy_upper_threshold_key, std::string mood_lower_threshold_key, std::string mood_upper_threshold_key ) 
            : ai::Service(id, node_name)
    {

        this->satietyKey = satiety_key;
        this->energyKey = energy_key;
        this->moodKey = mood_key;
        this->satietyLowerThresholdKey = satiety_lower_threshold_key;
        this->satietyUpperThresholdKey = satiety_upper_threshold_key;
        this->energyLowerThresholdKey = energy_lower_threshold_key;
        this->energyUpperThresholdKey = energy_upper_threshold_key;
        this->moodLowerThresholdKey = mood_lower_threshold_key;
        this->moodUpperThresholdKey = mood_upper_threshold_key;
    }
    virtual ~UpdateDailyBehaviorProps() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string satietyKey;
    /**
     
     */
    std::string energyKey;
    /**
     
     */
    std::string moodKey;
    /**
     
     */
    std::string satietyLowerThresholdKey;
    /**
     
     */
    std::string satietyUpperThresholdKey;
    /**
     
     */
    std::string energyLowerThresholdKey;
    /**
     
     */
    std::string energyUpperThresholdKey;
    /**
     
     */
    std::string moodLowerThresholdKey;
    /**
     
     */
    std::string moodUpperThresholdKey;

    static constexpr int ID = -61887372;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Decorator : public  ai::Node 
{
    public:

    static bool deserializeDecorator(ByteBuf& _buf, std::shared_ptr<Decorator>& _out);

    Decorator()
    { 

    }

    Decorator(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode ) 
            : ai::Node(id, node_name)
    {

        this->flowAbortMode = flow_abort_mode;
    }
    virtual ~Decorator() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    ai::EFlowAbortMode flowAbortMode;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeLoop : public  ai::Decorator 
{
    public:

    static bool deserializeUeLoop(ByteBuf& _buf, std::shared_ptr<UeLoop>& _out);

    UeLoop()
    { 

    }

    UeLoop(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, int32_t num_loops, bool infinite_loop, float infinite_loop_timeout_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->numLoops = num_loops;
        this->infiniteLoop = infinite_loop;
        this->infiniteLoopTimeoutTime = infinite_loop_timeout_time;
    }
    virtual ~UeLoop() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t numLoops;
    /**
     
     */
    bool infiniteLoop;
    /**
     
     */
    float infiniteLoopTimeoutTime;

    static constexpr int ID = -513308166;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeCooldown : public  ai::Decorator 
{
    public:

    static bool deserializeUeCooldown(ByteBuf& _buf, std::shared_ptr<UeCooldown>& _out);

    UeCooldown()
    { 

    }

    UeCooldown(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, float cooldown_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->cooldownTime = cooldown_time;
    }
    virtual ~UeCooldown() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    float cooldownTime;

    static constexpr int ID = -951439423;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeTimeLimit : public  ai::Decorator 
{
    public:

    static bool deserializeUeTimeLimit(ByteBuf& _buf, std::shared_ptr<UeTimeLimit>& _out);

    UeTimeLimit()
    { 

    }

    UeTimeLimit(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, float limit_time ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->limitTime = limit_time;
    }
    virtual ~UeTimeLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    float limitTime;

    static constexpr int ID = 338469720;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeBlackboard : public  ai::Decorator 
{
    public:

    static bool deserializeUeBlackboard(ByteBuf& _buf, std::shared_ptr<UeBlackboard>& _out);

    UeBlackboard()
    { 

    }

    UeBlackboard(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, ai::ENotifyObserverMode notify_observer, std::string blackboard_key, std::shared_ptr<ai::KeyQueryOperator> key_query ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->notifyObserver = notify_observer;
        this->blackboardKey = blackboard_key;
        this->keyQuery = key_query;
    }
    virtual ~UeBlackboard() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    ai::ENotifyObserverMode notifyObserver;
    /**
     
     */
    std::string blackboardKey;
    /**
     
     */
    std::shared_ptr<ai::KeyQueryOperator> keyQuery;

    static constexpr int ID = -315297507;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class KeyQueryOperator : public  bright::CfgBean 
{
    public:

    static bool deserializeKeyQueryOperator(ByteBuf& _buf, std::shared_ptr<KeyQueryOperator>& _out);

    KeyQueryOperator()
    { 

    }

    virtual ~KeyQueryOperator() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class IsSet : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeIsSet(ByteBuf& _buf, std::shared_ptr<IsSet>& _out);

    IsSet()
    { 

    }

    virtual ~IsSet() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 1635350898;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class IsNotSet : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeIsNotSet(ByteBuf& _buf, std::shared_ptr<IsNotSet>& _out);

    IsNotSet()
    { 

    }

    virtual ~IsNotSet() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 790736255;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class BinaryOperator : public  ai::KeyQueryOperator 
{
    public:

    static bool deserializeBinaryOperator(ByteBuf& _buf, std::shared_ptr<BinaryOperator>& _out);

    BinaryOperator()
    { 

    }

    BinaryOperator(ai::EOperator oper, std::shared_ptr<ai::KeyData> data ) 
            : ai::KeyQueryOperator()
    {

        this->oper = oper;
        this->data = data;
    }
    virtual ~BinaryOperator() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    ai::EOperator oper;
    /**
     
     */
    std::shared_ptr<ai::KeyData> data;

    static constexpr int ID = -979891605;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class KeyData : public  bright::CfgBean 
{
    public:

    static bool deserializeKeyData(ByteBuf& _buf, std::shared_ptr<KeyData>& _out);

    KeyData()
    { 

    }

    virtual ~KeyData() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class FloatKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeFloatKeyData(ByteBuf& _buf, std::shared_ptr<FloatKeyData>& _out);

    FloatKeyData()
    { 

    }

    FloatKeyData(float value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~FloatKeyData() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    float value;

    static constexpr int ID = -719747885;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class IntKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeIntKeyData(ByteBuf& _buf, std::shared_ptr<IntKeyData>& _out);

    IntKeyData()
    { 

    }

    IntKeyData(int32_t value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~IntKeyData() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t value;

    static constexpr int ID = -342751904;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class StringKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeStringKeyData(ByteBuf& _buf, std::shared_ptr<StringKeyData>& _out);

    StringKeyData()
    { 

    }

    StringKeyData(std::string value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~StringKeyData() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string value;

    static constexpr int ID = -307888654;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class BlackboardKeyData : public  ai::KeyData 
{
    public:

    static bool deserializeBlackboardKeyData(ByteBuf& _buf, std::shared_ptr<BlackboardKeyData>& _out);

    BlackboardKeyData()
    { 

    }

    BlackboardKeyData(std::string value ) 
            : ai::KeyData()
    {

        this->value = value;
    }
    virtual ~BlackboardKeyData() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string value;

    static constexpr int ID = 1517269500;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeForceSuccess : public  ai::Decorator 
{
    public:

    static bool deserializeUeForceSuccess(ByteBuf& _buf, std::shared_ptr<UeForceSuccess>& _out);

    UeForceSuccess()
    { 

    }

    UeForceSuccess(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

    }
    virtual ~UeForceSuccess() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 195054574;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class IsAtLocation : public  ai::Decorator 
{
    public:

    static bool deserializeIsAtLocation(ByteBuf& _buf, std::shared_ptr<IsAtLocation>& _out);

    IsAtLocation()
    { 

    }

    IsAtLocation(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, float acceptable_radius, std::string keyboard_key, bool inverse_condition ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->acceptableRadius = acceptable_radius;
        this->keyboardKey = keyboard_key;
        this->inverseCondition = inverse_condition;
    }
    virtual ~IsAtLocation() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    float acceptableRadius;
    /**
     
     */
    std::string keyboardKey;
    /**
     
     */
    bool inverseCondition;

    static constexpr int ID = 1255972344;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class DistanceLessThan : public  ai::Decorator 
{
    public:

    static bool deserializeDistanceLessThan(ByteBuf& _buf, std::shared_ptr<DistanceLessThan>& _out);

    DistanceLessThan()
    { 

    }

    DistanceLessThan(int32_t id, std::string node_name, ai::EFlowAbortMode flow_abort_mode, std::string actor1_key, std::string actor2_key, float distance, bool reverse_result ) 
            : ai::Decorator(id, node_name, flow_abort_mode)
    {

        this->actor1Key = actor1_key;
        this->actor2Key = actor2_key;
        this->distance = distance;
        this->reverseResult = reverse_result;
    }
    virtual ~DistanceLessThan() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string actor1Key;
    /**
     
     */
    std::string actor2Key;
    /**
     
     */
    float distance;
    /**
     
     */
    bool reverseResult;

    static constexpr int ID = -1207170283;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class FlowNode : public  ai::Node 
{
    public:

    static bool deserializeFlowNode(ByteBuf& _buf, std::shared_ptr<FlowNode>& _out);

    FlowNode()
    { 

    }

    FlowNode(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services ) 
            : ai::Node(id, node_name)
    {

        this->decorators = decorators;
        this->services = services;
    }
    virtual ~FlowNode() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<ai::Decorator>> decorators;
    /**
     
     */
    std::vector<std::shared_ptr<ai::Service>> services;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class ComposeNode : public  ai::FlowNode 
{
    public:

    static bool deserializeComposeNode(ByteBuf& _buf, std::shared_ptr<ComposeNode>& _out);

    ComposeNode()
    { 

    }

    ComposeNode(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services ) 
            : ai::FlowNode(id, node_name, decorators, services)
    {

    }
    virtual ~ComposeNode() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Sequence : public  ai::ComposeNode 
{
    public:

    static bool deserializeSequence(ByteBuf& _buf, std::shared_ptr<Sequence>& _out);

    Sequence()
    { 

    }

    Sequence(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, std::vector<std::shared_ptr<ai::FlowNode>> children ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->children = children;
    }
    virtual ~Sequence() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<ai::FlowNode>> children;

    static constexpr int ID = -1789006105;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Selector : public  ai::ComposeNode 
{
    public:

    static bool deserializeSelector(ByteBuf& _buf, std::shared_ptr<Selector>& _out);

    Selector()
    { 

    }

    Selector(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, std::vector<std::shared_ptr<ai::FlowNode>> children ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->children = children;
    }
    virtual ~Selector() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<ai::FlowNode>> children;

    static constexpr int ID = -1946981627;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class SimpleParallel : public  ai::ComposeNode 
{
    public:

    static bool deserializeSimpleParallel(ByteBuf& _buf, std::shared_ptr<SimpleParallel>& _out);

    SimpleParallel()
    { 

    }

    SimpleParallel(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, ai::EFinishMode finish_mode, std::shared_ptr<ai::Task> main_task, std::shared_ptr<ai::FlowNode> background_node ) 
            : ai::ComposeNode(id, node_name, decorators, services)
    {

        this->finishMode = finish_mode;
        this->mainTask = main_task;
        this->backgroundNode = background_node;
    }
    virtual ~SimpleParallel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    ai::EFinishMode finishMode;
    /**
     
     */
    std::shared_ptr<ai::Task> mainTask;
    /**
     
     */
    std::shared_ptr<ai::FlowNode> backgroundNode;

    static constexpr int ID = -1952582529;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class Task : public  ai::FlowNode 
{
    public:

    static bool deserializeTask(ByteBuf& _buf, std::shared_ptr<Task>& _out);

    Task()
    { 

    }

    Task(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self ) 
            : ai::FlowNode(id, node_name, decorators, services)
    {

        this->ignoreRestartSelf = ignore_restart_self;
    }
    virtual ~Task() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    bool ignoreRestartSelf;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeWait : public  ai::Task 
{
    public:

    static bool deserializeUeWait(ByteBuf& _buf, std::shared_ptr<UeWait>& _out);

    UeWait()
    { 

    }

    UeWait(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, float wait_time, float random_deviation ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->waitTime = wait_time;
        this->randomDeviation = random_deviation;
    }
    virtual ~UeWait() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    float waitTime;
    /**
     
     */
    float randomDeviation;

    static constexpr int ID = -512994101;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class UeWaitBlackboardTime : public  ai::Task 
{
    public:

    static bool deserializeUeWaitBlackboardTime(ByteBuf& _buf, std::shared_ptr<UeWaitBlackboardTime>& _out);

    UeWaitBlackboardTime()
    { 

    }

    UeWaitBlackboardTime(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, std::string blackboard_key ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->blackboardKey = blackboard_key;
    }
    virtual ~UeWaitBlackboardTime() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string blackboardKey;

    static constexpr int ID = 1215378271;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class MoveToTarget : public  ai::Task 
{
    public:

    static bool deserializeMoveToTarget(ByteBuf& _buf, std::shared_ptr<MoveToTarget>& _out);

    MoveToTarget()
    { 

    }

    MoveToTarget(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, std::string target_actor_key, float acceptable_radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->targetActorKey = target_actor_key;
        this->acceptableRadius = acceptable_radius;
    }
    virtual ~MoveToTarget() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string targetActorKey;
    /**
     
     */
    float acceptableRadius;

    static constexpr int ID = 514987779;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class ChooseSkill : public  ai::Task 
{
    public:

    static bool deserializeChooseSkill(ByteBuf& _buf, std::shared_ptr<ChooseSkill>& _out);

    ChooseSkill()
    { 

    }

    ChooseSkill(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, std::string target_actor_key, std::string result_skill_id_key ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->targetActorKey = target_actor_key;
        this->resultSkillIdKey = result_skill_id_key;
    }
    virtual ~ChooseSkill() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string targetActorKey;
    /**
     
     */
    std::string resultSkillIdKey;

    static constexpr int ID = -918812268;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class MoveToRandomLocation : public  ai::Task 
{
    public:

    static bool deserializeMoveToRandomLocation(ByteBuf& _buf, std::shared_ptr<MoveToRandomLocation>& _out);

    MoveToRandomLocation()
    { 

    }

    MoveToRandomLocation(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, std::string origin_position_key, float radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->originPositionKey = origin_position_key;
        this->radius = radius;
    }
    virtual ~MoveToRandomLocation() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string originPositionKey;
    /**
     
     */
    float radius;

    static constexpr int ID = -2140042998;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class MoveToLocation : public  ai::Task 
{
    public:

    static bool deserializeMoveToLocation(ByteBuf& _buf, std::shared_ptr<MoveToLocation>& _out);

    MoveToLocation()
    { 

    }

    MoveToLocation(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, bright::math::Vector3 location, float acceptable_radius ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->location = location;
        this->acceptableRadius = acceptable_radius;
    }
    virtual ~MoveToLocation() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    bright::math::Vector3 location;
    /**
     
     */
    float acceptableRadius;

    static constexpr int ID = -969953113;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {





/**

 */
class DebugPrint : public  ai::Task 
{
    public:

    static bool deserializeDebugPrint(ByteBuf& _buf, std::shared_ptr<DebugPrint>& _out);

    DebugPrint()
    { 

    }

    DebugPrint(int32_t id, std::string node_name, std::vector<std::shared_ptr<ai::Decorator>> decorators, std::vector<std::shared_ptr<ai::Service>> services, bool ignore_restart_self, std::string text ) 
            : ai::Task(id, node_name, decorators, services, ignore_restart_self)
    {

        this->text = text;
    }
    virtual ~DebugPrint() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string text;

    static constexpr int ID = 1357409728;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class Clazz : public  bright::CfgBean 
{
    public:

    static bool deserializeClazz(ByteBuf& _buf, std::shared_ptr<Clazz>& _out);

    Clazz()
    { 

    }

    Clazz(std::string name, std::string desc, std::vector<std::shared_ptr<blueprint::Clazz>> parents, std::vector<std::shared_ptr<blueprint::Method>> methods ) 
    {

        this->name = name;
        this->desc = desc;
        this->parents = parents;
        this->methods = methods;
    }
    virtual ~Clazz() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string desc;
    /**
     
     */
    std::vector<std::shared_ptr<blueprint::Clazz>> parents;
    /**
     
     */
    std::vector<std::shared_ptr<blueprint::Method>> methods;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class Method : public  bright::CfgBean 
{
    public:

    static bool deserializeMethod(ByteBuf& _buf, std::shared_ptr<Method>& _out);

    Method()
    { 

    }

    Method(std::string name, std::string desc, bool is_static, std::string return_type, std::vector<std::shared_ptr<blueprint::ParamInfo>> parameters ) 
    {

        this->name = name;
        this->desc = desc;
        this->isStatic = is_static;
        this->returnType = return_type;
        this->parameters = parameters;
    }
    virtual ~Method() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string desc;
    /**
     
     */
    bool isStatic;
    /**
     
     */
    std::string returnType;
    /**
     
     */
    std::vector<std::shared_ptr<blueprint::ParamInfo>> parameters;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class ParamInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeParamInfo(ByteBuf& _buf, std::shared_ptr<ParamInfo>& _out);

    ParamInfo()
    { 

    }

    ParamInfo(std::string name, std::string type, bool is_ref ) 
    {

        this->name = name;
        this->type = type;
        this->isRef = is_ref;
    }
    virtual ~ParamInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string type;
    /**
     
     */
    bool isRef;

    static constexpr int ID = -729799392;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class AbstraceMethod : public  blueprint::Method 
{
    public:

    static bool deserializeAbstraceMethod(ByteBuf& _buf, std::shared_ptr<AbstraceMethod>& _out);

    AbstraceMethod()
    { 

    }

    AbstraceMethod(std::string name, std::string desc, bool is_static, std::string return_type, std::vector<std::shared_ptr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~AbstraceMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = -392137809;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class ExternalMethod : public  blueprint::Method 
{
    public:

    static bool deserializeExternalMethod(ByteBuf& _buf, std::shared_ptr<ExternalMethod>& _out);

    ExternalMethod()
    { 

    }

    ExternalMethod(std::string name, std::string desc, bool is_static, std::string return_type, std::vector<std::shared_ptr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~ExternalMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 1739079015;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class BlueprintMethod : public  blueprint::Method 
{
    public:

    static bool deserializeBlueprintMethod(ByteBuf& _buf, std::shared_ptr<BlueprintMethod>& _out);

    BlueprintMethod()
    { 

    }

    BlueprintMethod(std::string name, std::string desc, bool is_static, std::string return_type, std::vector<std::shared_ptr<blueprint::ParamInfo>> parameters ) 
            : blueprint::Method(name, desc, is_static, return_type, parameters)
    {

    }
    virtual ~BlueprintMethod() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = -696408103;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class Interface : public  blueprint::Clazz 
{
    public:

    static bool deserializeInterface(ByteBuf& _buf, std::shared_ptr<Interface>& _out);

    Interface()
    { 

    }

    Interface(std::string name, std::string desc, std::vector<std::shared_ptr<blueprint::Clazz>> parents, std::vector<std::shared_ptr<blueprint::Method>> methods ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

    }
    virtual ~Interface() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 2114170750;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class NormalClazz : public  blueprint::Clazz 
{
    public:

    static bool deserializeNormalClazz(ByteBuf& _buf, std::shared_ptr<NormalClazz>& _out);

    NormalClazz()
    { 

    }

    NormalClazz(std::string name, std::string desc, std::vector<std::shared_ptr<blueprint::Clazz>> parents, std::vector<std::shared_ptr<blueprint::Method>> methods, bool is_abstract, std::vector<std::shared_ptr<blueprint::Field>> fields ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

        this->isAbstract = is_abstract;
        this->fields = fields;
    }
    virtual ~NormalClazz() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    bool isAbstract;
    /**
     
     */
    std::vector<std::shared_ptr<blueprint::Field>> fields;

    static constexpr int ID = -2073576778;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class Field : public  bright::CfgBean 
{
    public:

    static bool deserializeField(ByteBuf& _buf, std::shared_ptr<Field>& _out);

    Field()
    { 

    }

    Field(std::string name, std::string type, std::string desc ) 
    {

        this->name = name;
        this->type = type;
        this->desc = desc;
    }
    virtual ~Field() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    std::string type;
    /**
     
     */
    std::string desc;

    static constexpr int ID = 1694158271;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class EnumClazz : public  blueprint::Clazz 
{
    public:

    static bool deserializeEnumClazz(ByteBuf& _buf, std::shared_ptr<EnumClazz>& _out);

    EnumClazz()
    { 

    }

    EnumClazz(std::string name, std::string desc, std::vector<std::shared_ptr<blueprint::Clazz>> parents, std::vector<std::shared_ptr<blueprint::Method>> methods, std::vector<std::shared_ptr<blueprint::EnumField>> enums ) 
            : blueprint::Clazz(name, desc, parents, methods)
    {

        this->enums = enums;
    }
    virtual ~EnumClazz() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<blueprint::EnumField>> enums;

    static constexpr int ID = 1827364892;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace blueprint {





/**

 */
class EnumField : public  bright::CfgBean 
{
    public:

    static bool deserializeEnumField(ByteBuf& _buf, std::shared_ptr<EnumField>& _out);

    EnumField()
    { 

    }

    EnumField(std::string name, int32_t value ) 
    {

        this->name = name;
        this->value = value;
    }
    virtual ~EnumField() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string name;
    /**
     
     */
    int32_t value;

    static constexpr int ID = 1830049470;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class DropInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeDropInfo(ByteBuf& _buf, std::shared_ptr<DropInfo>& _out);

    DropInfo()
    { 

    }

    DropInfo(int32_t id, std::string desc, std::vector<std::shared_ptr<bonus::ShowItemInfo>> client_show_items, std::shared_ptr<bonus::Bonus> bonus ) 
    {

        this->id = id;
        this->desc = desc;
        this->clientShowItems = client_show_items;
        this->bonus = bonus;
    }
    virtual ~DropInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string desc;
    /**
     
     */
    std::vector<std::shared_ptr<bonus::ShowItemInfo>> clientShowItems;
    /**
     
     */
    std::shared_ptr<bonus::Bonus> bonus;

    static constexpr int ID = -2014781108;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class ShowItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeShowItemInfo(ByteBuf& _buf, std::shared_ptr<ShowItemInfo>& _out);

    ShowItemInfo()
    { 

    }

    ShowItemInfo(int32_t item_id, int64_t item_num ) 
    {

        this->itemId = item_id;
        this->itemNum = item_num;
    }
    virtual ~ShowItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int64_t itemNum;

    static constexpr int ID = -1496363507;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class Bonus : public  bright::CfgBean 
{
    public:

    static bool deserializeBonus(ByteBuf& _buf, std::shared_ptr<Bonus>& _out);

    Bonus()
    { 

    }

    virtual ~Bonus() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class OneItem : public  bonus::Bonus 
{
    public:

    static bool deserializeOneItem(ByteBuf& _buf, std::shared_ptr<OneItem>& _out);

    OneItem()
    { 

    }

    OneItem(int32_t item_id ) 
            : bonus::Bonus()
    {

        this->itemId = item_id;
    }
    virtual ~OneItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;

    static constexpr int ID = -1649658966;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class OneItems : public  bonus::Bonus 
{
    public:

    static bool deserializeOneItems(ByteBuf& _buf, std::shared_ptr<OneItems>& _out);

    OneItems()
    { 

    }

    OneItems(std::vector<int32_t> items ) 
            : bonus::Bonus()
    {

        this->items = items;
    }
    virtual ~OneItems() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<int32_t> items;

    static constexpr int ID = 400179721;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class Item : public  bonus::Bonus 
{
    public:

    static bool deserializeItem(ByteBuf& _buf, std::shared_ptr<Item>& _out);

    Item()
    { 

    }

    Item(int32_t item_id, int32_t amount ) 
            : bonus::Bonus()
    {

        this->itemId = item_id;
        this->amount = amount;
    }
    virtual ~Item() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int32_t amount;

    static constexpr int ID = 1689011106;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class Items : public  bonus::Bonus 
{
    public:

    static bool deserializeItems(ByteBuf& _buf, std::shared_ptr<Items>& _out);

    Items()
    { 

    }

    Items(std::vector<std::shared_ptr<bonus::Item>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~Items() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::Item>> itemList;

    static constexpr int ID = 819736849;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class CoefficientItem : public  bonus::Bonus 
{
    public:

    static bool deserializeCoefficientItem(ByteBuf& _buf, std::shared_ptr<CoefficientItem>& _out);

    CoefficientItem()
    { 

    }

    CoefficientItem(int32_t bonus_id, std::shared_ptr<bonus::Items> bonus_list ) 
            : bonus::Bonus()
    {

        this->bonusId = bonus_id;
        this->bonusList = bonus_list;
    }
    virtual ~CoefficientItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t bonusId;
    /**
     
     */
    std::shared_ptr<bonus::Items> bonusList;

    static constexpr int ID = -229470727;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class WeightItems : public  bonus::Bonus 
{
    public:

    static bool deserializeWeightItems(ByteBuf& _buf, std::shared_ptr<WeightItems>& _out);

    WeightItems()
    { 

    }

    WeightItems(std::vector<std::shared_ptr<bonus::WeightItemInfo>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~WeightItems() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::WeightItemInfo>> itemList;

    static constexpr int ID = -356202311;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class WeightItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeWeightItemInfo(ByteBuf& _buf, std::shared_ptr<WeightItemInfo>& _out);

    WeightItemInfo()
    { 

    }

    WeightItemInfo(int32_t item_id, int32_t num, int32_t weight ) 
    {

        this->itemId = item_id;
        this->num = num;
        this->weight = weight;
    }
    virtual ~WeightItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int32_t num;
    /**
     
     */
    int32_t weight;

    static constexpr int ID = 1239999176;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class ProbabilityItems : public  bonus::Bonus 
{
    public:

    static bool deserializeProbabilityItems(ByteBuf& _buf, std::shared_ptr<ProbabilityItems>& _out);

    ProbabilityItems()
    { 

    }

    ProbabilityItems(std::vector<std::shared_ptr<bonus::ProbabilityItemInfo>> item_list ) 
            : bonus::Bonus()
    {

        this->itemList = item_list;
    }
    virtual ~ProbabilityItems() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::ProbabilityItemInfo>> itemList;

    static constexpr int ID = 366387866;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class ProbabilityItemInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeProbabilityItemInfo(ByteBuf& _buf, std::shared_ptr<ProbabilityItemInfo>& _out);

    ProbabilityItemInfo()
    { 

    }

    ProbabilityItemInfo(int32_t item_id, int32_t num, float probability ) 
    {

        this->itemId = item_id;
        this->num = num;
        this->probability = probability;
    }
    virtual ~ProbabilityItemInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int32_t num;
    /**
     
     */
    float probability;

    static constexpr int ID = 1547874631;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class MultiBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeMultiBonus(ByteBuf& _buf, std::shared_ptr<MultiBonus>& _out);

    MultiBonus()
    { 

    }

    MultiBonus(std::vector<std::shared_ptr<bonus::Bonus>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~MultiBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::Bonus>> bonuses;

    static constexpr int ID = 1421907893;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class ProbabilityBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeProbabilityBonus(ByteBuf& _buf, std::shared_ptr<ProbabilityBonus>& _out);

    ProbabilityBonus()
    { 

    }

    ProbabilityBonus(std::vector<std::shared_ptr<bonus::ProbabilityBonusInfo>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~ProbabilityBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::ProbabilityBonusInfo>> bonuses;

    static constexpr int ID = 359783161;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class ProbabilityBonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeProbabilityBonusInfo(ByteBuf& _buf, std::shared_ptr<ProbabilityBonusInfo>& _out);

    ProbabilityBonusInfo()
    { 

    }

    ProbabilityBonusInfo(std::shared_ptr<bonus::Bonus> bonus, float probability ) 
    {

        this->bonus = bonus;
        this->probability = probability;
    }
    virtual ~ProbabilityBonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<bonus::Bonus> bonus;
    /**
     
     */
    float probability;

    static constexpr int ID = 46960455;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class WeightBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeWeightBonus(ByteBuf& _buf, std::shared_ptr<WeightBonus>& _out);

    WeightBonus()
    { 

    }

    WeightBonus(std::vector<std::shared_ptr<bonus::WeightBonusInfo>> bonuses ) 
            : bonus::Bonus()
    {

        this->bonuses = bonuses;
    }
    virtual ~WeightBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<bonus::WeightBonusInfo>> bonuses;

    static constexpr int ID = -362807016;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class WeightBonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeWeightBonusInfo(ByteBuf& _buf, std::shared_ptr<WeightBonusInfo>& _out);

    WeightBonusInfo()
    { 

    }

    WeightBonusInfo(std::shared_ptr<bonus::Bonus> bonus, int32_t weight ) 
    {

        this->bonus = bonus;
        this->weight = weight;
    }
    virtual ~WeightBonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<bonus::Bonus> bonus;
    /**
     
     */
    int32_t weight;

    static constexpr int ID = -907244058;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace bonus {





/**

 */
class DropBonus : public  bonus::Bonus 
{
    public:

    static bool deserializeDropBonus(ByteBuf& _buf, std::shared_ptr<DropBonus>& _out);

    DropBonus()
    { 

    }

    DropBonus(int32_t id ) 
            : bonus::Bonus()
    {

        this->id = id;
    }
    virtual ~DropBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    std::shared_ptr<bonus::DropInfo> id_Ref;

    static constexpr int ID = 1959868225;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace common {





/**

 */
class GlobalConfig : public  bright::CfgBean 
{
    public:

    static bool deserializeGlobalConfig(ByteBuf& _buf, std::shared_ptr<GlobalConfig>& _out);

    GlobalConfig()
    { 

    }

    GlobalConfig(int32_t bag_capacity, int32_t bag_capacity_special, int32_t bag_temp_expendable_capacity, int32_t bag_temp_tool_capacity, int32_t bag_init_capacity, int32_t quick_bag_capacity, int32_t cloth_bag_capacity, int32_t cloth_bag_init_capacity, int32_t cloth_bag_capacity_special, std::shared_ptr<int32_t> bag_init_items_drop_id, int32_t mail_box_capacity, float damage_param_c, float damage_param_e, float damage_param_f, float damage_param_d, float role_speed, float monster_speed, int32_t init_energy, int32_t init_viality, int32_t max_viality, int32_t per_viality_recovery_time ) 
    {

        this->bagCapacity = bag_capacity;
        this->bagCapacitySpecial = bag_capacity_special;
        this->bagTempExpendableCapacity = bag_temp_expendable_capacity;
        this->bagTempToolCapacity = bag_temp_tool_capacity;
        this->bagInitCapacity = bag_init_capacity;
        this->quickBagCapacity = quick_bag_capacity;
        this->clothBagCapacity = cloth_bag_capacity;
        this->clothBagInitCapacity = cloth_bag_init_capacity;
        this->clothBagCapacitySpecial = cloth_bag_capacity_special;
        this->bagInitItemsDropId = bag_init_items_drop_id;
        this->mailBoxCapacity = mail_box_capacity;
        this->damageParamC = damage_param_c;
        this->damageParamE = damage_param_e;
        this->damageParamF = damage_param_f;
        this->damageParamD = damage_param_d;
        this->roleSpeed = role_speed;
        this->monsterSpeed = monster_speed;
        this->initEnergy = init_energy;
        this->initViality = init_viality;
        this->maxViality = max_viality;
        this->perVialityRecoveryTime = per_viality_recovery_time;
    }
    virtual ~GlobalConfig() {}

    bool deserialize(ByteBuf& _buf);

    /**
     背包容量
     */
    int32_t bagCapacity;
    /**
     
     */
    int32_t bagCapacitySpecial;
    /**
     
     */
    int32_t bagTempExpendableCapacity;
    /**
     
     */
    int32_t bagTempToolCapacity;
    /**
     
     */
    int32_t bagInitCapacity;
    /**
     
     */
    int32_t quickBagCapacity;
    /**
     
     */
    int32_t clothBagCapacity;
    /**
     
     */
    int32_t clothBagInitCapacity;
    /**
     
     */
    int32_t clothBagCapacitySpecial;
    /**
     
     */
    std::shared_ptr<int32_t> bagInitItemsDropId;
    std::shared_ptr<bonus::DropInfo> bagInitItemsDropId_Ref;
    /**
     
     */
    int32_t mailBoxCapacity;
    /**
     
     */
    float damageParamC;
    /**
     
     */
    float damageParamE;
    /**
     
     */
    float damageParamF;
    /**
     
     */
    float damageParamD;
    /**
     
     */
    float roleSpeed;
    /**
     
     */
    float monsterSpeed;
    /**
     
     */
    int32_t initEnergy;
    /**
     
     */
    int32_t initViality;
    /**
     
     */
    int32_t maxViality;
    /**
     
     */
    int32_t perVialityRecoveryTime;

    static constexpr int ID = -848234488;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace common {





/**

 */
class Dummy : public  bright::CfgBean 
{
    public:

    static bool deserializeDummy(ByteBuf& _buf, std::shared_ptr<Dummy>& _out);

    Dummy()
    { 

    }

    Dummy(int32_t id, std::shared_ptr<limit::LimitBase> limit ) 
    {

        this->id = id;
        this->limit = limit;
    }
    virtual ~Dummy() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::shared_ptr<limit::LimitBase> limit;

    static constexpr int ID = -985084219;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class LimitBase : public  bright::CfgBean 
{
    public:

    static bool deserializeLimitBase(ByteBuf& _buf, std::shared_ptr<LimitBase>& _out);

    LimitBase()
    { 

    }

    virtual ~LimitBase() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class DailyLimitBase : public  limit::LimitBase 
{
    public:

    static bool deserializeDailyLimitBase(ByteBuf& _buf, std::shared_ptr<DailyLimitBase>& _out);

    DailyLimitBase()
    { 

    }

    virtual ~DailyLimitBase() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class DailyLimit : public  limit::DailyLimitBase 
{
    public:

    static bool deserializeDailyLimit(ByteBuf& _buf, std::shared_ptr<DailyLimit>& _out);

    DailyLimit()
    { 

    }

    DailyLimit(int32_t num ) 
            : limit::DailyLimitBase()
    {

        this->num = num;
    }
    virtual ~DailyLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t num;

    static constexpr int ID = 303235413;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class MultiDayLimit : public  limit::LimitBase 
{
    public:

    static bool deserializeMultiDayLimit(ByteBuf& _buf, std::shared_ptr<MultiDayLimit>& _out);

    MultiDayLimit()
    { 

    }

    MultiDayLimit(int32_t day, int32_t num ) 
            : limit::LimitBase()
    {

        this->day = day;
        this->num = num;
    }
    virtual ~MultiDayLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t day;
    /**
     
     */
    int32_t num;

    static constexpr int ID = -1753629499;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class WeeklyLimit : public  limit::LimitBase 
{
    public:

    static bool deserializeWeeklyLimit(ByteBuf& _buf, std::shared_ptr<WeeklyLimit>& _out);

    WeeklyLimit()
    { 

    }

    WeeklyLimit(int32_t num ) 
            : limit::LimitBase()
    {

        this->num = num;
    }
    virtual ~WeeklyLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t num;

    static constexpr int ID = -252187161;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class MonthlyLimit : public  limit::LimitBase 
{
    public:

    static bool deserializeMonthlyLimit(ByteBuf& _buf, std::shared_ptr<MonthlyLimit>& _out);

    MonthlyLimit()
    { 

    }

    MonthlyLimit(int32_t num ) 
            : limit::LimitBase()
    {

        this->num = num;
    }
    virtual ~MonthlyLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t num;

    static constexpr int ID = 2063279905;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class CoolDown : public  limit::LimitBase 
{
    public:

    static bool deserializeCoolDown(ByteBuf& _buf, std::shared_ptr<CoolDown>& _out);

    CoolDown()
    { 

    }

    CoolDown(int32_t duration ) 
            : limit::LimitBase()
    {

        this->duration = duration;
    }
    virtual ~CoolDown() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t duration;

    static constexpr int ID = -1366194050;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace limit {





/**

 */
class GroupCoolDown : public  limit::LimitBase 
{
    public:

    static bool deserializeGroupCoolDown(ByteBuf& _buf, std::shared_ptr<GroupCoolDown>& _out);

    GroupCoolDown()
    { 

    }

    GroupCoolDown(int32_t group_id, int32_t duration ) 
            : limit::LimitBase()
    {

        this->groupId = group_id;
        this->duration = duration;
    }
    virtual ~GroupCoolDown() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t groupId;
    /**
     
     */
    int32_t duration;

    static constexpr int ID = 394328599;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeErrorInfo(ByteBuf& _buf, std::shared_ptr<ErrorInfo>& _out);

    ErrorInfo()
    { 

    }

    ErrorInfo(std::string code, std::string desc, std::shared_ptr<error::ErrorStyle> style ) 
    {

        this->code = code;
        this->desc = desc;
        this->style = style;
    }
    virtual ~ErrorInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string code;
    /**
     
     */
    std::string desc;
    /**
     
     */
    std::shared_ptr<error::ErrorStyle> style;

    static constexpr int ID = 1389347408;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorStyle : public  bright::CfgBean 
{
    public:

    static bool deserializeErrorStyle(ByteBuf& _buf, std::shared_ptr<ErrorStyle>& _out);

    ErrorStyle()
    { 

    }

    virtual ~ErrorStyle() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorStyleTip : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleTip(ByteBuf& _buf, std::shared_ptr<ErrorStyleTip>& _out);

    ErrorStyleTip()
    { 

    }

    virtual ~ErrorStyleTip() {}

    bool deserialize(ByteBuf& _buf);


    static constexpr int ID = 1915239884;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorStyleMsgbox : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleMsgbox(ByteBuf& _buf, std::shared_ptr<ErrorStyleMsgbox>& _out);

    ErrorStyleMsgbox()
    { 

    }

    ErrorStyleMsgbox(std::string btn_name, error::EOperation operation ) 
            : error::ErrorStyle()
    {

        this->btnName = btn_name;
        this->operation = operation;
    }
    virtual ~ErrorStyleMsgbox() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string btnName;
    /**
     
     */
    error::EOperation operation;

    static constexpr int ID = -1920482343;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorStyleDlgOk : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleDlgOk(ByteBuf& _buf, std::shared_ptr<ErrorStyleDlgOk>& _out);

    ErrorStyleDlgOk()
    { 

    }

    ErrorStyleDlgOk(std::string btn_name ) 
            : error::ErrorStyle()
    {

        this->btnName = btn_name;
    }
    virtual ~ErrorStyleDlgOk() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string btnName;

    static constexpr int ID = -2010134516;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class ErrorStyleDlgOkCancel : public  error::ErrorStyle 
{
    public:

    static bool deserializeErrorStyleDlgOkCancel(ByteBuf& _buf, std::shared_ptr<ErrorStyleDlgOkCancel>& _out);

    ErrorStyleDlgOkCancel()
    { 

    }

    ErrorStyleDlgOkCancel(std::string btn1_name, std::string btn2_name ) 
            : error::ErrorStyle()
    {

        this->btn1Name = btn1_name;
        this->btn2Name = btn2_name;
    }
    virtual ~ErrorStyleDlgOkCancel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::string btn1Name;
    /**
     
     */
    std::string btn2Name;

    static constexpr int ID = 971221414;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace error {





/**

 */
class CodeInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeCodeInfo(ByteBuf& _buf, std::shared_ptr<CodeInfo>& _out);

    CodeInfo()
    { 

    }

    CodeInfo(error::EErrorCode code, std::string key ) 
    {

        this->code = code;
        this->key = key;
    }
    virtual ~CodeInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    error::EErrorCode code;
    /**
     
     */
    std::string key;

    static constexpr int ID = -1942481535;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**
道具
 */
class Item : public  bright::CfgBean 
{
    public:

    static bool deserializeItem(ByteBuf& _buf, std::shared_ptr<Item>& _out);

    Item()
    { 

    }

    Item(int32_t id, std::string name, item::EMajorType major_type, item::EMinorType minor_type, int32_t max_pile_num, item::EItemQuality quality, std::string icon, std::string icon_backgroud, std::string icon_mask, std::string desc, int32_t show_order, std::string quantifier, bool show_in_bag, int32_t min_show_level, bool batch_usable, float progress_time_when_use, bool show_hint_when_use, bool droppable, std::shared_ptr<int32_t> price, item::EUseType use_type, std::shared_ptr<int32_t> level_up_id ) 
    {

        this->id = id;
        this->name = name;
        this->majorType = major_type;
        this->minorType = minor_type;
        this->maxPileNum = max_pile_num;
        this->quality = quality;
        this->icon = icon;
        this->iconBackgroud = icon_backgroud;
        this->iconMask = icon_mask;
        this->desc = desc;
        this->showOrder = show_order;
        this->quantifier = quantifier;
        this->showInBag = show_in_bag;
        this->minShowLevel = min_show_level;
        this->batchUsable = batch_usable;
        this->progressTimeWhenUse = progress_time_when_use;
        this->showHintWhenUse = show_hint_when_use;
        this->droppable = droppable;
        this->price = price;
        this->useType = use_type;
        this->levelUpId = level_up_id;
    }
    virtual ~Item() {}

    bool deserialize(ByteBuf& _buf);

    /**
     道具id
     */
    int32_t id;
    /**
     
     */
    std::string name;
    /**
     
     */
    item::EMajorType majorType;
    /**
     
     */
    item::EMinorType minorType;
    /**
     
     */
    int32_t maxPileNum;
    /**
     
     */
    item::EItemQuality quality;
    /**
     
     */
    std::string icon;
    /**
     
     */
    std::string iconBackgroud;
    /**
     
     */
    std::string iconMask;
    /**
     
     */
    std::string desc;
    /**
     
     */
    int32_t showOrder;
    /**
     
     */
    std::string quantifier;
    /**
     
     */
    bool showInBag;
    /**
     
     */
    int32_t minShowLevel;
    /**
     
     */
    bool batchUsable;
    /**
     
     */
    float progressTimeWhenUse;
    /**
     
     */
    bool showHintWhenUse;
    /**
     
     */
    bool droppable;
    /**
     
     */
    std::shared_ptr<int32_t> price;
    /**
     
     */
    item::EUseType useType;
    /**
     
     */
    std::shared_ptr<int32_t> levelUpId;

    static constexpr int ID = 2107285806;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class ItemFunction : public  bright::CfgBean 
{
    public:

    static bool deserializeItemFunction(ByteBuf& _buf, std::shared_ptr<ItemFunction>& _out);

    ItemFunction()
    { 

    }

    ItemFunction(item::EMinorType minor_type, item::EItemFunctionType func_type, std::string method, bool close_bag_ui ) 
    {

        this->minorType = minor_type;
        this->funcType = func_type;
        this->method = method;
        this->closeBagUi = close_bag_ui;
    }
    virtual ~ItemFunction() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    item::EMinorType minorType;
    /**
     
     */
    item::EItemFunctionType funcType;
    /**
     
     */
    std::string method;
    /**
     
     */
    bool closeBagUi;

    static constexpr int ID = 1205824294;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class ItemExtra : public  bright::CfgBean 
{
    public:

    static bool deserializeItemExtra(ByteBuf& _buf, std::shared_ptr<ItemExtra>& _out);

    ItemExtra()
    { 

    }

    ItemExtra(int32_t id ) 
    {

        this->id = id;
    }
    virtual ~ItemExtra() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class TreasureBox : public  item::ItemExtra 
{
    public:

    static bool deserializeTreasureBox(ByteBuf& _buf, std::shared_ptr<TreasureBox>& _out);

    TreasureBox()
    { 

    }

    TreasureBox(int32_t id, std::shared_ptr<int32_t> key_item_id, std::shared_ptr<condition::MinLevel> open_level, bool use_on_obtain, std::vector<int32_t> drop_ids, std::vector<std::shared_ptr<item::ChooseOneBonus>> choose_list ) 
            : item::ItemExtra(id)
    {

        this->keyItemId = key_item_id;
        this->openLevel = open_level;
        this->useOnObtain = use_on_obtain;
        this->dropIds = drop_ids;
        this->chooseList = choose_list;
    }
    virtual ~TreasureBox() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<int32_t> keyItemId;
    /**
     
     */
    std::shared_ptr<condition::MinLevel> openLevel;
    /**
     
     */
    bool useOnObtain;
    /**
     
     */
    std::vector<int32_t> dropIds;
    /**
     
     */
    std::vector<std::shared_ptr<item::ChooseOneBonus>> chooseList;

    static constexpr int ID = 1494222369;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class Condition : public  bright::CfgBean 
{
    public:

    static bool deserializeCondition(ByteBuf& _buf, std::shared_ptr<Condition>& _out);

    Condition()
    { 

    }

    virtual ~Condition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class TimeRange : public  condition::Condition 
{
    public:

    static bool deserializeTimeRange(ByteBuf& _buf, std::shared_ptr<TimeRange>& _out);

    TimeRange()
    { 

    }

    TimeRange(std::shared_ptr<common::DateTimeRange> date_time_range ) 
            : condition::Condition()
    {

        this->dateTimeRange = date_time_range;
    }
    virtual ~TimeRange() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<common::DateTimeRange> dateTimeRange;

    static constexpr int ID = 1069033789;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace common {





/**

 */
class DateTimeRange : public  bright::CfgBean 
{
    public:

    static bool deserializeDateTimeRange(ByteBuf& _buf, std::shared_ptr<DateTimeRange>& _out);

    DateTimeRange()
    { 

    }

    DateTimeRange(std::shared_ptr<int32_t> start_time, std::shared_ptr<int32_t> end_time ) 
    {

        this->startTime = start_time;
        this->endTime = end_time;
    }
    virtual ~DateTimeRange() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<int32_t> startTime;
    /**
     
     */
    std::shared_ptr<int32_t> endTime;

    static constexpr int ID = 1642200959;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class RoleCondition : public  condition::Condition 
{
    public:

    static bool deserializeRoleCondition(ByteBuf& _buf, std::shared_ptr<RoleCondition>& _out);

    RoleCondition()
    { 

    }

    virtual ~RoleCondition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class MultiRoleCondition : public  condition::RoleCondition 
{
    public:

    static bool deserializeMultiRoleCondition(ByteBuf& _buf, std::shared_ptr<MultiRoleCondition>& _out);

    MultiRoleCondition()
    { 

    }

    MultiRoleCondition(std::vector<std::shared_ptr<condition::RoleCondition>> conditions ) 
            : condition::RoleCondition()
    {

        this->conditions = conditions;
    }
    virtual ~MultiRoleCondition() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<condition::RoleCondition>> conditions;

    static constexpr int ID = 934079583;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class BoolRoleCondition : public  condition::RoleCondition 
{
    public:

    static bool deserializeBoolRoleCondition(ByteBuf& _buf, std::shared_ptr<BoolRoleCondition>& _out);

    BoolRoleCondition()
    { 

    }

    virtual ~BoolRoleCondition() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class GenderLimit : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeGenderLimit(ByteBuf& _buf, std::shared_ptr<GenderLimit>& _out);

    GenderLimit()
    { 

    }

    GenderLimit(role::EGenderType gender ) 
            : condition::BoolRoleCondition()
    {

        this->gender = gender;
    }
    virtual ~GenderLimit() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    role::EGenderType gender;

    static constexpr int ID = 103675143;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class MinLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMinLevel(ByteBuf& _buf, std::shared_ptr<MinLevel>& _out);

    MinLevel()
    { 

    }

    MinLevel(int32_t level ) 
            : condition::BoolRoleCondition()
    {

        this->level = level;
    }
    virtual ~MinLevel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t level;

    static constexpr int ID = -1075273755;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class MaxLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMaxLevel(ByteBuf& _buf, std::shared_ptr<MaxLevel>& _out);

    MaxLevel()
    { 

    }

    MaxLevel(int32_t level ) 
            : condition::BoolRoleCondition()
    {

        this->level = level;
    }
    virtual ~MaxLevel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t level;

    static constexpr int ID = 700922899;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class MinMaxLevel : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeMinMaxLevel(ByteBuf& _buf, std::shared_ptr<MinMaxLevel>& _out);

    MinMaxLevel()
    { 

    }

    MinMaxLevel(int32_t min, int32_t max ) 
            : condition::BoolRoleCondition()
    {

        this->min = min;
        this->max = max;
    }
    virtual ~MinMaxLevel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t min;
    /**
     
     */
    int32_t max;

    static constexpr int ID = 907499647;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class ClothesPropertyScoreGreaterThan : public  condition::BoolRoleCondition 
{
    public:

    static bool deserializeClothesPropertyScoreGreaterThan(ByteBuf& _buf, std::shared_ptr<ClothesPropertyScoreGreaterThan>& _out);

    ClothesPropertyScoreGreaterThan()
    { 

    }

    ClothesPropertyScoreGreaterThan(item::EClothesPropertyType prop, int32_t value ) 
            : condition::BoolRoleCondition()
    {

        this->prop = prop;
        this->value = value;
    }
    virtual ~ClothesPropertyScoreGreaterThan() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    item::EClothesPropertyType prop;
    /**
     
     */
    int32_t value;

    static constexpr int ID = 696630835;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace condition {





/**

 */
class ContainsItem : public  condition::RoleCondition 
{
    public:

    static bool deserializeContainsItem(ByteBuf& _buf, std::shared_ptr<ContainsItem>& _out);

    ContainsItem()
    { 

    }

    ContainsItem(int32_t item_id, int32_t num, bool reverse ) 
            : condition::RoleCondition()
    {

        this->itemId = item_id;
        this->num = num;
        this->reverse = reverse;
    }
    virtual ~ContainsItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int32_t num;
    /**
     
     */
    bool reverse;

    static constexpr int ID = 1961145317;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class ChooseOneBonus : public  bright::CfgBean 
{
    public:

    static bool deserializeChooseOneBonus(ByteBuf& _buf, std::shared_ptr<ChooseOneBonus>& _out);

    ChooseOneBonus()
    { 

    }

    ChooseOneBonus(int32_t drop_id, bool is_unique ) 
    {

        this->dropId = drop_id;
        this->isUnique = is_unique;
    }
    virtual ~ChooseOneBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t dropId;
    std::shared_ptr<bonus::DropInfo> dropId_Ref;
    /**
     
     */
    bool isUnique;

    static constexpr int ID = 228058347;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class InteractionItem : public  item::ItemExtra 
{
    public:

    static bool deserializeInteractionItem(ByteBuf& _buf, std::shared_ptr<InteractionItem>& _out);

    InteractionItem()
    { 

    }

    InteractionItem(int32_t id, std::shared_ptr<int32_t> attack_num, std::string holding_static_mesh, std::string holding_static_mesh_mat ) 
            : item::ItemExtra(id)
    {

        this->attackNum = attack_num;
        this->holdingStaticMesh = holding_static_mesh;
        this->holdingStaticMeshMat = holding_static_mesh_mat;
    }
    virtual ~InteractionItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<int32_t> attackNum;
    /**
     
     */
    std::string holdingStaticMesh;
    /**
     
     */
    std::string holdingStaticMeshMat;

    static constexpr int ID = 640937802;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class Clothes : public  item::ItemExtra 
{
    public:

    static bool deserializeClothes(ByteBuf& _buf, std::shared_ptr<Clothes>& _out);

    Clothes()
    { 

    }

    Clothes(int32_t id, int32_t attack, int64_t hp, int32_t energy_limit, int32_t energy_resume ) 
            : item::ItemExtra(id)
    {

        this->attack = attack;
        this->hp = hp;
        this->energyLimit = energy_limit;
        this->energyResume = energy_resume;
    }
    virtual ~Clothes() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t attack;
    /**
     
     */
    int64_t hp;
    /**
     
     */
    int32_t energyLimit;
    /**
     
     */
    int32_t energyResume;

    static constexpr int ID = 1659907149;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class DesignDrawing : public  item::ItemExtra 
{
    public:

    static bool deserializeDesignDrawing(ByteBuf& _buf, std::shared_ptr<DesignDrawing>& _out);

    DesignDrawing()
    { 

    }

    DesignDrawing(int32_t id, std::vector<int32_t> learn_component_id ) 
            : item::ItemExtra(id)
    {

        this->learnComponentId = learn_component_id;
    }
    virtual ~DesignDrawing() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<int32_t> learnComponentId;

    static constexpr int ID = -1679179579;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace item {





/**

 */
class Dymmy : public  item::ItemExtra 
{
    public:

    static bool deserializeDymmy(ByteBuf& _buf, std::shared_ptr<Dymmy>& _out);

    Dymmy()
    { 

    }

    Dymmy(int32_t id, std::shared_ptr<cost::Cost> cost ) 
            : item::ItemExtra(id)
    {

        this->cost = cost;
    }
    virtual ~Dymmy() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<cost::Cost> cost;

    static constexpr int ID = 896889705;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class Cost : public  bright::CfgBean 
{
    public:

    static bool deserializeCost(ByteBuf& _buf, std::shared_ptr<Cost>& _out);

    Cost()
    { 

    }

    virtual ~Cost() {}

    bool deserialize(ByteBuf& _buf);



    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class CostCurrency : public  cost::Cost 
{
    public:

    static bool deserializeCostCurrency(ByteBuf& _buf, std::shared_ptr<CostCurrency>& _out);

    CostCurrency()
    { 

    }

    CostCurrency(item::ECurrencyType type, int32_t num ) 
            : cost::Cost()
    {

        this->type = type;
        this->num = num;
    }
    virtual ~CostCurrency() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    item::ECurrencyType type;
    /**
     
     */
    int32_t num;

    static constexpr int ID = 911838111;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class CostCurrencies : public  cost::Cost 
{
    public:

    static bool deserializeCostCurrencies(ByteBuf& _buf, std::shared_ptr<CostCurrencies>& _out);

    CostCurrencies()
    { 

    }

    CostCurrencies(std::vector<std::shared_ptr<cost::CostCurrency>> currencies ) 
            : cost::Cost()
    {

        this->currencies = currencies;
    }
    virtual ~CostCurrencies() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<cost::CostCurrency>> currencies;

    static constexpr int ID = 103084157;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class CostOneItem : public  cost::Cost 
{
    public:

    static bool deserializeCostOneItem(ByteBuf& _buf, std::shared_ptr<CostOneItem>& _out);

    CostOneItem()
    { 

    }

    CostOneItem(int32_t item_id ) 
            : cost::Cost()
    {

        this->itemId = item_id;
    }
    virtual ~CostOneItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;

    static constexpr int ID = -1033587381;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class CostItem : public  cost::Cost 
{
    public:

    static bool deserializeCostItem(ByteBuf& _buf, std::shared_ptr<CostItem>& _out);

    CostItem()
    { 

    }

    CostItem(int32_t item_id, int32_t amount ) 
            : cost::Cost()
    {

        this->itemId = item_id;
        this->amount = amount;
    }
    virtual ~CostItem() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t itemId;
    std::shared_ptr<item::Item> itemId_Ref;
    /**
     
     */
    int32_t amount;

    static constexpr int ID = -1249440351;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace cost {





/**

 */
class CostItems : public  cost::Cost 
{
    public:

    static bool deserializeCostItems(ByteBuf& _buf, std::shared_ptr<CostItems>& _out);

    CostItems()
    { 

    }

    CostItems(std::vector<std::shared_ptr<cost::CostItem>> item_list ) 
            : cost::Cost()
    {

        this->itemList = item_list;
    }
    virtual ~CostItems() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::vector<std::shared_ptr<cost::CostItem>> itemList;

    static constexpr int ID = -77945102;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace l10n {





/**

 */
class L10NDemo : public  bright::CfgBean 
{
    public:

    static bool deserializeL10NDemo(ByteBuf& _buf, std::shared_ptr<L10NDemo>& _out);

    L10NDemo()
    { 

    }

    L10NDemo(int32_t id, std::string text ) 
    {

        this->id = id;
        this->text = text;
    }
    virtual ~L10NDemo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string text;

    static constexpr int ID = -331195887;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace l10n {





/**

 */
class PatchDemo : public  bright::CfgBean 
{
    public:

    static bool deserializePatchDemo(ByteBuf& _buf, std::shared_ptr<PatchDemo>& _out);

    PatchDemo()
    { 

    }

    PatchDemo(int32_t id, int32_t value ) 
    {

        this->id = id;
        this->value = value;
    }
    virtual ~PatchDemo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    int32_t value;

    static constexpr int ID = -1707294656;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace mail {





/**

 */
class SystemMail : public  bright::CfgBean 
{
    public:

    static bool deserializeSystemMail(ByteBuf& _buf, std::shared_ptr<SystemMail>& _out);

    SystemMail()
    { 

    }

    SystemMail(int32_t id, std::string title, std::string sender, std::string content, std::vector<int32_t> award ) 
    {

        this->id = id;
        this->title = title;
        this->sender = sender;
        this->content = content;
        this->award = award;
    }
    virtual ~SystemMail() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string title;
    /**
     
     */
    std::string sender;
    /**
     
     */
    std::string content;
    /**
     
     */
    std::vector<int32_t> award;

    static constexpr int ID = 1214073149;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace mail {





/**

 */
class GlobalMail : public  bright::CfgBean 
{
    public:

    static bool deserializeGlobalMail(ByteBuf& _buf, std::shared_ptr<GlobalMail>& _out);

    GlobalMail()
    { 

    }

    GlobalMail(int32_t id, std::string title, std::string sender, std::string content, std::vector<int32_t> award, bool all_server, std::vector<int32_t> server_list, std::string platform, std::string channel, std::shared_ptr<condition::MinMaxLevel> min_max_level, std::shared_ptr<condition::TimeRange> register_time, std::shared_ptr<condition::TimeRange> mail_time ) 
    {

        this->id = id;
        this->title = title;
        this->sender = sender;
        this->content = content;
        this->award = award;
        this->allServer = all_server;
        this->serverList = server_list;
        this->platform = platform;
        this->channel = channel;
        this->minMaxLevel = min_max_level;
        this->registerTime = register_time;
        this->mailTime = mail_time;
    }
    virtual ~GlobalMail() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string title;
    /**
     
     */
    std::string sender;
    /**
     
     */
    std::string content;
    /**
     
     */
    std::vector<int32_t> award;
    /**
     
     */
    bool allServer;
    /**
     
     */
    std::vector<int32_t> serverList;
    /**
     
     */
    std::string platform;
    /**
     
     */
    std::string channel;
    /**
     
     */
    std::shared_ptr<condition::MinMaxLevel> minMaxLevel;
    /**
     
     */
    std::shared_ptr<condition::TimeRange> registerTime;
    /**
     
     */
    std::shared_ptr<condition::TimeRange> mailTime;

    static constexpr int ID = -287571791;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace role {





/**

 */
class LevelExpAttr : public  bright::CfgBean 
{
    public:

    static bool deserializeLevelExpAttr(ByteBuf& _buf, std::shared_ptr<LevelExpAttr>& _out);

    LevelExpAttr()
    { 

    }

    LevelExpAttr(int32_t level, int64_t need_exp, std::vector<int32_t> clothes_attrs ) 
    {

        this->level = level;
        this->needExp = need_exp;
        this->clothesAttrs = clothes_attrs;
    }
    virtual ~LevelExpAttr() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t level;
    /**
     
     */
    int64_t needExp;
    /**
     
     */
    std::vector<int32_t> clothesAttrs;

    static constexpr int ID = -1569837022;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace role {





/**

 */
class LevelBonus : public  bright::CfgBean 
{
    public:

    static bool deserializeLevelBonus(ByteBuf& _buf, std::shared_ptr<LevelBonus>& _out);

    LevelBonus()
    { 

    }

    LevelBonus(int32_t id, std::vector<std::shared_ptr<role::DistinctBonusInfos>> distinct_bonus_infos ) 
    {

        this->id = id;
        this->distinctBonusInfos = distinct_bonus_infos;
    }
    virtual ~LevelBonus() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::vector<std::shared_ptr<role::DistinctBonusInfos>> distinctBonusInfos;

    static constexpr int ID = -572269677;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace role {





/**

 */
class DistinctBonusInfos : public  bright::CfgBean 
{
    public:

    static bool deserializeDistinctBonusInfos(ByteBuf& _buf, std::shared_ptr<DistinctBonusInfos>& _out);

    DistinctBonusInfos()
    { 

    }

    DistinctBonusInfos(int32_t effective_level, std::vector<std::shared_ptr<role::BonusInfo>> bonus_info ) 
    {

        this->effectiveLevel = effective_level;
        this->bonusInfo = bonus_info;
    }
    virtual ~DistinctBonusInfos() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t effectiveLevel;
    /**
     
     */
    std::vector<std::shared_ptr<role::BonusInfo>> bonusInfo;

    static constexpr int ID = -854361766;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace role {





/**

 */
class BonusInfo : public  bright::CfgBean 
{
    public:

    static bool deserializeBonusInfo(ByteBuf& _buf, std::shared_ptr<BonusInfo>& _out);

    BonusInfo()
    { 

    }

    BonusInfo(item::ECurrencyType type, float coefficient ) 
    {

        this->type = type;
        this->coefficient = coefficient;
    }
    virtual ~BonusInfo() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    item::ECurrencyType type;
    /**
     
     */
    float coefficient;

    static constexpr int ID = -1354421803;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace tag {





/**

 */
class TestTag : public  bright::CfgBean 
{
    public:

    static bool deserializeTestTag(ByteBuf& _buf, std::shared_ptr<TestTag>& _out);

    TestTag()
    { 

    }

    TestTag(int32_t id, std::string value ) 
    {

        this->id = id;
        this->value = value;
    }
    virtual ~TestTag() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string value;

    static constexpr int ID = 1742933812;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoType2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoType2(ByteBuf& _buf, std::shared_ptr<DemoType2>& _out);

    DemoType2()
    { 

    }

    DemoType2(int32_t x4, bool x1, uint8_t x2, int16_t x3, int64_t x5, float x6, double x7, int16_t x8_0, int32_t x8, int64_t x9, std::string x10, std::shared_ptr<test::DemoType1> x12, test::DemoEnum x13, std::shared_ptr<test::DemoDynamic> x14, std::string s1, bright::math::Vector2 v2, bright::math::Vector3 v3, bright::math::Vector4 v4, int32_t t1, std::vector<int32_t> k1, std::vector<int32_t> k2, std::vector<int32_t> k3, std::vector<int32_t> k4, std::unordered_set<int32_t> k5, std::unordered_set<int32_t> k6, std::unordered_set<int32_t> k7, std::unordered_map<int32_t, int32_t> k8, std::vector<std::shared_ptr<test::DemoE2>> k9, std::vector<std::shared_ptr<test::DemoDynamic>> k15 ) 
    {

        this->x4 = x4;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x5 = x5;
        this->x6 = x6;
        this->x7 = x7;
        this->x80 = x8_0;
        this->x8 = x8;
        this->x9 = x9;
        this->x10 = x10;
        this->x12 = x12;
        this->x13 = x13;
        this->x14 = x14;
        this->s1 = s1;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
        this->t1 = t1;
        this->k1 = k1;
        this->k2 = k2;
        this->k3 = k3;
        this->k4 = k4;
        this->k5 = k5;
        this->k6 = k6;
        this->k7 = k7;
        this->k8 = k8;
        this->k9 = k9;
        this->k15 = k15;
    }
    virtual ~DemoType2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x4;
    /**
     
     */
    bool x1;
    /**
     
     */
    uint8_t x2;
    /**
     
     */
    int16_t x3;
    std::shared_ptr<test::DemoType2> x3_Ref;
    /**
     
     */
    int64_t x5;
    /**
     
     */
    float x6;
    /**
     
     */
    double x7;
    /**
     
     */
    int16_t x80;
    /**
     
     */
    int32_t x8;
    /**
     
     */
    int64_t x9;
    /**
     
     */
    std::string x10;
    /**
     
     */
    std::shared_ptr<test::DemoType1> x12;
    /**
     
     */
    test::DemoEnum x13;
    /**
     
     */
    std::shared_ptr<test::DemoDynamic> x14;
    /**
     
     */
    std::string s1;
    /**
     
     */
    bright::math::Vector2 v2;
    /**
     
     */
    bright::math::Vector3 v3;
    /**
     
     */
    bright::math::Vector4 v4;
    /**
     
     */
    int32_t t1;
    /**
     
     */
    std::vector<int32_t> k1;
    /**
     
     */
    std::vector<int32_t> k2;
    /**
     
     */
    std::vector<int32_t> k3;
    /**
     
     */
    std::vector<int32_t> k4;
    /**
     
     */
    std::unordered_set<int32_t> k5;
    /**
     
     */
    std::unordered_set<int32_t> k6;
    /**
     
     */
    std::unordered_set<int32_t> k7;
    /**
     
     */
    std::unordered_map<int32_t, int32_t> k8;
    /**
     
     */
    std::vector<std::shared_ptr<test::DemoE2>> k9;
    std::unordered_map<std::shared_ptr<int32_t>, std::shared_ptr<test::DemoE2>> k9_Index;
    /**
     
     */
    std::vector<std::shared_ptr<test::DemoDynamic>> k15;

    static constexpr int ID = -367048295;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoType1 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoType1(ByteBuf& _buf, std::shared_ptr<DemoType1>& _out);

    DemoType1()
    { 

    }

    DemoType1(int32_t x1 ) 
    {

        this->x1 = x1;
    }
    virtual ~DemoType1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x1;

    static constexpr int ID = -367048296;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoDynamic : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoDynamic(ByteBuf& _buf, std::shared_ptr<DemoDynamic>& _out);

    DemoDynamic()
    { 

    }

    DemoDynamic(int32_t x1 ) 
    {

        this->x1 = x1;
    }
    virtual ~DemoDynamic() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x1;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoD2 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD2(ByteBuf& _buf, std::shared_ptr<DemoD2>& _out);

    DemoD2()
    { 

    }

    DemoD2(int32_t x1, int32_t x2 ) 
            : test::DemoDynamic(x1)
    {

        this->x2 = x2;
    }
    virtual ~DemoD2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x2;

    static constexpr int ID = -2138341747;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoD3 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD3(ByteBuf& _buf, std::shared_ptr<DemoD3>& _out);

    DemoD3()
    { 

    }

    DemoD3(int32_t x1, int32_t x3 ) 
            : test::DemoDynamic(x1)
    {

        this->x3 = x3;
    }
    virtual ~DemoD3() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x3;


    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoE1 : public  test::DemoD3 
{
    public:

    static bool deserializeDemoE1(ByteBuf& _buf, std::shared_ptr<DemoE1>& _out);

    DemoE1()
    { 

    }

    DemoE1(int32_t x1, int32_t x3, int32_t x4 ) 
            : test::DemoD3(x1, x3)
    {

        this->x4 = x4;
    }
    virtual ~DemoE1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t x4;

    static constexpr int ID = -2138341717;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoD5 : public  test::DemoDynamic 
{
    public:

    static bool deserializeDemoD5(ByteBuf& _buf, std::shared_ptr<DemoD5>& _out);

    DemoD5()
    { 

    }

    DemoD5(int32_t x1, std::shared_ptr<test::DateTimeRange> time ) 
            : test::DemoDynamic(x1)
    {

        this->time = time;
    }
    virtual ~DemoD5() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<test::DateTimeRange> time;

    static constexpr int ID = -2138341744;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DateTimeRange : public  bright::CfgBean 
{
    public:

    static bool deserializeDateTimeRange(ByteBuf& _buf, std::shared_ptr<DateTimeRange>& _out);

    DateTimeRange()
    { 

    }

    DateTimeRange(int32_t start_time, int32_t end_time ) 
    {

        this->startTime = start_time;
        this->endTime = end_time;
    }
    virtual ~DateTimeRange() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t startTime;
    /**
     
     */
    int32_t endTime;

    static constexpr int ID = 495315430;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoE2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoE2(ByteBuf& _buf, std::shared_ptr<DemoE2>& _out);

    DemoE2()
    { 

    }

    DemoE2(std::shared_ptr<int32_t> y1, bool y2 ) 
    {

        this->y1 = y1;
        this->y2 = y2;
    }
    virtual ~DemoE2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<int32_t> y1;
    /**
     
     */
    bool y2;

    static constexpr int ID = -2138341716;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoSingletonType : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoSingletonType(ByteBuf& _buf, std::shared_ptr<DemoSingletonType>& _out);

    DemoSingletonType()
    { 

    }

    DemoSingletonType(int32_t id, std::string name, std::shared_ptr<test::DemoDynamic> date ) 
    {

        this->id = id;
        this->name = name;
        this->date = date;
    }
    virtual ~DemoSingletonType() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string name;
    /**
     
     */
    std::shared_ptr<test::DemoDynamic> date;

    static constexpr int ID = 539196998;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class MultiRowRecord : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowRecord(ByteBuf& _buf, std::shared_ptr<MultiRowRecord>& _out);

    MultiRowRecord()
    { 

    }

    MultiRowRecord(int32_t id, std::string name, std::vector<std::shared_ptr<test::MultiRowType1>> one_rows, std::vector<std::shared_ptr<test::MultiRowType1>> multi_rows1, std::vector<std::shared_ptr<test::MultiRowType1>> multi_rows2, std::unordered_set<std::shared_ptr<test::MultiRowType2>> multi_rows3, std::unordered_map<int32_t, std::shared_ptr<test::MultiRowType2>> multi_rows4, std::vector<std::shared_ptr<test::MultiRowType3>> multi_rows5 ) 
    {

        this->id = id;
        this->name = name;
        this->oneRows = one_rows;
        this->multiRows1 = multi_rows1;
        this->multiRows2 = multi_rows2;
        this->multiRows3 = multi_rows3;
        this->multiRows4 = multi_rows4;
        this->multiRows5 = multi_rows5;
    }
    virtual ~MultiRowRecord() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string name;
    /**
     
     */
    std::vector<std::shared_ptr<test::MultiRowType1>> oneRows;
    /**
     
     */
    std::vector<std::shared_ptr<test::MultiRowType1>> multiRows1;
    /**
     
     */
    std::vector<std::shared_ptr<test::MultiRowType1>> multiRows2;
    /**
     
     */
    std::unordered_set<std::shared_ptr<test::MultiRowType2>> multiRows3;
    /**
     
     */
    std::unordered_map<int32_t, std::shared_ptr<test::MultiRowType2>> multiRows4;
    /**
     
     */
    std::vector<std::shared_ptr<test::MultiRowType3>> multiRows5;

    static constexpr int ID = -501249394;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class MultiRowType1 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType1(ByteBuf& _buf, std::shared_ptr<MultiRowType1>& _out);

    MultiRowType1()
    { 

    }

    MultiRowType1(int32_t id, int32_t x ) 
    {

        this->id = id;
        this->x = x;
    }
    virtual ~MultiRowType1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    int32_t x;

    static constexpr int ID = 540474970;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class MultiRowType2 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType2(ByteBuf& _buf, std::shared_ptr<MultiRowType2>& _out);

    MultiRowType2()
    { 

    }

    MultiRowType2(int32_t id, int32_t x, float y ) 
    {

        this->id = id;
        this->x = x;
        this->y = y;
    }
    virtual ~MultiRowType2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    int32_t x;
    /**
     
     */
    float y;

    static constexpr int ID = 540474971;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class MultiRowType3 : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowType3(ByteBuf& _buf, std::shared_ptr<MultiRowType3>& _out);

    MultiRowType3()
    { 

    }

    MultiRowType3(int32_t id, std::vector<std::shared_ptr<test::MultiRowType1>> items ) 
    {

        this->id = id;
        this->items = items;
    }
    virtual ~MultiRowType3() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::vector<std::shared_ptr<test::MultiRowType1>> items;

    static constexpr int ID = 540474972;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class MultiRowTitle : public  bright::CfgBean 
{
    public:

    static bool deserializeMultiRowTitle(ByteBuf& _buf, std::shared_ptr<MultiRowTitle>& _out);

    MultiRowTitle()
    { 

    }

    MultiRowTitle(int32_t id, std::string name, std::shared_ptr<test::H1> x1, std::vector<std::shared_ptr<test::H2>> x2, std::vector<std::shared_ptr<test::H2>> x3 ) 
    {

        this->id = id;
        this->name = name;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
    }
    virtual ~MultiRowTitle() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string name;
    /**
     
     */
    std::shared_ptr<test::H1> x1;
    /**
     
     */
    std::vector<std::shared_ptr<test::H2>> x2;
    /**
     
     */
    std::vector<std::shared_ptr<test::H2>> x3;

    static constexpr int ID = 540002427;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class H1 : public  bright::CfgBean 
{
    public:

    static bool deserializeH1(ByteBuf& _buf, std::shared_ptr<H1>& _out);

    H1()
    { 

    }

    H1(std::shared_ptr<test::H2> y2, int32_t y3 ) 
    {

        this->y2 = y2;
        this->y3 = y3;
    }
    virtual ~H1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    std::shared_ptr<test::H2> y2;
    /**
     
     */
    int32_t y3;

    static constexpr int ID = -1422503995;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class H2 : public  bright::CfgBean 
{
    public:

    static bool deserializeH2(ByteBuf& _buf, std::shared_ptr<H2>& _out);

    H2()
    { 

    }

    H2(int32_t z2, int32_t z3 ) 
    {

        this->z2 = z2;
        this->z3 = z3;
    }
    virtual ~H2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t z2;
    /**
     
     */
    int32_t z3;

    static constexpr int ID = -1422503994;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class TestNull : public  bright::CfgBean 
{
    public:

    static bool deserializeTestNull(ByteBuf& _buf, std::shared_ptr<TestNull>& _out);

    TestNull()
    { 

    }

    TestNull(int32_t id, std::shared_ptr<int32_t> x1, std::shared_ptr<test::DemoEnum> x2, std::shared_ptr<test::DemoType1> x3, std::shared_ptr<test::DemoDynamic> x4, std::shared_ptr<std::string> s1, std::shared_ptr<std::string> s2 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->s1 = s1;
        this->s2 = s2;
    }
    virtual ~TestNull() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::shared_ptr<int32_t> x1;
    /**
     
     */
    std::shared_ptr<test::DemoEnum> x2;
    /**
     
     */
    std::shared_ptr<test::DemoType1> x3;
    /**
     
     */
    std::shared_ptr<test::DemoDynamic> x4;
    /**
     
     */
    std::shared_ptr<std::string> s1;
    /**
     
     */
    std::shared_ptr<std::string> s2;

    static constexpr int ID = 339868469;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoPrimitiveTypesTable : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoPrimitiveTypesTable(ByteBuf& _buf, std::shared_ptr<DemoPrimitiveTypesTable>& _out);

    DemoPrimitiveTypesTable()
    { 

    }

    DemoPrimitiveTypesTable(bool x1, uint8_t x2, int16_t x3, int32_t x4, int64_t x5, float x6, double x7, std::string s1, std::string s2, bright::math::Vector2 v2, bright::math::Vector3 v3, bright::math::Vector4 v4, int32_t t1 ) 
    {

        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->x5 = x5;
        this->x6 = x6;
        this->x7 = x7;
        this->s1 = s1;
        this->s2 = s2;
        this->v2 = v2;
        this->v3 = v3;
        this->v4 = v4;
        this->t1 = t1;
    }
    virtual ~DemoPrimitiveTypesTable() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    bool x1;
    /**
     
     */
    uint8_t x2;
    /**
     
     */
    int16_t x3;
    /**
     
     */
    int32_t x4;
    /**
     
     */
    int64_t x5;
    /**
     
     */
    float x6;
    /**
     
     */
    double x7;
    /**
     
     */
    std::string s1;
    /**
     
     */
    std::string s2;
    /**
     
     */
    bright::math::Vector2 v2;
    /**
     
     */
    bright::math::Vector3 v3;
    /**
     
     */
    bright::math::Vector4 v4;
    /**
     
     */
    int32_t t1;

    static constexpr int ID = -370934083;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class TestString : public  bright::CfgBean 
{
    public:

    static bool deserializeTestString(ByteBuf& _buf, std::shared_ptr<TestString>& _out);

    TestString()
    { 

    }

    TestString(int32_t id, std::string s1, std::shared_ptr<test::CompactString> cs1, std::shared_ptr<test::CompactString> cs2 ) 
    {

        this->id = id;
        this->s1 = s1;
        this->cs1 = cs1;
        this->cs2 = cs2;
    }
    virtual ~TestString() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string s1;
    /**
     
     */
    std::shared_ptr<test::CompactString> cs1;
    /**
     
     */
    std::shared_ptr<test::CompactString> cs2;

    static constexpr int ID = 338485823;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class CompactString : public  bright::CfgBean 
{
    public:

    static bool deserializeCompactString(ByteBuf& _buf, std::shared_ptr<CompactString>& _out);

    CompactString()
    { 

    }

    CompactString(int32_t id, std::string s2, std::string s3 ) 
    {

        this->id = id;
        this->s2 = s2;
        this->s3 = s3;
    }
    virtual ~CompactString() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string s2;
    /**
     
     */
    std::string s3;

    static constexpr int ID = 1968089240;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DemoGroup : public  bright::CfgBean 
{
    public:

    static bool deserializeDemoGroup(ByteBuf& _buf, std::shared_ptr<DemoGroup>& _out);

    DemoGroup()
    { 

    }

    DemoGroup(int32_t id, int32_t x1, int32_t x2, int32_t x3, int32_t x4, std::shared_ptr<test::InnerGroup> x5 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
        this->x5 = x5;
    }
    virtual ~DemoGroup() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    int32_t x1;
    /**
     
     */
    int32_t x2;
    /**
     
     */
    int32_t x3;
    /**
     
     */
    int32_t x4;
    /**
     
     */
    std::shared_ptr<test::InnerGroup> x5;

    static constexpr int ID = -379263008;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class InnerGroup : public  bright::CfgBean 
{
    public:

    static bool deserializeInnerGroup(ByteBuf& _buf, std::shared_ptr<InnerGroup>& _out);

    InnerGroup()
    { 

    }

    InnerGroup(int32_t y1, int32_t y2, int32_t y3, int32_t y4 ) 
    {

        this->y1 = y1;
        this->y2 = y2;
        this->y3 = y3;
        this->y4 = y4;
    }
    virtual ~InnerGroup() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t y1;
    /**
     
     */
    int32_t y2;
    /**
     
     */
    int32_t y3;
    /**
     
     */
    int32_t y4;

    static constexpr int ID = -587873083;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class TestGlobal : public  bright::CfgBean 
{
    public:

    static bool deserializeTestGlobal(ByteBuf& _buf, std::shared_ptr<TestGlobal>& _out);

    TestGlobal()
    { 

    }

    TestGlobal(int32_t unlock_equip, int32_t unlock_hero ) 
    {

        this->unlockEquip = unlock_equip;
        this->unlockHero = unlock_hero;
    }
    virtual ~TestGlobal() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t unlockEquip;
    /**
     
     */
    int32_t unlockHero;

    static constexpr int ID = -12548655;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DetectEncoding : public  bright::CfgBean 
{
    public:

    static bool deserializeDetectEncoding(ByteBuf& _buf, std::shared_ptr<DetectEncoding>& _out);

    DetectEncoding()
    { 

    }

    DetectEncoding(int32_t id, std::string name ) 
    {

        this->id = id;
        this->name = name;
    }
    virtual ~DetectEncoding() {}

    bool deserialize(ByteBuf& _buf);

    /**
     
     */
    int32_t id;
    /**
     
     */
    std::string name;

    static constexpr int ID = -1154609646;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DefineFromExcel : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcel(ByteBuf& _buf, std::shared_ptr<DefineFromExcel>& _out);

    DefineFromExcel()
    { 

    }

    DefineFromExcel(int32_t id, bool x1, int64_t x5, float x6, int32_t x8, std::string x10, test::ETestQuality x13, std::shared_ptr<test::DemoDynamic> x14, bright::math::Vector2 v2, int32_t t1, std::vector<int32_t> k1, std::unordered_map<int32_t, int32_t> k8, std::vector<std::shared_ptr<test::DemoE2>> k9 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x5 = x5;
        this->x6 = x6;
        this->x8 = x8;
        this->x10 = x10;
        this->x13 = x13;
        this->x14 = x14;
        this->v2 = v2;
        this->t1 = t1;
        this->k1 = k1;
        this->k8 = k8;
        this->k9 = k9;
    }
    virtual ~DefineFromExcel() {}

    bool deserialize(ByteBuf& _buf);

    /**
     id的描述
     */
    int32_t id;
    /**
     字段的描述
     */
    bool x1;
    /**
     
     */
    int64_t x5;
    /**
     
     */
    float x6;
    /**
     
     */
    int32_t x8;
    std::shared_ptr<test::DemoPrimitiveTypesTable> x8_Ref;
    /**
     
     */
    std::string x10;
    /**
     
     */
    test::ETestQuality x13;
    /**
     
     */
    std::shared_ptr<test::DemoDynamic> x14;
    /**
     
     */
    bright::math::Vector2 v2;
    /**
     
     */
    int32_t t1;
    /**
     
     */
    std::vector<int32_t> k1;
    /**
     
     */
    std::unordered_map<int32_t, int32_t> k8;
    /**
     
     */
    std::vector<std::shared_ptr<test::DemoE2>> k9;

    static constexpr int ID = 2100429878;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DefineFromExcelOne : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcelOne(ByteBuf& _buf, std::shared_ptr<DefineFromExcelOne>& _out);

    DefineFromExcelOne()
    { 

    }

    DefineFromExcelOne(int32_t unlock_equip, int32_t unlock_hero, std::string default_avatar, std::string default_item ) 
    {

        this->unlockEquip = unlock_equip;
        this->unlockHero = unlock_hero;
        this->defaultAvatar = default_avatar;
        this->defaultItem = default_item;
    }
    virtual ~DefineFromExcelOne() {}

    bool deserialize(ByteBuf& _buf);

    /**
     装备解锁等级_描述
     */
    int32_t unlockEquip;
    /**
     英雄解锁等级
     */
    int32_t unlockHero;
    /**
     默认头像
     */
    std::string defaultAvatar;
    /**
     
     */
    std::string defaultItem;

    static constexpr int ID = 528039504;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**

 */
class DefineFromExcel2 : public  bright::CfgBean 
{
    public:

    static bool deserializeDefineFromExcel2(ByteBuf& _buf, std::shared_ptr<DefineFromExcel2>& _out);

    DefineFromExcel2()
    { 

    }

    DefineFromExcel2(int32_t id, bool x1, int64_t x5, float x6, int32_t x8, std::string x10, test::ETestQuality x13, std::shared_ptr<test::DemoDynamic> x14, bright::math::Vector2 v2, int32_t t1, std::vector<int32_t> k1, std::unordered_map<int32_t, int32_t> k8, std::vector<std::shared_ptr<test::DemoE2>> k9 ) 
    {

        this->id = id;
        this->x1 = x1;
        this->x5 = x5;
        this->x6 = x6;
        this->x8 = x8;
        this->x10 = x10;
        this->x13 = x13;
        this->x14 = x14;
        this->v2 = v2;
        this->t1 = t1;
        this->k1 = k1;
        this->k8 = k8;
        this->k9 = k9;
    }
    virtual ~DefineFromExcel2() {}

    bool deserialize(ByteBuf& _buf);

    /**
     id的描述
     */
    int32_t id;
    /**
     字段的描述
     */
    bool x1;
    /**
     
     */
    int64_t x5;
    /**
     
     */
    float x6;
    /**
     
     */
    int32_t x8;
    std::shared_ptr<test::DemoPrimitiveTypesTable> x8_Ref;
    /**
     
     */
    std::string x10;
    /**
     
     */
    test::ETestQuality x13;
    /**
     
     */
    std::shared_ptr<test::DemoDynamic> x14;
    /**
     
     */
    bright::math::Vector2 v2;
    /**
     
     */
    int32_t t1;
    /**
     
     */
    std::vector<int32_t> k1;
    /**
     
     */
    std::unordered_map<int32_t, int32_t> k8;
    /**
     
     */
    std::vector<std::shared_ptr<test::DemoE2>> k9;

    static constexpr int ID = 688816828;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace test {





/**
这是个测试excel结构
 */
class TestExcelBean1 : public  bright::CfgBean 
{
    public:

    static bool deserializeTestExcelBean1(ByteBuf& _buf, std::shared_ptr<TestExcelBean1>& _out);

    TestExcelBean1()
    { 

    }

    TestExcelBean1(int32_t x1, std::string x2, int32_t x3, float x4 ) 
    {

        this->x1 = x1;
        this->x2 = x2;
        this->x3 = x3;
        this->x4 = x4;
    }
    virtual ~TestExcelBean1() {}

    bool deserialize(ByteBuf& _buf);

    /**
     最高品质
     */
    int32_t x1;
    /**
     黑色的
     */
    std::string x2;
    /**
     蓝色的
     */
    int32_t x3;
    /**
     最差品质
     */
    float x4;

    static constexpr int ID = -1738345160;

    int getTypeId() const { return ID; }

    virtual void resolve(std::unordered_map<std::string, void*>& _tables);
};

}



namespace ai {


/**

 */
class TbBlackboard
{
    private:
    std::unordered_map<std::string, std::shared_ptr<ai::Blackboard>> _dataMap;
    std::vector<std::shared_ptr<ai::Blackboard>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<ai::Blackboard> _v;
            if(!ai::Blackboard::deserializeBlackboard(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->name] = _v;
        }
        return true;
    }

    const std::unordered_map<std::string, std::shared_ptr<ai::Blackboard>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<ai::Blackboard>>& getDataList() const { return _dataList; }

    ai::Blackboard* getRaw(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<ai::Blackboard> get(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace ai {


/**

 */
class TbBehaviorTree
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<ai::BehaviorTree>> _dataMap;
    std::vector<std::shared_ptr<ai::BehaviorTree>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<ai::BehaviorTree> _v;
            if(!ai::BehaviorTree::deserializeBehaviorTree(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<ai::BehaviorTree>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<ai::BehaviorTree>>& getDataList() const { return _dataList; }

    ai::BehaviorTree* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<ai::BehaviorTree> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace blueprint {


/**

 */
class TbClazz
{
    private:
    std::unordered_map<std::string, std::shared_ptr<blueprint::Clazz>> _dataMap;
    std::vector<std::shared_ptr<blueprint::Clazz>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<blueprint::Clazz> _v;
            if(!blueprint::Clazz::deserializeClazz(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->name] = _v;
        }
        return true;
    }

    const std::unordered_map<std::string, std::shared_ptr<blueprint::Clazz>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<blueprint::Clazz>>& getDataList() const { return _dataList; }

    blueprint::Clazz* getRaw(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<blueprint::Clazz> get(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace bonus {


/**

 */
class TbDrop
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<bonus::DropInfo>> _dataMap;
    std::vector<std::shared_ptr<bonus::DropInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<bonus::DropInfo> _v;
            if(!bonus::DropInfo::deserializeDropInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<bonus::DropInfo>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<bonus::DropInfo>>& getDataList() const { return _dataList; }

    bonus::DropInfo* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<bonus::DropInfo> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace common {


/**

 */
class TbGlobalConfig
{
     private:
    std::shared_ptr<common::GlobalConfig> _data;

    public:
    std::shared_ptr<common::GlobalConfig> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!common::GlobalConfig::deserializeGlobalConfig(_buf, _data)) return false;
        return true;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
    背包容量
     */
    int32_t& getBagCapacity() const { return _data->bagCapacity; }
    /**
    
     */
    int32_t& getBagCapacitySpecial() const { return _data->bagCapacitySpecial; }
    /**
    
     */
    int32_t& getBagTempExpendableCapacity() const { return _data->bagTempExpendableCapacity; }
    /**
    
     */
    int32_t& getBagTempToolCapacity() const { return _data->bagTempToolCapacity; }
    /**
    
     */
    int32_t& getBagInitCapacity() const { return _data->bagInitCapacity; }
    /**
    
     */
    int32_t& getQuickBagCapacity() const { return _data->quickBagCapacity; }
    /**
    
     */
    int32_t& getClothBagCapacity() const { return _data->clothBagCapacity; }
    /**
    
     */
    int32_t& getClothBagInitCapacity() const { return _data->clothBagInitCapacity; }
    /**
    
     */
    int32_t& getClothBagCapacitySpecial() const { return _data->clothBagCapacitySpecial; }
    /**
    
     */
    std::shared_ptr<int32_t>& getBagInitItemsDropId() const { return _data->bagInitItemsDropId; }
    /**
    
     */
    int32_t& getMailBoxCapacity() const { return _data->mailBoxCapacity; }
    /**
    
     */
    float& getDamageParamC() const { return _data->damageParamC; }
    /**
    
     */
    float& getDamageParamE() const { return _data->damageParamE; }
    /**
    
     */
    float& getDamageParamF() const { return _data->damageParamF; }
    /**
    
     */
    float& getDamageParamD() const { return _data->damageParamD; }
    /**
    
     */
    float& getRoleSpeed() const { return _data->roleSpeed; }
    /**
    
     */
    float& getMonsterSpeed() const { return _data->monsterSpeed; }
    /**
    
     */
    int32_t& getInitEnergy() const { return _data->initEnergy; }
    /**
    
     */
    int32_t& getInitViality() const { return _data->initViality; }
    /**
    
     */
    int32_t& getMaxViality() const { return _data->maxViality; }
    /**
    
     */
    int32_t& getPerVialityRecoveryTime() const { return _data->perVialityRecoveryTime; }
};
}


namespace common {


/**

 */
class TbDummy
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<common::Dummy>> _dataMap;
    std::vector<std::shared_ptr<common::Dummy>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<common::Dummy> _v;
            if(!common::Dummy::deserializeDummy(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<common::Dummy>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<common::Dummy>>& getDataList() const { return _dataList; }

    common::Dummy* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<common::Dummy> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace error {


/**

 */
class TbErrorInfo
{
    private:
    std::unordered_map<std::string, std::shared_ptr<error::ErrorInfo>> _dataMap;
    std::vector<std::shared_ptr<error::ErrorInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<error::ErrorInfo> _v;
            if(!error::ErrorInfo::deserializeErrorInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->code] = _v;
        }
        return true;
    }

    const std::unordered_map<std::string, std::shared_ptr<error::ErrorInfo>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<error::ErrorInfo>>& getDataList() const { return _dataList; }

    error::ErrorInfo* getRaw(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<error::ErrorInfo> get(std::string key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace error {


/**

 */
class TbCodeInfo
{
    private:
    std::unordered_map<error::EErrorCode, std::shared_ptr<error::CodeInfo>> _dataMap;
    std::vector<std::shared_ptr<error::CodeInfo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<error::CodeInfo> _v;
            if(!error::CodeInfo::deserializeCodeInfo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->code] = _v;
        }
        return true;
    }

    const std::unordered_map<error::EErrorCode, std::shared_ptr<error::CodeInfo>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<error::CodeInfo>>& getDataList() const { return _dataList; }

    error::CodeInfo* getRaw(error::EErrorCode key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<error::CodeInfo> get(error::EErrorCode key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace item {


/**
道具表
 */
class TbItem
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<item::Item>> _dataMap;
    std::vector<std::shared_ptr<item::Item>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<item::Item> _v;
            if(!item::Item::deserializeItem(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<item::Item>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<item::Item>>& getDataList() const { return _dataList; }

    item::Item* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<item::Item> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace item {


/**

 */
class TbItemFunc
{
    private:
    std::unordered_map<item::EMinorType, std::shared_ptr<item::ItemFunction>> _dataMap;
    std::vector<std::shared_ptr<item::ItemFunction>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<item::ItemFunction> _v;
            if(!item::ItemFunction::deserializeItemFunction(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->minorType] = _v;
        }
        return true;
    }

    const std::unordered_map<item::EMinorType, std::shared_ptr<item::ItemFunction>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<item::ItemFunction>>& getDataList() const { return _dataList; }

    item::ItemFunction* getRaw(item::EMinorType key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<item::ItemFunction> get(item::EMinorType key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace item {


/**

 */
class TbItemExtra
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<item::ItemExtra>> _dataMap;
    std::vector<std::shared_ptr<item::ItemExtra>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<item::ItemExtra> _v;
            if(!item::ItemExtra::deserializeItemExtra(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<item::ItemExtra>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<item::ItemExtra>>& getDataList() const { return _dataList; }

    item::ItemExtra* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<item::ItemExtra> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace l10n {


/**

 */
class TbL10NDemo
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<l10n::L10NDemo>> _dataMap;
    std::vector<std::shared_ptr<l10n::L10NDemo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<l10n::L10NDemo> _v;
            if(!l10n::L10NDemo::deserializeL10NDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<l10n::L10NDemo>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<l10n::L10NDemo>>& getDataList() const { return _dataList; }

    l10n::L10NDemo* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<l10n::L10NDemo> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace l10n {


/**

 */
class TbPatchDemo
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<l10n::PatchDemo>> _dataMap;
    std::vector<std::shared_ptr<l10n::PatchDemo>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<l10n::PatchDemo> _v;
            if(!l10n::PatchDemo::deserializePatchDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<l10n::PatchDemo>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<l10n::PatchDemo>>& getDataList() const { return _dataList; }

    l10n::PatchDemo* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<l10n::PatchDemo> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace mail {


/**

 */
class TbSystemMail
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<mail::SystemMail>> _dataMap;
    std::vector<std::shared_ptr<mail::SystemMail>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<mail::SystemMail> _v;
            if(!mail::SystemMail::deserializeSystemMail(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<mail::SystemMail>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<mail::SystemMail>>& getDataList() const { return _dataList; }

    mail::SystemMail* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<mail::SystemMail> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace mail {


/**

 */
class TbGlobalMail
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<mail::GlobalMail>> _dataMap;
    std::vector<std::shared_ptr<mail::GlobalMail>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<mail::GlobalMail> _v;
            if(!mail::GlobalMail::deserializeGlobalMail(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<mail::GlobalMail>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<mail::GlobalMail>>& getDataList() const { return _dataList; }

    mail::GlobalMail* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<mail::GlobalMail> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace role {


/**

 */
class TbRoleLevelExpAttr
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<role::LevelExpAttr>> _dataMap;
    std::vector<std::shared_ptr<role::LevelExpAttr>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<role::LevelExpAttr> _v;
            if(!role::LevelExpAttr::deserializeLevelExpAttr(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->level] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<role::LevelExpAttr>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<role::LevelExpAttr>>& getDataList() const { return _dataList; }

    role::LevelExpAttr* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<role::LevelExpAttr> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace role {


/**

 */
class TbRoleLevelBonusCoefficient
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<role::LevelBonus>> _dataMap;
    std::vector<std::shared_ptr<role::LevelBonus>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<role::LevelBonus> _v;
            if(!role::LevelBonus::deserializeLevelBonus(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<role::LevelBonus>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<role::LevelBonus>>& getDataList() const { return _dataList; }

    role::LevelBonus* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<role::LevelBonus> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace tag {


/**

 */
class TbTestTag
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<tag::TestTag>> _dataMap;
    std::vector<std::shared_ptr<tag::TestTag>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<tag::TestTag> _v;
            if(!tag::TestTag::deserializeTestTag(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<tag::TestTag>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<tag::TestTag>>& getDataList() const { return _dataList; }

    tag::TestTag* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<tag::TestTag> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbFullTypes
{
    private:
    std::unordered_map<int16_t, std::shared_ptr<test::DemoType2>> _dataMap;
    std::vector<std::shared_ptr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x3] = _v;
        }
        return true;
    }

    const std::unordered_map<int16_t, std::shared_ptr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(int16_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoType2> get(int16_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbSingleton
{
     private:
    std::shared_ptr<test::DemoSingletonType> _data;

    public:
    std::shared_ptr<test::DemoSingletonType> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::DemoSingletonType::deserializeDemoSingletonType(_buf, _data)) return false;
        return true;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
    
     */
    int32_t& getId() const { return _data->id; }
    /**
    
     */
    std::string& getName() const { return _data->name; }
    /**
    
     */
    std::shared_ptr<test::DemoDynamic>& getDate() const { return _data->date; }
};
}


namespace test {


/**

 */
class TbDataFromJson
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>> _dataMap;
    std::vector<std::shared_ptr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoType2> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDataFromXml
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>> _dataMap;
    std::vector<std::shared_ptr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoType2> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDataFromLua
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>> _dataMap;
    std::vector<std::shared_ptr<test::DemoType2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoType2> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbMultiRowRecord
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::MultiRowRecord>> _dataMap;
    std::vector<std::shared_ptr<test::MultiRowRecord>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::MultiRowRecord> _v;
            if(!test::MultiRowRecord::deserializeMultiRowRecord(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::MultiRowRecord>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::MultiRowRecord>>& getDataList() const { return _dataList; }

    test::MultiRowRecord* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::MultiRowRecord> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbMultiRowTitle
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::MultiRowTitle>> _dataMap;
    std::vector<std::shared_ptr<test::MultiRowTitle>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::MultiRowTitle> _v;
            if(!test::MultiRowTitle::deserializeMultiRowTitle(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::MultiRowTitle>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::MultiRowTitle>>& getDataList() const { return _dataList; }

    test::MultiRowTitle* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::MultiRowTitle> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbTestNull
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::TestNull>> _dataMap;
    std::vector<std::shared_ptr<test::TestNull>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::TestNull> _v;
            if(!test::TestNull::deserializeTestNull(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::TestNull>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::TestNull>>& getDataList() const { return _dataList; }

    test::TestNull* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::TestNull> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDemoPrimitive
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoPrimitiveTypesTable>> _dataMap;
    std::vector<std::shared_ptr<test::DemoPrimitiveTypesTable>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoPrimitiveTypesTable> _v;
            if(!test::DemoPrimitiveTypesTable::deserializeDemoPrimitiveTypesTable(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoPrimitiveTypesTable>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoPrimitiveTypesTable>>& getDataList() const { return _dataList; }

    test::DemoPrimitiveTypesTable* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoPrimitiveTypesTable> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbTestString
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::TestString>> _dataMap;
    std::vector<std::shared_ptr<test::TestString>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::TestString> _v;
            if(!test::TestString::deserializeTestString(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::TestString>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::TestString>>& getDataList() const { return _dataList; }

    test::TestString* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::TestString> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDemoGroup
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>> _dataMap;
    std::vector<std::shared_ptr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoGroup> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDemoGroup_C
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>> _dataMap;
    std::vector<std::shared_ptr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoGroup> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDemoGroup_S
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>> _dataMap;
    std::vector<std::shared_ptr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoGroup> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDemoGroup_E
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>> _dataMap;
    std::vector<std::shared_ptr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoGroup> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbTestGlobal
{
     private:
    std::shared_ptr<test::TestGlobal> _data;

    public:
    std::shared_ptr<test::TestGlobal> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::TestGlobal::deserializeTestGlobal(_buf, _data)) return false;
        return true;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
    
     */
    int32_t& getUnlockEquip() const { return _data->unlockEquip; }
    /**
    
     */
    int32_t& getUnlockHero() const { return _data->unlockHero; }
};
}


namespace test {


/**

 */
class TbDetectCsvEncoding
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DetectEncoding>> _dataMap;
    std::vector<std::shared_ptr<test::DetectEncoding>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DetectEncoding> _v;
            if(!test::DetectEncoding::deserializeDetectEncoding(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DetectEncoding>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DetectEncoding>>& getDataList() const { return _dataList; }

    test::DetectEncoding* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DetectEncoding> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDefineFromExcel
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DefineFromExcel>> _dataMap;
    std::vector<std::shared_ptr<test::DefineFromExcel>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DefineFromExcel> _v;
            if(!test::DefineFromExcel::deserializeDefineFromExcel(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DefineFromExcel>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DefineFromExcel>>& getDataList() const { return _dataList; }

    test::DefineFromExcel* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DefineFromExcel> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDefineFromExcelOne
{
     private:
    std::shared_ptr<test::DefineFromExcelOne> _data;

    public:
    std::shared_ptr<test::DefineFromExcelOne> data() const { return _data; }

    bool load(ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::DefineFromExcelOne::deserializeDefineFromExcelOne(_buf, _data)) return false;
        return true;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        _data->resolve(_tables);
    }

    /**
    装备解锁等级_描述
     */
    int32_t& getUnlockEquip() const { return _data->unlockEquip; }
    /**
    英雄解锁等级
     */
    int32_t& getUnlockHero() const { return _data->unlockHero; }
    /**
    默认头像
     */
    std::string& getDefaultAvatar() const { return _data->defaultAvatar; }
    /**
    
     */
    std::string& getDefaultItem() const { return _data->defaultItem; }
};
}


namespace test {


/**

 */
class TbDemoGroupDefineFromExcel
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>> _dataMap;
    std::vector<std::shared_ptr<test::DemoGroup>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DemoGroup> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbDefineFromExcel2
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::DefineFromExcel2>> _dataMap;
    std::vector<std::shared_ptr<test::DefineFromExcel2>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::DefineFromExcel2> _v;
            if(!test::DefineFromExcel2::deserializeDefineFromExcel2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::DefineFromExcel2>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::DefineFromExcel2>>& getDataList() const { return _dataList; }

    test::DefineFromExcel2* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::DefineFromExcel2> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


namespace test {


/**

 */
class TbTestExcelBean
{
    private:
    std::unordered_map<int32_t, std::shared_ptr<test::TestExcelBean1>> _dataMap;
    std::vector<std::shared_ptr<test::TestExcelBean1>> _dataList;
    
    public:
    bool load(ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            std::shared_ptr<test::TestExcelBean1> _v;
            if(!test::TestExcelBean1::deserializeTestExcelBean1(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x1] = _v;
        }
        return true;
    }

    const std::unordered_map<int32_t, std::shared_ptr<test::TestExcelBean1>>& getDataMap() const { return _dataMap; }
    const std::vector<std::shared_ptr<test::TestExcelBean1>>& getDataList() const { return _dataList; }

    test::TestExcelBean1* getRaw(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    std::shared_ptr<test::TestExcelBean1> get(int32_t key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

    void resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto v : _dataList)
        {
            v->resolve(_tables);
        }
    }

};
}


class Tables
{
    public:
    /**
     
     */
     ai::TbBlackboard TbBlackboard;
    /**
     
     */
     ai::TbBehaviorTree TbBehaviorTree;
    /**
     
     */
     blueprint::TbClazz TbClazz;
    /**
     
     */
     bonus::TbDrop TbDrop;
    /**
     
     */
     common::TbGlobalConfig TbGlobalConfig;
    /**
     
     */
     common::TbDummy TbDummy;
    /**
     
     */
     error::TbErrorInfo TbErrorInfo;
    /**
     
     */
     error::TbCodeInfo TbCodeInfo;
    /**
     道具表
     */
     item::TbItem TbItem;
    /**
     
     */
     item::TbItemFunc TbItemFunc;
    /**
     
     */
     item::TbItemExtra TbItemExtra;
    /**
     
     */
     l10n::TbL10NDemo TbL10NDemo;
    /**
     
     */
     l10n::TbPatchDemo TbPatchDemo;
    /**
     
     */
     mail::TbSystemMail TbSystemMail;
    /**
     
     */
     mail::TbGlobalMail TbGlobalMail;
    /**
     
     */
     role::TbRoleLevelExpAttr TbRoleLevelExpAttr;
    /**
     
     */
     role::TbRoleLevelBonusCoefficient TbRoleLevelBonusCoefficient;
    /**
     
     */
     tag::TbTestTag TbTestTag;
    /**
     
     */
     test::TbFullTypes TbFullTypes;
    /**
     
     */
     test::TbSingleton TbSingleton;
    /**
     
     */
     test::TbDataFromJson TbDataFromJson;
    /**
     
     */
     test::TbDataFromXml TbDataFromXml;
    /**
     
     */
     test::TbDataFromLua TbDataFromLua;
    /**
     
     */
     test::TbMultiRowRecord TbMultiRowRecord;
    /**
     
     */
     test::TbMultiRowTitle TbMultiRowTitle;
    /**
     
     */
     test::TbTestNull TbTestNull;
    /**
     
     */
     test::TbDemoPrimitive TbDemoPrimitive;
    /**
     
     */
     test::TbTestString TbTestString;
    /**
     
     */
     test::TbDemoGroup TbDemoGroup;
    /**
     
     */
     test::TbDemoGroup_C TbDemoGroup_C;
    /**
     
     */
     test::TbDemoGroup_S TbDemoGroup_S;
    /**
     
     */
     test::TbDemoGroup_E TbDemoGroup_E;
    /**
     
     */
     test::TbTestGlobal TbTestGlobal;
    /**
     
     */
     test::TbDetectCsvEncoding TbDetectCsvEncoding;
    /**
     
     */
     test::TbDefineFromExcel TbDefineFromExcel;
    /**
     
     */
     test::TbDefineFromExcelOne TbDefineFromExcelOne;
    /**
     
     */
     test::TbDemoGroupDefineFromExcel TbDemoGroupDefineFromExcel;
    /**
     
     */
     test::TbDefineFromExcel2 TbDefineFromExcel2;
    /**
     
     */
     test::TbTestExcelBean TbTestExcelBean;

    bool load(std::function<bool(ByteBuf&, const std::string&)> loader)
    {
        std::unordered_map<std::string, void*> __tables__;

        ByteBuf buf;
        if (!loader(buf, "ai.TbBlackboard")) return false;
        if (!TbBlackboard.load(buf)) return false;
        __tables__["ai.TbBlackboard"] = &TbBlackboard;
        if (!loader(buf, "ai.TbBehaviorTree")) return false;
        if (!TbBehaviorTree.load(buf)) return false;
        __tables__["ai.TbBehaviorTree"] = &TbBehaviorTree;
        if (!loader(buf, "blueprint.TbClazz")) return false;
        if (!TbClazz.load(buf)) return false;
        __tables__["blueprint.TbClazz"] = &TbClazz;
        if (!loader(buf, "bonus.TbDrop")) return false;
        if (!TbDrop.load(buf)) return false;
        __tables__["bonus.TbDrop"] = &TbDrop;
        if (!loader(buf, "common.TbGlobalConfig")) return false;
        if (!TbGlobalConfig.load(buf)) return false;
        __tables__["common.TbGlobalConfig"] = &TbGlobalConfig;
        if (!loader(buf, "common.TbDummy")) return false;
        if (!TbDummy.load(buf)) return false;
        __tables__["common.TbDummy"] = &TbDummy;
        if (!loader(buf, "error.TbErrorInfo")) return false;
        if (!TbErrorInfo.load(buf)) return false;
        __tables__["error.TbErrorInfo"] = &TbErrorInfo;
        if (!loader(buf, "error.TbCodeInfo")) return false;
        if (!TbCodeInfo.load(buf)) return false;
        __tables__["error.TbCodeInfo"] = &TbCodeInfo;
        if (!loader(buf, "item.TbItem")) return false;
        if (!TbItem.load(buf)) return false;
        __tables__["item.TbItem"] = &TbItem;
        if (!loader(buf, "item.TbItemFunc")) return false;
        if (!TbItemFunc.load(buf)) return false;
        __tables__["item.TbItemFunc"] = &TbItemFunc;
        if (!loader(buf, "item.TbItemExtra")) return false;
        if (!TbItemExtra.load(buf)) return false;
        __tables__["item.TbItemExtra"] = &TbItemExtra;
        if (!loader(buf, "l10n.TbL10NDemo")) return false;
        if (!TbL10NDemo.load(buf)) return false;
        __tables__["l10n.TbL10NDemo"] = &TbL10NDemo;
        if (!loader(buf, "l10n.TbPatchDemo")) return false;
        if (!TbPatchDemo.load(buf)) return false;
        __tables__["l10n.TbPatchDemo"] = &TbPatchDemo;
        if (!loader(buf, "mail.TbSystemMail")) return false;
        if (!TbSystemMail.load(buf)) return false;
        __tables__["mail.TbSystemMail"] = &TbSystemMail;
        if (!loader(buf, "mail.TbGlobalMail")) return false;
        if (!TbGlobalMail.load(buf)) return false;
        __tables__["mail.TbGlobalMail"] = &TbGlobalMail;
        if (!loader(buf, "role.TbRoleLevelExpAttr")) return false;
        if (!TbRoleLevelExpAttr.load(buf)) return false;
        __tables__["role.TbRoleLevelExpAttr"] = &TbRoleLevelExpAttr;
        if (!loader(buf, "role.TbRoleLevelBonusCoefficient")) return false;
        if (!TbRoleLevelBonusCoefficient.load(buf)) return false;
        __tables__["role.TbRoleLevelBonusCoefficient"] = &TbRoleLevelBonusCoefficient;
        if (!loader(buf, "tag.TbTestTag")) return false;
        if (!TbTestTag.load(buf)) return false;
        __tables__["tag.TbTestTag"] = &TbTestTag;
        if (!loader(buf, "test.TbFullTypes")) return false;
        if (!TbFullTypes.load(buf)) return false;
        __tables__["test.TbFullTypes"] = &TbFullTypes;
        if (!loader(buf, "test.TbSingleton")) return false;
        if (!TbSingleton.load(buf)) return false;
        __tables__["test.TbSingleton"] = &TbSingleton;
        if (!loader(buf, "test.TbDataFromJson")) return false;
        if (!TbDataFromJson.load(buf)) return false;
        __tables__["test.TbDataFromJson"] = &TbDataFromJson;
        if (!loader(buf, "test.TbDataFromXml")) return false;
        if (!TbDataFromXml.load(buf)) return false;
        __tables__["test.TbDataFromXml"] = &TbDataFromXml;
        if (!loader(buf, "test.TbDataFromLua")) return false;
        if (!TbDataFromLua.load(buf)) return false;
        __tables__["test.TbDataFromLua"] = &TbDataFromLua;
        if (!loader(buf, "test.TbMultiRowRecord")) return false;
        if (!TbMultiRowRecord.load(buf)) return false;
        __tables__["test.TbMultiRowRecord"] = &TbMultiRowRecord;
        if (!loader(buf, "test.TbMultiRowTitle")) return false;
        if (!TbMultiRowTitle.load(buf)) return false;
        __tables__["test.TbMultiRowTitle"] = &TbMultiRowTitle;
        if (!loader(buf, "test.TbTestNull")) return false;
        if (!TbTestNull.load(buf)) return false;
        __tables__["test.TbTestNull"] = &TbTestNull;
        if (!loader(buf, "test.TbDemoPrimitive")) return false;
        if (!TbDemoPrimitive.load(buf)) return false;
        __tables__["test.TbDemoPrimitive"] = &TbDemoPrimitive;
        if (!loader(buf, "test.TbTestString")) return false;
        if (!TbTestString.load(buf)) return false;
        __tables__["test.TbTestString"] = &TbTestString;
        if (!loader(buf, "test.TbDemoGroup")) return false;
        if (!TbDemoGroup.load(buf)) return false;
        __tables__["test.TbDemoGroup"] = &TbDemoGroup;
        if (!loader(buf, "test.TbDemoGroup_C")) return false;
        if (!TbDemoGroup_C.load(buf)) return false;
        __tables__["test.TbDemoGroup_C"] = &TbDemoGroup_C;
        if (!loader(buf, "test.TbDemoGroup_S")) return false;
        if (!TbDemoGroup_S.load(buf)) return false;
        __tables__["test.TbDemoGroup_S"] = &TbDemoGroup_S;
        if (!loader(buf, "test.TbDemoGroup_E")) return false;
        if (!TbDemoGroup_E.load(buf)) return false;
        __tables__["test.TbDemoGroup_E"] = &TbDemoGroup_E;
        if (!loader(buf, "test.TbTestGlobal")) return false;
        if (!TbTestGlobal.load(buf)) return false;
        __tables__["test.TbTestGlobal"] = &TbTestGlobal;
        if (!loader(buf, "test.TbDetectCsvEncoding")) return false;
        if (!TbDetectCsvEncoding.load(buf)) return false;
        __tables__["test.TbDetectCsvEncoding"] = &TbDetectCsvEncoding;
        if (!loader(buf, "test.TbDefineFromExcel")) return false;
        if (!TbDefineFromExcel.load(buf)) return false;
        __tables__["test.TbDefineFromExcel"] = &TbDefineFromExcel;
        if (!loader(buf, "test.TbDefineFromExcelOne")) return false;
        if (!TbDefineFromExcelOne.load(buf)) return false;
        __tables__["test.TbDefineFromExcelOne"] = &TbDefineFromExcelOne;
        if (!loader(buf, "test.TbDemoGroupDefineFromExcel")) return false;
        if (!TbDemoGroupDefineFromExcel.load(buf)) return false;
        __tables__["test.TbDemoGroupDefineFromExcel"] = &TbDemoGroupDefineFromExcel;
        if (!loader(buf, "test.TbDefineFromExcel2")) return false;
        if (!TbDefineFromExcel2.load(buf)) return false;
        __tables__["test.TbDefineFromExcel2"] = &TbDefineFromExcel2;
        if (!loader(buf, "test.TbTestExcelBean")) return false;
        if (!TbTestExcelBean.load(buf)) return false;
        __tables__["test.TbTestExcelBean"] = &TbTestExcelBean;

        TbBlackboard.resolve(__tables__); 
        TbBehaviorTree.resolve(__tables__); 
        TbClazz.resolve(__tables__); 
        TbDrop.resolve(__tables__); 
        TbGlobalConfig.resolve(__tables__); 
        TbDummy.resolve(__tables__); 
        TbErrorInfo.resolve(__tables__); 
        TbCodeInfo.resolve(__tables__); 
        TbItem.resolve(__tables__); 
        TbItemFunc.resolve(__tables__); 
        TbItemExtra.resolve(__tables__); 
        TbL10NDemo.resolve(__tables__); 
        TbPatchDemo.resolve(__tables__); 
        TbSystemMail.resolve(__tables__); 
        TbGlobalMail.resolve(__tables__); 
        TbRoleLevelExpAttr.resolve(__tables__); 
        TbRoleLevelBonusCoefficient.resolve(__tables__); 
        TbTestTag.resolve(__tables__); 
        TbFullTypes.resolve(__tables__); 
        TbSingleton.resolve(__tables__); 
        TbDataFromJson.resolve(__tables__); 
        TbDataFromXml.resolve(__tables__); 
        TbDataFromLua.resolve(__tables__); 
        TbMultiRowRecord.resolve(__tables__); 
        TbMultiRowTitle.resolve(__tables__); 
        TbTestNull.resolve(__tables__); 
        TbDemoPrimitive.resolve(__tables__); 
        TbTestString.resolve(__tables__); 
        TbDemoGroup.resolve(__tables__); 
        TbDemoGroup_C.resolve(__tables__); 
        TbDemoGroup_S.resolve(__tables__); 
        TbDemoGroup_E.resolve(__tables__); 
        TbTestGlobal.resolve(__tables__); 
        TbDetectCsvEncoding.resolve(__tables__); 
        TbDefineFromExcel.resolve(__tables__); 
        TbDefineFromExcelOne.resolve(__tables__); 
        TbDemoGroupDefineFromExcel.resolve(__tables__); 
        TbDefineFromExcel2.resolve(__tables__); 
        TbTestExcelBean.resolve(__tables__); 
        return true;
    }
};



}