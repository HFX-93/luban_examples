
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include <algorithm>
#include "gen_types.h"

using ByteBuf = bright::serialization::ByteBuf;

namespace cfg
{

    bool ai::Blackboard::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readString(parentName)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); keys.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<ai::BlackboardKey> _e;  if(!ai::BlackboardKey::deserializeBlackboardKey(_buf, _e)) return false; keys.push_back(_e);}}

        return true;
    }

    bool ai::Blackboard::deserializeBlackboard(ByteBuf& _buf, std::shared_ptr<ai::Blackboard>& _out)
    {
        _out.reset(new ai::Blackboard());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Blackboard::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->parentName_Ref = ((ai::TbBlackboard*)(_tables["ai.TbBlackboard"]))->get(parentName);
        for(auto _e : keys) { _e->resolve(_tables); }
    }

    bool ai::BlackboardKey::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; type = ai::EKeyType(__enum_temp__); }
        if(!_buf.readString(typeClassName)) return false;

        return true;
    }

    bool ai::BlackboardKey::deserializeBlackboardKey(ByteBuf& _buf, std::shared_ptr<ai::BlackboardKey>& _out)
    {
        _out.reset(new ai::BlackboardKey());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BlackboardKey::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool ai::BehaviorTree::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readString(blackboardId)) return false;
        if(!ai::ComposeNode::deserializeComposeNode(_buf, root)) return false;

        return true;
    }

    bool ai::BehaviorTree::deserializeBehaviorTree(ByteBuf& _buf, std::shared_ptr<ai::BehaviorTree>& _out)
    {
        _out.reset(new ai::BehaviorTree());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BehaviorTree::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->blackboardId_Ref = ((ai::TbBlackboard*)(_tables["ai.TbBlackboard"]))->get(blackboardId);
        root->resolve(_tables);
    }

    bool ai::Node::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(nodeName)) return false;

        return true;
    }

    bool ai::Node::deserializeNode(ByteBuf& _buf, std::shared_ptr<ai::Node>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::ID: { _out.reset(new ai::UeSetDefaultFocus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ExecuteTimeStatistic::ID: { _out.reset(new ai::ExecuteTimeStatistic()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseTarget::ID: { _out.reset(new ai::ChooseTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::KeepFaceTarget::ID: { _out.reset(new ai::KeepFaceTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::GetOwnerPlayer::ID: { _out.reset(new ai::GetOwnerPlayer()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UpdateDailyBehaviorProps::ID: { _out.reset(new ai::UpdateDailyBehaviorProps()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeLoop::ID: { _out.reset(new ai::UeLoop()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeCooldown::ID: { _out.reset(new ai::UeCooldown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeTimeLimit::ID: { _out.reset(new ai::UeTimeLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeBlackboard::ID: { _out.reset(new ai::UeBlackboard()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeForceSuccess::ID: { _out.reset(new ai::UeForceSuccess()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsAtLocation::ID: { _out.reset(new ai::IsAtLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DistanceLessThan::ID: { _out.reset(new ai::DistanceLessThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Sequence::ID: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::ID: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::ID: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWait::ID: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::ID: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::ID: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::ID: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::ID: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::ID: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Node::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool ai::Service::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::Service::deserializeService(ByteBuf& _buf, std::shared_ptr<ai::Service>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeSetDefaultFocus::ID: { _out.reset(new ai::UeSetDefaultFocus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ExecuteTimeStatistic::ID: { _out.reset(new ai::ExecuteTimeStatistic()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseTarget::ID: { _out.reset(new ai::ChooseTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::KeepFaceTarget::ID: { _out.reset(new ai::KeepFaceTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::GetOwnerPlayer::ID: { _out.reset(new ai::GetOwnerPlayer()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UpdateDailyBehaviorProps::ID: { _out.reset(new ai::UpdateDailyBehaviorProps()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Service::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Node::resolve(_tables);
    }

    bool ai::UeSetDefaultFocus::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(keyboardKey)) return false;

        return true;
    }

    bool ai::UeSetDefaultFocus::deserializeUeSetDefaultFocus(ByteBuf& _buf, std::shared_ptr<ai::UeSetDefaultFocus>& _out)
    {
        _out.reset(new ai::UeSetDefaultFocus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeSetDefaultFocus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::ExecuteTimeStatistic::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ExecuteTimeStatistic::deserializeExecuteTimeStatistic(ByteBuf& _buf, std::shared_ptr<ai::ExecuteTimeStatistic>& _out)
    {
        _out.reset(new ai::ExecuteTimeStatistic());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ExecuteTimeStatistic::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::ChooseTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(resultTargetKey)) return false;

        return true;
    }

    bool ai::ChooseTarget::deserializeChooseTarget(ByteBuf& _buf, std::shared_ptr<ai::ChooseTarget>& _out)
    {
        _out.reset(new ai::ChooseTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ChooseTarget::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::KeepFaceTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;

        return true;
    }

    bool ai::KeepFaceTarget::deserializeKeepFaceTarget(ByteBuf& _buf, std::shared_ptr<ai::KeepFaceTarget>& _out)
    {
        _out.reset(new ai::KeepFaceTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::KeepFaceTarget::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::GetOwnerPlayer::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(playerActorKey)) return false;

        return true;
    }

    bool ai::GetOwnerPlayer::deserializeGetOwnerPlayer(ByteBuf& _buf, std::shared_ptr<ai::GetOwnerPlayer>& _out)
    {
        _out.reset(new ai::GetOwnerPlayer());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::GetOwnerPlayer::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::UpdateDailyBehaviorProps::deserialize(ByteBuf& _buf)
    {
        if (!ai::Service::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(satietyKey)) return false;
        if(!_buf.readString(energyKey)) return false;
        if(!_buf.readString(moodKey)) return false;
        if(!_buf.readString(satietyLowerThresholdKey)) return false;
        if(!_buf.readString(satietyUpperThresholdKey)) return false;
        if(!_buf.readString(energyLowerThresholdKey)) return false;
        if(!_buf.readString(energyUpperThresholdKey)) return false;
        if(!_buf.readString(moodLowerThresholdKey)) return false;
        if(!_buf.readString(moodUpperThresholdKey)) return false;

        return true;
    }

    bool ai::UpdateDailyBehaviorProps::deserializeUpdateDailyBehaviorProps(ByteBuf& _buf, std::shared_ptr<ai::UpdateDailyBehaviorProps>& _out)
    {
        _out.reset(new ai::UpdateDailyBehaviorProps());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UpdateDailyBehaviorProps::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Service::resolve(_tables);
    }

    bool ai::Decorator::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; flowAbortMode = ai::EFlowAbortMode(__enum_temp__); }

        return true;
    }

    bool ai::Decorator::deserializeDecorator(ByteBuf& _buf, std::shared_ptr<ai::Decorator>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeLoop::ID: { _out.reset(new ai::UeLoop()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeCooldown::ID: { _out.reset(new ai::UeCooldown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeTimeLimit::ID: { _out.reset(new ai::UeTimeLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeBlackboard::ID: { _out.reset(new ai::UeBlackboard()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeForceSuccess::ID: { _out.reset(new ai::UeForceSuccess()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsAtLocation::ID: { _out.reset(new ai::IsAtLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DistanceLessThan::ID: { _out.reset(new ai::DistanceLessThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Decorator::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Node::resolve(_tables);
    }

    bool ai::UeLoop::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(numLoops)) return false;
        if (!_buf.readBool(infiniteLoop)) return false;
        if(!_buf.readFloat(infiniteLoopTimeoutTime)) return false;

        return true;
    }

    bool ai::UeLoop::deserializeUeLoop(ByteBuf& _buf, std::shared_ptr<ai::UeLoop>& _out)
    {
        _out.reset(new ai::UeLoop());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeLoop::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeCooldown::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(cooldownTime)) return false;

        return true;
    }

    bool ai::UeCooldown::deserializeUeCooldown(ByteBuf& _buf, std::shared_ptr<ai::UeCooldown>& _out)
    {
        _out.reset(new ai::UeCooldown());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeCooldown::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeTimeLimit::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(limitTime)) return false;

        return true;
    }

    bool ai::UeTimeLimit::deserializeUeTimeLimit(ByteBuf& _buf, std::shared_ptr<ai::UeTimeLimit>& _out)
    {
        _out.reset(new ai::UeTimeLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeTimeLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::UeBlackboard::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; notifyObserver = ai::ENotifyObserverMode(__enum_temp__); }
        if(!_buf.readString(blackboardKey)) return false;
        if(!ai::KeyQueryOperator::deserializeKeyQueryOperator(_buf, keyQuery)) return false;

        return true;
    }

    bool ai::UeBlackboard::deserializeUeBlackboard(ByteBuf& _buf, std::shared_ptr<ai::UeBlackboard>& _out)
    {
        _out.reset(new ai::UeBlackboard());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeBlackboard::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
        keyQuery->resolve(_tables);
    }

    bool ai::KeyQueryOperator::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyQueryOperator::deserializeKeyQueryOperator(ByteBuf& _buf, std::shared_ptr<ai::KeyQueryOperator>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::IsSet::ID: { _out.reset(new ai::IsSet()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IsNotSet::ID: { _out.reset(new ai::IsNotSet()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::BinaryOperator::ID: { _out.reset(new ai::BinaryOperator()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::KeyQueryOperator::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool ai::IsSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsSet::deserializeIsSet(ByteBuf& _buf, std::shared_ptr<ai::IsSet>& _out)
    {
        _out.reset(new ai::IsSet());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsSet::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
    }

    bool ai::IsNotSet::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::IsNotSet::deserializeIsNotSet(ByteBuf& _buf, std::shared_ptr<ai::IsNotSet>& _out)
    {
        _out.reset(new ai::IsNotSet());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsNotSet::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
    }

    bool ai::BinaryOperator::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyQueryOperator::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; oper = ai::EOperator(__enum_temp__); }
        if(!ai::KeyData::deserializeKeyData(_buf, data)) return false;

        return true;
    }

    bool ai::BinaryOperator::deserializeBinaryOperator(ByteBuf& _buf, std::shared_ptr<ai::BinaryOperator>& _out)
    {
        _out.reset(new ai::BinaryOperator());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BinaryOperator::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyQueryOperator::resolve(_tables);
        data->resolve(_tables);
    }

    bool ai::KeyData::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool ai::KeyData::deserializeKeyData(ByteBuf& _buf, std::shared_ptr<ai::KeyData>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::FloatKeyData::ID: { _out.reset(new ai::FloatKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::IntKeyData::ID: { _out.reset(new ai::IntKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::StringKeyData::ID: { _out.reset(new ai::StringKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::BlackboardKeyData::ID: { _out.reset(new ai::BlackboardKeyData()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::KeyData::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool ai::FloatKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(value)) return false;

        return true;
    }

    bool ai::FloatKeyData::deserializeFloatKeyData(ByteBuf& _buf, std::shared_ptr<ai::FloatKeyData>& _out)
    {
        _out.reset(new ai::FloatKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::FloatKeyData::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::IntKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool ai::IntKeyData::deserializeIntKeyData(ByteBuf& _buf, std::shared_ptr<ai::IntKeyData>& _out)
    {
        _out.reset(new ai::IntKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IntKeyData::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::StringKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(value)) return false;

        return true;
    }

    bool ai::StringKeyData::deserializeStringKeyData(ByteBuf& _buf, std::shared_ptr<ai::StringKeyData>& _out)
    {
        _out.reset(new ai::StringKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::StringKeyData::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::BlackboardKeyData::deserialize(ByteBuf& _buf)
    {
        if (!ai::KeyData::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(value)) return false;

        return true;
    }

    bool ai::BlackboardKeyData::deserializeBlackboardKeyData(ByteBuf& _buf, std::shared_ptr<ai::BlackboardKeyData>& _out)
    {
        _out.reset(new ai::BlackboardKeyData());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::BlackboardKeyData::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        KeyData::resolve(_tables);
    }

    bool ai::UeForceSuccess::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::UeForceSuccess::deserializeUeForceSuccess(ByteBuf& _buf, std::shared_ptr<ai::UeForceSuccess>& _out)
    {
        _out.reset(new ai::UeForceSuccess());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeForceSuccess::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::IsAtLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(acceptableRadius)) return false;
        if(!_buf.readString(keyboardKey)) return false;
        if (!_buf.readBool(inverseCondition)) return false;

        return true;
    }

    bool ai::IsAtLocation::deserializeIsAtLocation(ByteBuf& _buf, std::shared_ptr<ai::IsAtLocation>& _out)
    {
        _out.reset(new ai::IsAtLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::IsAtLocation::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::DistanceLessThan::deserialize(ByteBuf& _buf)
    {
        if (!ai::Decorator::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(actor1Key)) return false;
        if(!_buf.readString(actor2Key)) return false;
        if(!_buf.readFloat(distance)) return false;
        if (!_buf.readBool(reverseResult)) return false;

        return true;
    }

    bool ai::DistanceLessThan::deserializeDistanceLessThan(ByteBuf& _buf, std::shared_ptr<ai::DistanceLessThan>& _out)
    {
        _out.reset(new ai::DistanceLessThan());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::DistanceLessThan::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Decorator::resolve(_tables);
    }

    bool ai::FlowNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::Node::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); decorators.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<ai::Decorator> _e;  if(!ai::Decorator::deserializeDecorator(_buf, _e)) return false; decorators.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); services.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<ai::Service> _e;  if(!ai::Service::deserializeService(_buf, _e)) return false; services.push_back(_e);}}

        return true;
    }

    bool ai::FlowNode::deserializeFlowNode(ByteBuf& _buf, std::shared_ptr<ai::FlowNode>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::ID: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::ID: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::ID: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWait::ID: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::ID: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::ID: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::ID: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::ID: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::ID: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::FlowNode::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Node::resolve(_tables);
        for(auto _e : decorators) { _e->resolve(_tables); }
        for(auto _e : services) { _e->resolve(_tables); }
    }

    bool ai::ComposeNode::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool ai::ComposeNode::deserializeComposeNode(ByteBuf& _buf, std::shared_ptr<ai::ComposeNode>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::Sequence::ID: { _out.reset(new ai::Sequence()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::Selector::ID: { _out.reset(new ai::Selector()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::SimpleParallel::ID: { _out.reset(new ai::SimpleParallel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::ComposeNode::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        FlowNode::resolve(_tables);
    }

    bool ai::Sequence::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); children.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<ai::FlowNode> _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Sequence::deserializeSequence(ByteBuf& _buf, std::shared_ptr<ai::Sequence>& _out)
    {
        _out.reset(new ai::Sequence());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Sequence::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        for(auto _e : children) { _e->resolve(_tables); }
    }

    bool ai::Selector::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); children.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<ai::FlowNode> _e;  if(!ai::FlowNode::deserializeFlowNode(_buf, _e)) return false; children.push_back(_e);}}

        return true;
    }

    bool ai::Selector::deserializeSelector(ByteBuf& _buf, std::shared_ptr<ai::Selector>& _out)
    {
        _out.reset(new ai::Selector());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::Selector::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        for(auto _e : children) { _e->resolve(_tables); }
    }

    bool ai::SimpleParallel::deserialize(ByteBuf& _buf)
    {
        if (!ai::ComposeNode::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; finishMode = ai::EFinishMode(__enum_temp__); }
        if(!ai::Task::deserializeTask(_buf, mainTask)) return false;
        if(!ai::FlowNode::deserializeFlowNode(_buf, backgroundNode)) return false;

        return true;
    }

    bool ai::SimpleParallel::deserializeSimpleParallel(ByteBuf& _buf, std::shared_ptr<ai::SimpleParallel>& _out)
    {
        _out.reset(new ai::SimpleParallel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::SimpleParallel::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ComposeNode::resolve(_tables);
        mainTask->resolve(_tables);
        backgroundNode->resolve(_tables);
    }

    bool ai::Task::deserialize(ByteBuf& _buf)
    {
        if (!ai::FlowNode::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(ignoreRestartSelf)) return false;

        return true;
    }

    bool ai::Task::deserializeTask(ByteBuf& _buf, std::shared_ptr<ai::Task>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case ai::UeWait::ID: { _out.reset(new ai::UeWait()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::UeWaitBlackboardTime::ID: { _out.reset(new ai::UeWaitBlackboardTime()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToTarget::ID: { _out.reset(new ai::MoveToTarget()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::ChooseSkill::ID: { _out.reset(new ai::ChooseSkill()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToRandomLocation::ID: { _out.reset(new ai::MoveToRandomLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::MoveToLocation::ID: { _out.reset(new ai::MoveToLocation()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case ai::DebugPrint::ID: { _out.reset(new ai::DebugPrint()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void ai::Task::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        FlowNode::resolve(_tables);
    }

    bool ai::UeWait::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readFloat(waitTime)) return false;
        if(!_buf.readFloat(randomDeviation)) return false;

        return true;
    }

    bool ai::UeWait::deserializeUeWait(ByteBuf& _buf, std::shared_ptr<ai::UeWait>& _out)
    {
        _out.reset(new ai::UeWait());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeWait::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::UeWaitBlackboardTime::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(blackboardKey)) return false;

        return true;
    }

    bool ai::UeWaitBlackboardTime::deserializeUeWaitBlackboardTime(ByteBuf& _buf, std::shared_ptr<ai::UeWaitBlackboardTime>& _out)
    {
        _out.reset(new ai::UeWaitBlackboardTime());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::UeWaitBlackboardTime::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToTarget::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToTarget::deserializeMoveToTarget(ByteBuf& _buf, std::shared_ptr<ai::MoveToTarget>& _out)
    {
        _out.reset(new ai::MoveToTarget());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToTarget::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::ChooseSkill::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(targetActorKey)) return false;
        if(!_buf.readString(resultSkillIdKey)) return false;

        return true;
    }

    bool ai::ChooseSkill::deserializeChooseSkill(ByteBuf& _buf, std::shared_ptr<ai::ChooseSkill>& _out)
    {
        _out.reset(new ai::ChooseSkill());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::ChooseSkill::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToRandomLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(originPositionKey)) return false;
        if(!_buf.readFloat(radius)) return false;

        return true;
    }

    bool ai::MoveToRandomLocation::deserializeMoveToRandomLocation(ByteBuf& _buf, std::shared_ptr<ai::MoveToRandomLocation>& _out)
    {
        _out.reset(new ai::MoveToRandomLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToRandomLocation::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::MoveToLocation::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readVector3(location)) return false;
        if(!_buf.readFloat(acceptableRadius)) return false;

        return true;
    }

    bool ai::MoveToLocation::deserializeMoveToLocation(ByteBuf& _buf, std::shared_ptr<ai::MoveToLocation>& _out)
    {
        _out.reset(new ai::MoveToLocation());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::MoveToLocation::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool ai::DebugPrint::deserialize(ByteBuf& _buf)
    {
        if (!ai::Task::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(text)) return false;

        return true;
    }

    bool ai::DebugPrint::deserializeDebugPrint(ByteBuf& _buf, std::shared_ptr<ai::DebugPrint>& _out)
    {
        _out.reset(new ai::DebugPrint());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void ai::DebugPrint::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Task::resolve(_tables);
    }

    bool blueprint::Clazz::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); parents.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<blueprint::Clazz> _e;  if(!blueprint::Clazz::deserializeClazz(_buf, _e)) return false; parents.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); methods.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<blueprint::Method> _e;  if(!blueprint::Method::deserializeMethod(_buf, _e)) return false; methods.push_back(_e);}}

        return true;
    }

    bool blueprint::Clazz::deserializeClazz(ByteBuf& _buf, std::shared_ptr<blueprint::Clazz>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::Interface::ID: { _out.reset(new blueprint::Interface()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::NormalClazz::ID: { _out.reset(new blueprint::NormalClazz()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::EnumClazz::ID: { _out.reset(new blueprint::EnumClazz()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void blueprint::Clazz::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto _e : parents) { _e->resolve(_tables); }
        for(auto _e : methods) { _e->resolve(_tables); }
    }

    bool blueprint::Method::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(desc)) return false;
        if (!_buf.readBool(isStatic)) return false;
        if(!_buf.readString(returnType)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); parameters.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<blueprint::ParamInfo> _e;  if(!blueprint::ParamInfo::deserializeParamInfo(_buf, _e)) return false; parameters.push_back(_e);}}

        return true;
    }

    bool blueprint::Method::deserializeMethod(ByteBuf& _buf, std::shared_ptr<blueprint::Method>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case blueprint::AbstraceMethod::ID: { _out.reset(new blueprint::AbstraceMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::ExternalMethod::ID: { _out.reset(new blueprint::ExternalMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case blueprint::BlueprintMethod::ID: { _out.reset(new blueprint::BlueprintMethod()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void blueprint::Method::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto _e : parameters) { _e->resolve(_tables); }
    }

    bool blueprint::ParamInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(type)) return false;
        if (!_buf.readBool(isRef)) return false;

        return true;
    }

    bool blueprint::ParamInfo::deserializeParamInfo(ByteBuf& _buf, std::shared_ptr<blueprint::ParamInfo>& _out)
    {
        _out.reset(new blueprint::ParamInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::ParamInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool blueprint::AbstraceMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::AbstraceMethod::deserializeAbstraceMethod(ByteBuf& _buf, std::shared_ptr<blueprint::AbstraceMethod>& _out)
    {
        _out.reset(new blueprint::AbstraceMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::AbstraceMethod::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::ExternalMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::ExternalMethod::deserializeExternalMethod(ByteBuf& _buf, std::shared_ptr<blueprint::ExternalMethod>& _out)
    {
        _out.reset(new blueprint::ExternalMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::ExternalMethod::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::BlueprintMethod::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Method::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::BlueprintMethod::deserializeBlueprintMethod(ByteBuf& _buf, std::shared_ptr<blueprint::BlueprintMethod>& _out)
    {
        _out.reset(new blueprint::BlueprintMethod());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::BlueprintMethod::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Method::resolve(_tables);
    }

    bool blueprint::Interface::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool blueprint::Interface::deserializeInterface(ByteBuf& _buf, std::shared_ptr<blueprint::Interface>& _out)
    {
        _out.reset(new blueprint::Interface());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::Interface::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Clazz::resolve(_tables);
    }

    bool blueprint::NormalClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        if (!_buf.readBool(isAbstract)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); fields.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<blueprint::Field> _e;  if(!blueprint::Field::deserializeField(_buf, _e)) return false; fields.push_back(_e);}}

        return true;
    }

    bool blueprint::NormalClazz::deserializeNormalClazz(ByteBuf& _buf, std::shared_ptr<blueprint::NormalClazz>& _out)
    {
        _out.reset(new blueprint::NormalClazz());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::NormalClazz::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Clazz::resolve(_tables);
        for(auto _e : fields) { _e->resolve(_tables); }
    }

    bool blueprint::Field::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readString(type)) return false;
        if(!_buf.readString(desc)) return false;

        return true;
    }

    bool blueprint::Field::deserializeField(ByteBuf& _buf, std::shared_ptr<blueprint::Field>& _out)
    {
        _out.reset(new blueprint::Field());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::Field::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool blueprint::EnumClazz::deserialize(ByteBuf& _buf)
    {
        if (!blueprint::Clazz::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); enums.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<blueprint::EnumField> _e;  if(!blueprint::EnumField::deserializeEnumField(_buf, _e)) return false; enums.push_back(_e);}}

        return true;
    }

    bool blueprint::EnumClazz::deserializeEnumClazz(ByteBuf& _buf, std::shared_ptr<blueprint::EnumClazz>& _out)
    {
        _out.reset(new blueprint::EnumClazz());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::EnumClazz::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Clazz::resolve(_tables);
        for(auto _e : enums) { _e->resolve(_tables); }
    }

    bool blueprint::EnumField::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(name)) return false;
        if(!_buf.readInt(value)) return false;

        return true;
    }

    bool blueprint::EnumField::deserializeEnumField(ByteBuf& _buf, std::shared_ptr<blueprint::EnumField>& _out)
    {
        _out.reset(new blueprint::EnumField());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void blueprint::EnumField::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool bonus::DropInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(desc)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); clientShowItems.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::ShowItemInfo> _e;  if(!bonus::ShowItemInfo::deserializeShowItemInfo(_buf, _e)) return false; clientShowItems.push_back(_e);}}
        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;

        return true;
    }

    bool bonus::DropInfo::deserializeDropInfo(ByteBuf& _buf, std::shared_ptr<bonus::DropInfo>& _out)
    {
        _out.reset(new bonus::DropInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::DropInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        for(auto _e : clientShowItems) { _e->resolve(_tables); }
        bonus->resolve(_tables);
    }

    bool bonus::ShowItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readLong(itemNum)) return false;

        return true;
    }

    bool bonus::ShowItemInfo::deserializeShowItemInfo(ByteBuf& _buf, std::shared_ptr<bonus::ShowItemInfo>& _out)
    {
        _out.reset(new bonus::ShowItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ShowItemInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::Bonus::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool bonus::Bonus::deserializeBonus(ByteBuf& _buf, std::shared_ptr<bonus::Bonus>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case bonus::OneItem::ID: { _out.reset(new bonus::OneItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::OneItems::ID: { _out.reset(new bonus::OneItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::Item::ID: { _out.reset(new bonus::Item()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::Items::ID: { _out.reset(new bonus::Items()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::CoefficientItem::ID: { _out.reset(new bonus::CoefficientItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::WeightItems::ID: { _out.reset(new bonus::WeightItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::ProbabilityItems::ID: { _out.reset(new bonus::ProbabilityItems()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::MultiBonus::ID: { _out.reset(new bonus::MultiBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::ProbabilityBonus::ID: { _out.reset(new bonus::ProbabilityBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::WeightBonus::ID: { _out.reset(new bonus::WeightBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case bonus::DropBonus::ID: { _out.reset(new bonus::DropBonus()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void bonus::Bonus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool bonus::OneItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;

        return true;
    }

    bool bonus::OneItem::deserializeOneItem(ByteBuf& _buf, std::shared_ptr<bonus::OneItem>& _out)
    {
        _out.reset(new bonus::OneItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::OneItem::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::OneItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());items.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;if(!_buf.readInt(_e)) return false; items.push_back(_e);}}

        return true;
    }

    bool bonus::OneItems::deserializeOneItems(ByteBuf& _buf, std::shared_ptr<bonus::OneItems>& _out)
    {
        _out.reset(new bonus::OneItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::OneItems::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
    }

    bool bonus::Item::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(amount)) return false;

        return true;
    }

    bool bonus::Item::deserializeItem(ByteBuf& _buf, std::shared_ptr<bonus::Item>& _out)
    {
        _out.reset(new bonus::Item());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::Item::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::Items::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::Item> _e;if(!bonus::Item::deserializeItem(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::Items::deserializeItems(ByteBuf& _buf, std::shared_ptr<bonus::Items>& _out)
    {
        _out.reset(new bonus::Items());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::Items::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::CoefficientItem::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(bonusId)) return false;
        if(!bonus::Items::deserializeItems(_buf, bonusList)) return false;

        return true;
    }

    bool bonus::CoefficientItem::deserializeCoefficientItem(ByteBuf& _buf, std::shared_ptr<bonus::CoefficientItem>& _out)
    {
        _out.reset(new bonus::CoefficientItem());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::CoefficientItem::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        bonusList->resolve(_tables);
    }

    bool bonus::WeightItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::WeightItemInfo> _e;if(!bonus::WeightItemInfo::deserializeWeightItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::WeightItems::deserializeWeightItems(ByteBuf& _buf, std::shared_ptr<bonus::WeightItems>& _out)
    {
        _out.reset(new bonus::WeightItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightItems::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::WeightItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightItemInfo::deserializeWeightItemInfo(ByteBuf& _buf, std::shared_ptr<bonus::WeightItemInfo>& _out)
    {
        _out.reset(new bonus::WeightItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightItemInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::ProbabilityItems::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());itemList.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::ProbabilityItemInfo> _e;if(!bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(_buf, _e)) return false; itemList.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityItems::deserializeProbabilityItems(ByteBuf& _buf, std::shared_ptr<bonus::ProbabilityItems>& _out)
    {
        _out.reset(new bonus::ProbabilityItems());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityItems::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : itemList) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityItemInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(itemId)) return false;
        if(!_buf.readInt(num)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityItemInfo::deserializeProbabilityItemInfo(ByteBuf& _buf, std::shared_ptr<bonus::ProbabilityItemInfo>& _out)
    {
        _out.reset(new bonus::ProbabilityItemInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityItemInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->itemId_Ref = ((item::TbItem*)(_tables["item.TbItem"]))->get(itemId);
    }

    bool bonus::MultiBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::Bonus> _e;if(!bonus::Bonus::deserializeBonus(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::MultiBonus::deserializeMultiBonus(ByteBuf& _buf, std::shared_ptr<bonus::MultiBonus>& _out)
    {
        _out.reset(new bonus::MultiBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::MultiBonus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::ProbabilityBonusInfo> _e;if(!bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::ProbabilityBonus::deserializeProbabilityBonus(ByteBuf& _buf, std::shared_ptr<bonus::ProbabilityBonus>& _out)
    {
        _out.reset(new bonus::ProbabilityBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityBonus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::ProbabilityBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readFloat(probability)) return false;

        return true;
    }

    bool bonus::ProbabilityBonusInfo::deserializeProbabilityBonusInfo(ByteBuf& _buf, std::shared_ptr<bonus::ProbabilityBonusInfo>& _out)
    {
        _out.reset(new bonus::ProbabilityBonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::ProbabilityBonusInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        bonus->resolve(_tables);
    }

    bool bonus::WeightBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());bonuses.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<bonus::WeightBonusInfo> _e;if(!bonus::WeightBonusInfo::deserializeWeightBonusInfo(_buf, _e)) return false; bonuses.push_back(_e);}}

        return true;
    }

    bool bonus::WeightBonus::deserializeWeightBonus(ByteBuf& _buf, std::shared_ptr<bonus::WeightBonus>& _out)
    {
        _out.reset(new bonus::WeightBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightBonus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        for(auto _e : bonuses) { _e->resolve(_tables); }
    }

    bool bonus::WeightBonusInfo::deserialize(ByteBuf& _buf)
    {

        if(!bonus::Bonus::deserializeBonus(_buf, bonus)) return false;
        if(!_buf.readInt(weight)) return false;

        return true;
    }

    bool bonus::WeightBonusInfo::deserializeWeightBonusInfo(ByteBuf& _buf, std::shared_ptr<bonus::WeightBonusInfo>& _out)
    {
        _out.reset(new bonus::WeightBonusInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::WeightBonusInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        bonus->resolve(_tables);
    }

    bool bonus::DropBonus::deserialize(ByteBuf& _buf)
    {
        if (!bonus::Bonus::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool bonus::DropBonus::deserializeDropBonus(ByteBuf& _buf, std::shared_ptr<bonus::DropBonus>& _out)
    {
        _out.reset(new bonus::DropBonus());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void bonus::DropBonus::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Bonus::resolve(_tables);
        this->id_Ref = ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(id);
    }

    bool common::GlobalConfig::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(bagCapacity)) return false;
        if(!_buf.readInt(bagCapacitySpecial)) return false;
        if(!_buf.readInt(bagTempExpendableCapacity)) return false;
        if(!_buf.readInt(bagTempToolCapacity)) return false;
        if(!_buf.readInt(bagInitCapacity)) return false;
        if(!_buf.readInt(quickBagCapacity)) return false;
        if(!_buf.readInt(clothBagCapacity)) return false;
        if(!_buf.readInt(clothBagInitCapacity)) return false;
        if(!_buf.readInt(clothBagCapacitySpecial)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; bagInitItemsDropId = new int32_t; *bagInitItemsDropId = _temp_; } else { bagInitItemsDropId = nullptr; } }
        if(!_buf.readInt(mailBoxCapacity)) return false;
        if(!_buf.readFloat(damageParamC)) return false;
        if(!_buf.readFloat(damageParamE)) return false;
        if(!_buf.readFloat(damageParamF)) return false;
        if(!_buf.readFloat(damageParamD)) return false;
        if(!_buf.readFloat(roleSpeed)) return false;
        if(!_buf.readFloat(monsterSpeed)) return false;
        if(!_buf.readInt(initEnergy)) return false;
        if(!_buf.readInt(initViality)) return false;
        if(!_buf.readInt(maxViality)) return false;
        if(!_buf.readInt(perVialityRecoveryTime)) return false;

        return true;
    }

    bool common::GlobalConfig::deserializeGlobalConfig(ByteBuf& _buf, std::shared_ptr<common::GlobalConfig>& _out)
    {
        _out.reset(new common::GlobalConfig());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void common::GlobalConfig::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        this->bagInitItemsDropId_Ref = this->bagInitItemsDropId != nullptr ? ((bonus::TbDrop*)(_tables["bonus.TbDrop"]))->get(*(this->bagInitItemsDropId)) : nullptr;
    }

    bool common::Dummy::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!limit::LimitBase::deserializeLimitBase(_buf, limit)) return false;

        return true;
    }

    bool common::Dummy::deserializeDummy(ByteBuf& _buf, std::shared_ptr<common::Dummy>& _out)
    {
        _out.reset(new common::Dummy());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void common::Dummy::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        limit->resolve(_tables);
    }

    bool limit::LimitBase::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool limit::LimitBase::deserializeLimitBase(ByteBuf& _buf, std::shared_ptr<limit::LimitBase>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case limit::DailyLimit::ID: { _out.reset(new limit::DailyLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case limit::MultiDayLimit::ID: { _out.reset(new limit::MultiDayLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case limit::WeeklyLimit::ID: { _out.reset(new limit::WeeklyLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case limit::MonthlyLimit::ID: { _out.reset(new limit::MonthlyLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case limit::CoolDown::ID: { _out.reset(new limit::CoolDown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case limit::GroupCoolDown::ID: { _out.reset(new limit::GroupCoolDown()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void limit::LimitBase::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool limit::DailyLimitBase::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool limit::DailyLimitBase::deserializeDailyLimitBase(ByteBuf& _buf, std::shared_ptr<limit::DailyLimitBase>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case limit::DailyLimit::ID: { _out.reset(new limit::DailyLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void limit::DailyLimitBase::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool limit::DailyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::DailyLimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::DailyLimit::deserializeDailyLimit(ByteBuf& _buf, std::shared_ptr<limit::DailyLimit>& _out)
    {
        _out.reset(new limit::DailyLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::DailyLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        DailyLimitBase::resolve(_tables);
    }

    bool limit::MultiDayLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(day)) return false;
        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::MultiDayLimit::deserializeMultiDayLimit(ByteBuf& _buf, std::shared_ptr<limit::MultiDayLimit>& _out)
    {
        _out.reset(new limit::MultiDayLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::MultiDayLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool limit::WeeklyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::WeeklyLimit::deserializeWeeklyLimit(ByteBuf& _buf, std::shared_ptr<limit::WeeklyLimit>& _out)
    {
        _out.reset(new limit::WeeklyLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::WeeklyLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool limit::MonthlyLimit::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(num)) return false;

        return true;
    }

    bool limit::MonthlyLimit::deserializeMonthlyLimit(ByteBuf& _buf, std::shared_ptr<limit::MonthlyLimit>& _out)
    {
        _out.reset(new limit::MonthlyLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::MonthlyLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool limit::CoolDown::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(duration)) return false;

        return true;
    }

    bool limit::CoolDown::deserializeCoolDown(ByteBuf& _buf, std::shared_ptr<limit::CoolDown>& _out)
    {
        _out.reset(new limit::CoolDown());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::CoolDown::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool limit::GroupCoolDown::deserialize(ByteBuf& _buf)
    {
        if (!limit::LimitBase::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(groupId)) return false;
        if(!_buf.readInt(duration)) return false;

        return true;
    }

    bool limit::GroupCoolDown::deserializeGroupCoolDown(ByteBuf& _buf, std::shared_ptr<limit::GroupCoolDown>& _out)
    {
        _out.reset(new limit::GroupCoolDown());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void limit::GroupCoolDown::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        LimitBase::resolve(_tables);
    }

    bool error::ErrorInfo::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readString(code)) return false;
        if(!_buf.readString(desc)) return false;
        if(!error::ErrorStyle::deserializeErrorStyle(_buf, style)) return false;

        return true;
    }

    bool error::ErrorInfo::deserializeErrorInfo(ByteBuf& _buf, std::shared_ptr<error::ErrorInfo>& _out)
    {
        _out.reset(new error::ErrorInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        style->resolve(_tables);
    }

    bool error::ErrorStyle::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool error::ErrorStyle::deserializeErrorStyle(ByteBuf& _buf, std::shared_ptr<error::ErrorStyle>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case error::ErrorStyleTip::ID: { _out.reset(new error::ErrorStyleTip()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleMsgbox::ID: { _out.reset(new error::ErrorStyleMsgbox()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleDlgOk::ID: { _out.reset(new error::ErrorStyleDlgOk()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case error::ErrorStyleDlgOkCancel::ID: { _out.reset(new error::ErrorStyleDlgOkCancel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void error::ErrorStyle::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool error::ErrorStyleTip::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool error::ErrorStyleTip::deserializeErrorStyleTip(ByteBuf& _buf, std::shared_ptr<error::ErrorStyleTip>& _out)
    {
        _out.reset(new error::ErrorStyleTip());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleTip::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleMsgbox::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btnName)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; operation = error::EOperation(__enum_temp__); }

        return true;
    }

    bool error::ErrorStyleMsgbox::deserializeErrorStyleMsgbox(ByteBuf& _buf, std::shared_ptr<error::ErrorStyleMsgbox>& _out)
    {
        _out.reset(new error::ErrorStyleMsgbox());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleMsgbox::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleDlgOk::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btnName)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOk::deserializeErrorStyleDlgOk(ByteBuf& _buf, std::shared_ptr<error::ErrorStyleDlgOk>& _out)
    {
        _out.reset(new error::ErrorStyleDlgOk());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleDlgOk::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::ErrorStyleDlgOkCancel::deserialize(ByteBuf& _buf)
    {
        if (!error::ErrorStyle::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readString(btn1Name)) return false;
        if(!_buf.readString(btn2Name)) return false;

        return true;
    }

    bool error::ErrorStyleDlgOkCancel::deserializeErrorStyleDlgOkCancel(ByteBuf& _buf, std::shared_ptr<error::ErrorStyleDlgOkCancel>& _out)
    {
        _out.reset(new error::ErrorStyleDlgOkCancel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::ErrorStyleDlgOkCancel::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ErrorStyle::resolve(_tables);
    }

    bool error::CodeInfo::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; code = error::EErrorCode(__enum_temp__); }
        if(!_buf.readString(key)) return false;

        return true;
    }

    bool error::CodeInfo::deserializeCodeInfo(ByteBuf& _buf, std::shared_ptr<error::CodeInfo>& _out)
    {
        _out.reset(new error::CodeInfo());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void error::CodeInfo::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool item::Item::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;
        if(!_buf.readString(name)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; majorType = item::EMajorType(__enum_temp__); }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; minorType = item::EMinorType(__enum_temp__); }
        if(!_buf.readInt(maxPileNum)) return false;
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; quality = item::EItemQuality(__enum_temp__); }
        if(!_buf.readString(icon)) return false;
        if(!_buf.readString(iconBackgroud)) return false;
        if(!_buf.readString(iconMask)) return false;
        if(!_buf.readString(desc)) return false;
        if(!_buf.readInt(showOrder)) return false;
        if(!_buf.readString(quantifier)) return false;
        if (!_buf.readBool(showInBag)) return false;
        if(!_buf.readInt(minShowLevel)) return false;
        if (!_buf.readBool(batchUsable)) return false;
        if(!_buf.readFloat(progressTimeWhenUse)) return false;
        if (!_buf.readBool(showHintWhenUse)) return false;
        if (!_buf.readBool(droppable)) return false;
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; price = new int32_t; *price = _temp_; } else { price = nullptr; } }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; useType = item::EUseType(__enum_temp__); }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; levelUpId = new int32_t; *levelUpId = _temp_; } else { levelUpId = nullptr; } }

        return true;
    }

    bool item::Item::deserializeItem(ByteBuf& _buf, std::shared_ptr<item::Item>& _out)
    {
        _out.reset(new item::Item());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::Item::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool item::ItemFunction::deserialize(ByteBuf& _buf)
    {

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; minorType = item::EMinorType(__enum_temp__); }
        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; funcType = item::EItemFunctionType(__enum_temp__); }
        if(!_buf.readString(method)) return false;
        if (!_buf.readBool(closeBagUi)) return false;

        return true;
    }

    bool item::ItemFunction::deserializeItemFunction(ByteBuf& _buf, std::shared_ptr<item::ItemFunction>& _out)
    {
        _out.reset(new item::ItemFunction());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::ItemFunction::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool item::ItemExtra::deserialize(ByteBuf& _buf)
    {

        if(!_buf.readInt(id)) return false;

        return true;
    }

    bool item::ItemExtra::deserializeItemExtra(ByteBuf& _buf, std::shared_ptr<item::ItemExtra>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case item::TreasureBox::ID: { _out.reset(new item::TreasureBox()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::InteractionItem::ID: { _out.reset(new item::InteractionItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::Clothes::ID: { _out.reset(new item::Clothes()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::DesignDrawing::ID: { _out.reset(new item::DesignDrawing()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case item::Dymmy::ID: { _out.reset(new item::Dymmy()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void item::ItemExtra::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool item::TreasureBox::deserialize(ByteBuf& _buf)
    {
        if (!item::ItemExtra::deserialize(_buf))
        {
            return false;
        }

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; keyItemId = new int32_t; *keyItemId = _temp_; } else { keyItemId = nullptr; } }
        if(!condition::MinLevel::deserializeMinLevel(_buf, openLevel)) return false;
        if (!_buf.readBool(useOnObtain)) return false;
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); dropIds.reserve(n);for(int i = 0 ; i < n ; i++) { int32_t _e;  if(!_buf.readInt(_e)) return false; dropIds.push_back(_e);}}
        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size()); chooseList.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<item::ChooseOneBonus> _e;  if(!item::ChooseOneBonus::deserializeChooseOneBonus(_buf, _e)) return false; chooseList.push_back(_e);}}

        return true;
    }

    bool item::TreasureBox::deserializeTreasureBox(ByteBuf& _buf, std::shared_ptr<item::TreasureBox>& _out)
    {
        _out.reset(new item::TreasureBox());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void item::TreasureBox::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        ItemExtra::resolve(_tables);
        openLevel->resolve(_tables);
        for(auto _e : chooseList) { _e->resolve(_tables); }
    }

    bool condition::Condition::deserialize(ByteBuf& _buf)
    {


        return true;
    }

    bool condition::Condition::deserializeCondition(ByteBuf& _buf, std::shared_ptr<condition::Condition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::TimeRange::ID: { _out.reset(new condition::TimeRange()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MultiRoleCondition::ID: { _out.reset(new condition::MultiRoleCondition()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::GenderLimit::ID: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::ID: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::ID: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::ID: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ContainsItem::ID: { _out.reset(new condition::ContainsItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::Condition::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool condition::TimeRange::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }

        if(!common::DateTimeRange::deserializeDateTimeRange(_buf, dateTimeRange)) return false;

        return true;
    }

    bool condition::TimeRange::deserializeTimeRange(ByteBuf& _buf, std::shared_ptr<condition::TimeRange>& _out)
    {
        _out.reset(new condition::TimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::TimeRange::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Condition::resolve(_tables);
        dateTimeRange->resolve(_tables);
    }

    bool common::DateTimeRange::deserialize(ByteBuf& _buf)
    {

        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; startTime = new int32_t; *startTime = _temp_; } else { startTime = nullptr; } }
        { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) {int32_t _temp_;  if(!_buf.readInt(_temp_)) return false; endTime = new int32_t; *endTime = _temp_; } else { endTime = nullptr; } }

        return true;
    }

    bool common::DateTimeRange::deserializeDateTimeRange(ByteBuf& _buf, std::shared_ptr<common::DateTimeRange>& _out)
    {
        _out.reset(new common::DateTimeRange());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void common::DateTimeRange::resolve(std::unordered_map<std::string, void*>& _tables)
    {
    }

    bool condition::RoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::Condition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::RoleCondition::deserializeRoleCondition(ByteBuf& _buf, std::shared_ptr<condition::RoleCondition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::MultiRoleCondition::ID: { _out.reset(new condition::MultiRoleCondition()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::GenderLimit::ID: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::ID: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::ID: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::ID: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ContainsItem::ID: { _out.reset(new condition::ContainsItem()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::RoleCondition::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        Condition::resolve(_tables);
    }

    bool condition::MultiRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int32_t n; if(!_buf.readSize(n)) return false; n = std::min(n, _buf.size());conditions.reserve(n);for(int i = 0 ; i < n ; i++) { std::shared_ptr<condition::RoleCondition> _e;if(!condition::RoleCondition::deserializeRoleCondition(_buf, _e)) return false; conditions.push_back(_e);}}

        return true;
    }

    bool condition::MultiRoleCondition::deserializeMultiRoleCondition(ByteBuf& _buf, std::shared_ptr<condition::MultiRoleCondition>& _out)
    {
        _out.reset(new condition::MultiRoleCondition());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MultiRoleCondition::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
        for(auto _e : conditions) { _e->resolve(_tables); }
    }

    bool condition::BoolRoleCondition::deserialize(ByteBuf& _buf)
    {
        if (!condition::RoleCondition::deserialize(_buf))
        {
            return false;
        }


        return true;
    }

    bool condition::BoolRoleCondition::deserializeBoolRoleCondition(ByteBuf& _buf, std::shared_ptr<condition::BoolRoleCondition>& _out)
    {
        int id;
        if (!_buf.readInt(id)) return false;
        switch (id)
        {
            case condition::GenderLimit::ID: { _out.reset(new condition::GenderLimit()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinLevel::ID: { _out.reset(new condition::MinLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MaxLevel::ID: { _out.reset(new condition::MaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::MinMaxLevel::ID: { _out.reset(new condition::MinMaxLevel()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            case condition::ClothesPropertyScoreGreaterThan::ID: { _out.reset(new condition::ClothesPropertyScoreGreaterThan()); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
            default: { _out = nullptr; return false;}
        }
    }

    void condition::BoolRoleCondition::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        RoleCondition::resolve(_tables);
    }

    bool condition::GenderLimit::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; gender = role::EGenderType(__enum_temp__); }

        return true;
    }

    bool condition::GenderLimit::deserializeGenderLimit(ByteBuf& _buf, std::shared_ptr<condition::GenderLimit>& _out)
    {
        _out.reset(new condition::GenderLimit());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::GenderLimit::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::MinLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MinLevel::deserializeMinLevel(ByteBuf& _buf, std::shared_ptr<condition::MinLevel>& _out)
    {
        _out.reset(new condition::MinLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MinLevel::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }

    bool condition::MaxLevel::deserialize(ByteBuf& _buf)
    {
        if (!condition::BoolRoleCondition::deserialize(_buf))
        {
            return false;
        }

        if(!_buf.readInt(level)) return false;

        return true;
    }

    bool condition::MaxLevel::deserializeMaxLevel(ByteBuf& _buf, std::shared_ptr<condition::MaxLevel>& _out)
    {
        _out.reset(new condition::MaxLevel());
        if (_out->deserialize(_buf))
        {
            return true;
        }
        else
        { 
            _out.reset();
            return false;
        }
    }

    void condition::MaxLevel::resolve(std::unordered_map<std::string, void*>& _tables)
    {
        BoolRoleCondition::resolve(_tables);
    }
}
