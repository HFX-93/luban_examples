
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------



export class Vector2 {
    static deserializeFromJson(json: any): Vector2 {
        let x = json['x']
        let y = json['y']
        if (x == null || y == null) {
            throw new Error()
        }
        return new Vector2(x, y)
    }

    x: number
    y: number
    constructor(x: number = 0, y: number = 0) {
        this.x = x
        this.y = y
    }
}

export class Vector3 {
    static deserializeFromJson(json: any): Vector3 {
        let x = json['x']
        let y = json['y']
        let z = json['z']
        if (x == null || y == null || z == null) {
            throw new Error()
        }
        return new Vector3(x, y, z)
    }

    x: number
    y: number
    z: number

    constructor(x: number = 0, y: number = 0, z: number = 0) {
        this.x = x
        this.y = y
        this.z = z
    }
}

export class Vector4 {
    static deserializeFromJson(json: any): Vector4 {
        let x = json['x']
        let y = json['y']
        let z = json['z']
        let w = json['w']
        if (x == null || y == null || z == null || w == null) {
            throw new Error()
        }
        return new Vector4(x, y, z, w)
    }
    
    x: number
    y: number
    z: number
    w: number

    constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {
        this.x = x
        this.y = y
        this.z = z
        this.w = w
    }
}


export namespace cfg {

export namespace role {

export class Consts {
    static MAX_NAME_LENGTH = 20;
    static MAX_USER_ROLE_NUM = 10;
}
}



export namespace test {

export class DemoConst {
    static x1 = 0;
    static x2 = 3242;
    static x3 = 444.3;
    static x4 = 55.3;
}
}



export namespace ai {

export enum EExecutor {
    CLIENT = 0,
    SERVER = 1,
}
}


export namespace ai {

export enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS = 8,
    ENUM = 9,
    OBJECT = 10,
}
}


export namespace ai {

export enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}
}


export namespace ai {

export enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}
}


export namespace ai {

export enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}
}


export namespace ai {

export enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}
}


export namespace common {

export enum EBoolOperator {
    AND = 0,
    OR = 1,
}
}


export namespace error {

export enum EOperation {
    LOGOUT = 0,
    RESTART = 1,
}
}


export namespace error {

export enum EErrorCode {
    OK = 0,
    SERVER_NOT_EXISTS = 1,
    HAS_BIND_SERVER = 2,
    AUTH_FAIL = 3,
    NOT_BIND_SERVER = 4,
    SERVER_ACCESS_FAIL = 5,
    EXAMPLE_FLASH = 6,
    EXAMPLE_MSGBOX = 7,
    EXAMPLE_DLG_OK = 8,
    EXAMPLE_DLG_OK_CANCEL = 9,
    ROLE_CREATE_NAME_INVALID_CHAR = 100,
    ROLE_CREATE_NAME_EMPTY = 101,
    ROLE_CREATE_NAME_EXCEED_MAX_LENGTH = 102,
    ROLE_CREATE_ROLE_LIST_FULL = 103,
    ROLE_CREATE_INVALID_PROFESSION = 104,
    ROLE_CREATE_INVALID_GENDER = 105,
    ROLE_NOT_OWNED_BY_USER = 106,
    ROLE_LEVEL_NOT_ARRIVE = 107,
    PARAM_ILLEGAL = 200,
    TEMP_BAG_NOT_EMPTY = 201,
    ITEM_CAN_NOT_USE = 202,
    CURRENCY_NOT_ENOUGH = 203,
    BAG_IS_FULL = 204,
    ITEM_NOT_ENOUGH = 205,
    ITEM_IN_BAG = 206,
    GENDER_NOT_MATCH = 300,
    LEVEL_TOO_LOW = 301,
    LEVEL_TOO_HIGH = 302,
    EXCEED_LIMIT = 303,
    OVER_TIME = 304,
    SERVER_ERROR = 305,
    SKILL_NOT_IN_LIST = 400,
    SKILL_NOT_COOLDOWN = 401,
    SKILL_TARGET_NOT_EXIST = 402,
    SKILL_ANOTHER_CASTING = 403,
    SKILL_OUT_OF_DISTANCE = 404,
    SKILL_TARGET_CAMP_NOT_MATCH = 405,
    SKILL_INVALID_DIRECTION = 406,
    SKILL_NOT_IN_SELECT_SHAPE = 407,
    SKILL_ENERGY_NOT_ENOUGH = 408,
    DIALOG_NODE_NOT_CHOOSEN = 500,
    DIALOG_NOT_FINISH = 501,
    DIALOG_HAS_FINISH = 502,
    QUEST_STAGE_NOT_FINISHED = 503,
    QUEST_NOT_DOING = 504,
    QUEST_STAGE_NOT_DOING = 505,
    QUEST_HAS_ACCEPTED = 506,
    MAP_OBJECT_NOT_EXIST = 600,
    INTERACTION_OBJECT_NOT_SUPPORT_OPERATION = 601,
    HAS_NOT_EQUIP = 602,
    HANDHELD_EQUIP_ID_NOT_MATCH = 603,
    NOT_AVAILABLE_SUIT_ID = 604,
    NO_INTERACTION_COMPONENT = 605,
    HAS_INTERACTED = 606,
    VIALITY_NOT_ENOUGH = 607,
    PLAYER_SESSION_NOT_EXIST = 608,
    PLAYER_SESSION_WORLD_PLAYER_NOT_INIT = 609,
    MAP_NOT_EXIST = 610,
    MAIL_TYPE_ERROR = 700,
    MAIL_NOT_EXITST = 701,
    MAIL_HAVE_DELETED = 702,
    MAIL_AWARD_HAVE_RECEIVED = 703,
    MAIL_OPERATE_TYPE_ERROR = 704,
    MAIL_CONDITION_NOT_MEET = 705,
    MAIL_STATE_ERROR = 706,
    MAIL_NO_AWARD = 707,
    MAIL_BOX_IS_FULL = 708,
    PROP_SCORE_NOT_BIGGER_THAN = 800,
    NOT_WEAR_CLOTHES = 801,
    NOT_WEAR_SUIT = 802,
    SUIT_NOT_UNLOCK = 900,
    SUIT_COMPONENT_NOT_UNLOCK = 901,
    SUIT_STATE_ERROR = 902,
    SUIT_COMPONENT_STATE_ERROR = 903,
    SUIT_COMPONENT_NO_NEED_LEARN = 904,
    STORE_NOT_ENABLED = 1000,
    SHELF_NOT_ENABLED = 1001,
    GOODS_NOT_ENABLED = 1002,
    GOODS_NOT_IN_CUR_REFRESH = 1003,
    RETRY = 1100,
    NOT_COOLDOWN = 1101,
    SELFIE_UNLOCK = 1200,
    SELFIE_ALREADY_UNLOCK = 1201,
    SELFIE_LACK_STARTS = 1202,
    SELFIE_HAD_REWARD = 1203,
}
}


export namespace item {

export enum EItemQuality {
    WHITE = 0,
    GREEN = 1,
    BLUE = 2,
    PURPLE = 3,
    GOLDEN = 4,
}
}


export namespace item {

export enum ECurrencyType {
    DIAMOND = 1,
    GOLD = 2,
    SILVER = 3,
    EXP = 4,
    POWER_POINT = 5,
}
}


export namespace item {

export enum EMajorType {
    CURRENCY = 1,
    CLOTH = 2,
    QUEST = 3,
    CONSUMABLES = 4,
    TREASURE_BOX = 5,
    ACHIEVEMENT_AND_TITLE = 6,
    HEAD_FRAME = 7,
    VOICE = 8,
    ACTION = 9,
    EXPANSION = 10,
    MATERIAL = 11,
}
}


export namespace item {

export enum EMinorType {
    DIAMOND = 101,
    GOLD = 102,
    SILVER = 103,
    EXP = 104,
    POWER_POINT = 105,
    HAIR_STYLE = 210,
    COAT = 220,
    UPPER_JACKET = 230,
    TROUSERS = 241,
    SKIRT = 242,
    SOCKS = 250,
    SHOES = 260,
    HAIR_ACCESSORY = 271,
    HAT = 272,
    EARRING = 273,
    NECKLACE = 274,
    BRACELET = 275,
    HAIR_CLASP = 276,
    GLOVE = 277,
    HANDHELD_OBJECT = 278,
    SPECIAL = 279,
    BASE_COSMETIC = 281,
    EYEBROW_COSMETIC = 282,
    EYELASH = 283,
    COSMETIC_CONTACT_LENSES = 284,
    LIP_COSMETIC = 285,
    SKIN_COLOR = 286,
    ONE_PIECE_DRESS = 290,
    SWITCH_CLOTHES_SCENE = 291,
    QUEST = 301,
    CAST = 401,
    SWORD = 421,
    BOW_ARROW = 422,
    WANDS = 423,
    SPECIAL_TOOL = 424,
    FOOD = 403,
    TREASURE_BOX = 501,
    KEY = 502,
    MULTI_CHOOSE_TREASURE_BOX = 503,
    ACHIEVEMENT = 601,
    TITLE = 602,
    AVATAR_FRAME = 701,
    VOICE = 801,
    IDLE_POSE = 901,
    PHOTO_POSE = 902,
    BAG = 1001,
    FRIEND_CAPACITY = 1002,
    CONSTRUCTION_MATERIAL = 1101,
    DESIGN_DRAWING = 1102,
}
}


export namespace item {

export enum EClothersStarQualityType {
    ONE = 1,
    TWO = 2,
    THREE = 3,
    FOUR = 4,
    FIVE = 5,
    SIX = 6,
    SEVEN = 7,
    EIGHT = 8,
    NINE = 9,
    TEN = 10,
}
}


export namespace item {

export enum EClothersTag {
    FANG_SHAI = 1,
    WU_ZHE = 2,
}
}


export namespace item {

export enum EUseType {
    MANUAL = 0,
    AUTO = 1,
}
}


export namespace item {

export enum EClothesHidePartType {
    CHEST = 0,
    HEAD = 1,
    SPINE_UPPER = 2,
    SPINE_LOWER = 3,
    HIP = 4,
    LEG_UPPER = 5,
    LEG_MIDDLE = 6,
    LEG_LOWER = 7,
}
}


export namespace item {

export enum EClothesPropertyType {
    JIAN_YUE = 1,
    HUA_LI = 2,
    KE_AI = 3,
    CHENG_SHU = 4,
    HUO_PO = 5,
    YOU_YA = 6,
    QING_CHUN = 7,
    XING_GAN = 8,
    QING_LIANG = 9,
    BAO_NUAN = 10,
}
}


export namespace item {

export enum EItemFunctionType {
    REPLACE_HANDHELD = 0,
    USE_DESIGN_DRAWING = 1,
}
}


export namespace limit {

export enum ENamespace {
    ITEM_DAILY_OBTAIN = 1,
    TREASURE_DAILY_USE = 2,
    STORE_GOODS_LIMIT_BUY = 3,
}
}


export namespace mail {

export enum EMailType {
    GLOBAL = 0,
    SYSTEM = 1,
}
}


export namespace role {

export enum EGenderType {
    MALE = 1,
    FEMALE = 2,
}
}


export namespace role {

export enum EProfession {
    TEST_PROFESSION = 1,
}
}


export namespace test {

export enum DemoEnum {
    A = 1,
    B = 2,
    C = 4,
    D = 5,
}
}


export namespace test {

export enum ETestUeType {
    WHITE = 0,
    BLACK = 1,
}
}


export namespace test {

export enum ETestEmptyEnum {
}
}


export namespace test {

export enum ETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}
}


   
export namespace ai {
export class TbBlackboard{
    private _dataMap: Map<string, ai.Blackboard>
    private _dataList: ai.Blackboard[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, ai.Blackboard>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: ai.Blackboard
            _v = new ai.Blackboard(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.name, _v)
        }
    }

    getDataMap(): Map<string, ai.Blackboard> { return this._dataMap; }
    getDataList(): ai.Blackboard[] { return this._dataList; }

    get(key: string): ai.Blackboard  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace ai {

export  class Blackboard  {

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.parent_name == null) { throw new Error() }
        this.parentName = _json_.parent_name
        if (_json_.keys == null) { throw new Error() }
        { this.keys = []; for(let _ele of _json_.keys) { let _e : ai.BlackboardKey; _e = new ai.BlackboardKey(_ele); this.keys.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly parentName: string
    parentName_Ref : ai.Blackboard
    readonly keys: ai.BlackboardKey[]

    resolve(_tables: Map<string, any>) {
        this.parentName_Ref = (_tables.get('ai.TbBlackboard') as ai.TbBlackboard).get(this.parentName)
        for(let _e of this.keys) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace ai {

export  class BlackboardKey  {

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.is_static == null) { throw new Error() }
        this.isStatic = _json_.is_static
        if (_json_.type == null) { throw new Error() }
        this.type = _json_.type
        if (_json_.type_class_name == null) { throw new Error() }
        this.typeClassName = _json_.type_class_name
    }

    readonly name: string
    readonly desc: string
    readonly isStatic: boolean
    readonly type: ai.EKeyType
    readonly typeClassName: string

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace ai {
export class TbBehaviorTree{
    private _dataMap: Map<number, ai.BehaviorTree>
    private _dataList: ai.BehaviorTree[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, ai.BehaviorTree>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: ai.BehaviorTree
            _v = new ai.BehaviorTree(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, ai.BehaviorTree> { return this._dataMap; }
    getDataList(): ai.BehaviorTree[] { return this._dataList; }

    get(key: number): ai.BehaviorTree  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace ai {

export  class BehaviorTree  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.blackboard_id == null) { throw new Error() }
        this.blackboardId = _json_.blackboard_id
        if (_json_.root == null) { throw new Error() }
        this.root = ai.ComposeNode.constructorFrom(_json_.root)
    }

    readonly id: number
    readonly name: string
    readonly desc: string
    readonly blackboardId: string
    blackboardId_Ref : ai.Blackboard
    readonly root: ai.ComposeNode

    resolve(_tables: Map<string, any>) {
        this.blackboardId_Ref = (_tables.get('ai.TbBlackboard') as ai.TbBlackboard).get(this.blackboardId)
        if (this.root != null) { this.root.resolve(_tables);}
    }
}

}





export namespace ai {

export  abstract  class Node  {
    static constructorFrom(_json_: any): Node {
        switch (_json_.__type__) {
            case 'UeSetDefaultFocus': return new ai.UeSetDefaultFocus(_json_)
            case 'ExecuteTimeStatistic': return new ai.ExecuteTimeStatistic(_json_)
            case 'ChooseTarget': return new ai.ChooseTarget(_json_)
            case 'KeepFaceTarget': return new ai.KeepFaceTarget(_json_)
            case 'GetOwnerPlayer': return new ai.GetOwnerPlayer(_json_)
            case 'UpdateDailyBehaviorProps': return new ai.UpdateDailyBehaviorProps(_json_)
            case 'UeLoop': return new ai.UeLoop(_json_)
            case 'UeCooldown': return new ai.UeCooldown(_json_)
            case 'UeTimeLimit': return new ai.UeTimeLimit(_json_)
            case 'UeBlackboard': return new ai.UeBlackboard(_json_)
            case 'UeForceSuccess': return new ai.UeForceSuccess(_json_)
            case 'IsAtLocation': return new ai.IsAtLocation(_json_)
            case 'DistanceLessThan': return new ai.DistanceLessThan(_json_)
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.node_name == null) { throw new Error() }
        this.nodeName = _json_.node_name
    }

    readonly id: number
    readonly nodeName: string

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace ai {

export  abstract  class Service  extends ai.Node {
    static constructorFrom(_json_: any): Service {
        switch (_json_.__type__) {
            case 'UeSetDefaultFocus': return new ai.UeSetDefaultFocus(_json_)
            case 'ExecuteTimeStatistic': return new ai.ExecuteTimeStatistic(_json_)
            case 'ChooseTarget': return new ai.ChooseTarget(_json_)
            case 'KeepFaceTarget': return new ai.KeepFaceTarget(_json_)
            case 'GetOwnerPlayer': return new ai.GetOwnerPlayer(_json_)
            case 'UpdateDailyBehaviorProps': return new ai.UpdateDailyBehaviorProps(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeSetDefaultFocus  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.keyboard_key == null) { throw new Error() }
        this.keyboardKey = _json_.keyboard_key
    }

    readonly keyboardKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class ExecuteTimeStatistic  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class ChooseTarget  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.result_target_key == null) { throw new Error() }
        this.resultTargetKey = _json_.result_target_key
    }

    readonly resultTargetKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class KeepFaceTarget  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key == null) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
    }

    readonly targetActorKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class GetOwnerPlayer  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.player_actor_key == null) { throw new Error() }
        this.playerActorKey = _json_.player_actor_key
    }

    readonly playerActorKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UpdateDailyBehaviorProps  extends ai.Service {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.satiety_key == null) { throw new Error() }
        this.satietyKey = _json_.satiety_key
        if (_json_.energy_key == null) { throw new Error() }
        this.energyKey = _json_.energy_key
        if (_json_.mood_key == null) { throw new Error() }
        this.moodKey = _json_.mood_key
        if (_json_.satiety_lower_threshold_key == null) { throw new Error() }
        this.satietyLowerThresholdKey = _json_.satiety_lower_threshold_key
        if (_json_.satiety_upper_threshold_key == null) { throw new Error() }
        this.satietyUpperThresholdKey = _json_.satiety_upper_threshold_key
        if (_json_.energy_lower_threshold_key == null) { throw new Error() }
        this.energyLowerThresholdKey = _json_.energy_lower_threshold_key
        if (_json_.energy_upper_threshold_key == null) { throw new Error() }
        this.energyUpperThresholdKey = _json_.energy_upper_threshold_key
        if (_json_.mood_lower_threshold_key == null) { throw new Error() }
        this.moodLowerThresholdKey = _json_.mood_lower_threshold_key
        if (_json_.mood_upper_threshold_key == null) { throw new Error() }
        this.moodUpperThresholdKey = _json_.mood_upper_threshold_key
    }

    readonly satietyKey: string
    readonly energyKey: string
    readonly moodKey: string
    readonly satietyLowerThresholdKey: string
    readonly satietyUpperThresholdKey: string
    readonly energyLowerThresholdKey: string
    readonly energyUpperThresholdKey: string
    readonly moodLowerThresholdKey: string
    readonly moodUpperThresholdKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  abstract  class Decorator  extends ai.Node {
    static constructorFrom(_json_: any): Decorator {
        switch (_json_.__type__) {
            case 'UeLoop': return new ai.UeLoop(_json_)
            case 'UeCooldown': return new ai.UeCooldown(_json_)
            case 'UeTimeLimit': return new ai.UeTimeLimit(_json_)
            case 'UeBlackboard': return new ai.UeBlackboard(_json_)
            case 'UeForceSuccess': return new ai.UeForceSuccess(_json_)
            case 'IsAtLocation': return new ai.IsAtLocation(_json_)
            case 'DistanceLessThan': return new ai.DistanceLessThan(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.flow_abort_mode == null) { throw new Error() }
        this.flowAbortMode = _json_.flow_abort_mode
    }

    readonly flowAbortMode: ai.EFlowAbortMode

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeLoop  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num_loops == null) { throw new Error() }
        this.numLoops = _json_.num_loops
        if (_json_.infinite_loop == null) { throw new Error() }
        this.infiniteLoop = _json_.infinite_loop
        if (_json_.infinite_loop_timeout_time == null) { throw new Error() }
        this.infiniteLoopTimeoutTime = _json_.infinite_loop_timeout_time
    }

    readonly numLoops: number
    readonly infiniteLoop: boolean
    readonly infiniteLoopTimeoutTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeCooldown  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.cooldown_time == null) { throw new Error() }
        this.cooldownTime = _json_.cooldown_time
    }

    readonly cooldownTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeTimeLimit  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.limit_time == null) { throw new Error() }
        this.limitTime = _json_.limit_time
    }

    readonly limitTime: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeBlackboard  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.notify_observer == null) { throw new Error() }
        this.notifyObserver = _json_.notify_observer
        if (_json_.blackboard_key == null) { throw new Error() }
        this.blackboardKey = _json_.blackboard_key
        if (_json_.key_query == null) { throw new Error() }
        this.keyQuery = ai.KeyQueryOperator.constructorFrom(_json_.key_query)
    }

    readonly notifyObserver: ai.ENotifyObserverMode
    readonly blackboardKey: string
    readonly keyQuery: ai.KeyQueryOperator

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.keyQuery != null) { this.keyQuery.resolve(_tables);}
    }
}

}





export namespace ai {

export  abstract  class KeyQueryOperator  {
    static constructorFrom(_json_: any): KeyQueryOperator {
        switch (_json_.__type__) {
            case 'IsSet': return new ai.IsSet(_json_)
            case 'IsNotSet': return new ai.IsNotSet(_json_)
            case 'BinaryOperator': return new ai.BinaryOperator(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace ai {

export  class IsSet  extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class IsNotSet  extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class BinaryOperator  extends ai.KeyQueryOperator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.oper == null) { throw new Error() }
        this.oper = _json_.oper
        if (_json_.data == null) { throw new Error() }
        this.data = ai.KeyData.constructorFrom(_json_.data)
    }

    readonly oper: ai.EOperator
    readonly data: ai.KeyData

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.data != null) { this.data.resolve(_tables);}
    }
}

}





export namespace ai {

export  abstract  class KeyData  {
    static constructorFrom(_json_: any): KeyData {
        switch (_json_.__type__) {
            case 'FloatKeyData': return new ai.FloatKeyData(_json_)
            case 'IntKeyData': return new ai.IntKeyData(_json_)
            case 'StringKeyData': return new ai.StringKeyData(_json_)
            case 'BlackboardKeyData': return new ai.BlackboardKeyData(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace ai {

export  class FloatKeyData  extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class IntKeyData  extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class StringKeyData  extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class BlackboardKeyData  extends ai.KeyData {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly value: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeForceSuccess  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class IsAtLocation  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.acceptable_radius == null) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
        if (_json_.keyboard_key == null) { throw new Error() }
        this.keyboardKey = _json_.keyboard_key
        if (_json_.inverse_condition == null) { throw new Error() }
        this.inverseCondition = _json_.inverse_condition
    }

    readonly acceptableRadius: number
    readonly keyboardKey: string
    readonly inverseCondition: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class DistanceLessThan  extends ai.Decorator {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.actor1_key == null) { throw new Error() }
        this.actor1Key = _json_.actor1_key
        if (_json_.actor2_key == null) { throw new Error() }
        this.actor2Key = _json_.actor2_key
        if (_json_.distance == null) { throw new Error() }
        this.distance = _json_.distance
        if (_json_.reverse_result == null) { throw new Error() }
        this.reverseResult = _json_.reverse_result
    }

    readonly actor1Key: string
    readonly actor2Key: string
    readonly distance: number
    readonly reverseResult: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  abstract  class FlowNode  extends ai.Node {
    static constructorFrom(_json_: any): FlowNode {
        switch (_json_.__type__) {
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.decorators == null) { throw new Error() }
        { this.decorators = []; for(let _ele of _json_.decorators) { let _e : ai.Decorator; _e = ai.Decorator.constructorFrom(_ele); this.decorators.push(_e);}}
        if (_json_.services == null) { throw new Error() }
        { this.services = []; for(let _ele of _json_.services) { let _e : ai.Service; _e = ai.Service.constructorFrom(_ele); this.services.push(_e);}}
    }

    readonly decorators: ai.Decorator[]
    readonly services: ai.Service[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.decorators) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.services) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace ai {

export  abstract  class ComposeNode  extends ai.FlowNode {
    static constructorFrom(_json_: any): ComposeNode {
        switch (_json_.__type__) {
            case 'Sequence': return new ai.Sequence(_json_)
            case 'Selector': return new ai.Selector(_json_)
            case 'SimpleParallel': return new ai.SimpleParallel(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class Sequence  extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.children == null) { throw new Error() }
        { this.children = []; for(let _ele of _json_.children) { let _e : ai.FlowNode; _e = ai.FlowNode.constructorFrom(_ele); this.children.push(_e);}}
    }

    readonly children: ai.FlowNode[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.children) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace ai {

export  class Selector  extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.children == null) { throw new Error() }
        { this.children = []; for(let _ele of _json_.children) { let _e : ai.FlowNode; _e = ai.FlowNode.constructorFrom(_ele); this.children.push(_e);}}
    }

    readonly children: ai.FlowNode[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.children) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace ai {

export  class SimpleParallel  extends ai.ComposeNode {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.finish_mode == null) { throw new Error() }
        this.finishMode = _json_.finish_mode
        if (_json_.main_task == null) { throw new Error() }
        this.mainTask = ai.Task.constructorFrom(_json_.main_task)
        if (_json_.background_node == null) { throw new Error() }
        this.backgroundNode = ai.FlowNode.constructorFrom(_json_.background_node)
    }

    readonly finishMode: ai.EFinishMode
    readonly mainTask: ai.Task
    readonly backgroundNode: ai.FlowNode

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.mainTask != null) { this.mainTask.resolve(_tables);}
        if (this.backgroundNode != null) { this.backgroundNode.resolve(_tables);}
    }
}

}





export namespace ai {

export  abstract  class Task  extends ai.FlowNode {
    static constructorFrom(_json_: any): Task {
        switch (_json_.__type__) {
            case 'UeWait': return new ai.UeWait(_json_)
            case 'UeWaitBlackboardTime': return new ai.UeWaitBlackboardTime(_json_)
            case 'MoveToTarget': return new ai.MoveToTarget(_json_)
            case 'ChooseSkill': return new ai.ChooseSkill(_json_)
            case 'MoveToRandomLocation': return new ai.MoveToRandomLocation(_json_)
            case 'MoveToLocation': return new ai.MoveToLocation(_json_)
            case 'DebugPrint': return new ai.DebugPrint(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.ignore_restart_self == null) { throw new Error() }
        this.ignoreRestartSelf = _json_.ignore_restart_self
    }

    readonly ignoreRestartSelf: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeWait  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.wait_time == null) { throw new Error() }
        this.waitTime = _json_.wait_time
        if (_json_.random_deviation == null) { throw new Error() }
        this.randomDeviation = _json_.random_deviation
    }

    readonly waitTime: number
    readonly randomDeviation: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class UeWaitBlackboardTime  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.blackboard_key == null) { throw new Error() }
        this.blackboardKey = _json_.blackboard_key
    }

    readonly blackboardKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class MoveToTarget  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key == null) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
        if (_json_.acceptable_radius == null) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
    }

    readonly targetActorKey: string
    readonly acceptableRadius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class ChooseSkill  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.target_actor_key == null) { throw new Error() }
        this.targetActorKey = _json_.target_actor_key
        if (_json_.result_skill_id_key == null) { throw new Error() }
        this.resultSkillIdKey = _json_.result_skill_id_key
    }

    readonly targetActorKey: string
    readonly resultSkillIdKey: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class MoveToRandomLocation  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.origin_position_key == null) { throw new Error() }
        this.originPositionKey = _json_.origin_position_key
        if (_json_.radius == null) { throw new Error() }
        this.radius = _json_.radius
    }

    readonly originPositionKey: string
    readonly radius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class MoveToLocation  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.location == null) { throw new Error() }
        this.location = Vector3.deserializeFromJson(_json_.location)
        if (_json_.acceptable_radius == null) { throw new Error() }
        this.acceptableRadius = _json_.acceptable_radius
    }

    readonly location: Vector3
    readonly acceptableRadius: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace ai {

export  class DebugPrint  extends ai.Task {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.text == null) { throw new Error() }
        this.text = _json_.text
    }

    readonly text: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}


   
export namespace blueprint {
export class TbClazz{
    private _dataMap: Map<string, blueprint.Clazz>
    private _dataList: blueprint.Clazz[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, blueprint.Clazz>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: blueprint.Clazz
            _v = blueprint.Clazz.constructorFrom(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.name, _v)
        }
    }

    getDataMap(): Map<string, blueprint.Clazz> { return this._dataMap; }
    getDataList(): blueprint.Clazz[] { return this._dataList; }

    get(key: string): blueprint.Clazz  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace blueprint {

export  abstract  class Clazz  {
    static constructorFrom(_json_: any): Clazz {
        switch (_json_.__type__) {
            case 'Interface': return new blueprint.Interface(_json_)
            case 'NormalClazz': return new blueprint.NormalClazz(_json_)
            case 'EnumClazz': return new blueprint.EnumClazz(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.parents == null) { throw new Error() }
        { this.parents = []; for(let _ele of _json_.parents) { let _e : blueprint.Clazz; _e = blueprint.Clazz.constructorFrom(_ele); this.parents.push(_e);}}
        if (_json_.methods == null) { throw new Error() }
        { this.methods = []; for(let _ele of _json_.methods) { let _e : blueprint.Method; _e = blueprint.Method.constructorFrom(_ele); this.methods.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly parents: blueprint.Clazz[]
    readonly methods: blueprint.Method[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.parents) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.methods) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace blueprint {

export  abstract  class Method  {
    static constructorFrom(_json_: any): Method {
        switch (_json_.__type__) {
            case 'AbstraceMethod': return new blueprint.AbstraceMethod(_json_)
            case 'ExternalMethod': return new blueprint.ExternalMethod(_json_)
            case 'BlueprintMethod': return new blueprint.BlueprintMethod(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.is_static == null) { throw new Error() }
        this.isStatic = _json_.is_static
        if (_json_.return_type == null) { throw new Error() }
        this.returnType = _json_.return_type
        if (_json_.parameters == null) { throw new Error() }
        { this.parameters = []; for(let _ele of _json_.parameters) { let _e : blueprint.ParamInfo; _e = new blueprint.ParamInfo(_ele); this.parameters.push(_e);}}
    }

    readonly name: string
    readonly desc: string
    readonly isStatic: boolean
    readonly returnType: string
    readonly parameters: blueprint.ParamInfo[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.parameters) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace blueprint {

export  class ParamInfo  {

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.type == null) { throw new Error() }
        this.type = _json_.type
        if (_json_.is_ref == null) { throw new Error() }
        this.isRef = _json_.is_ref
    }

    readonly name: string
    readonly type: string
    readonly isRef: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace blueprint {

export  class AbstraceMethod  extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace blueprint {

export  class ExternalMethod  extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace blueprint {

export  class BlueprintMethod  extends blueprint.Method {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace blueprint {

export  class Interface  extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace blueprint {

export  class NormalClazz  extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.is_abstract == null) { throw new Error() }
        this.isAbstract = _json_.is_abstract
        if (_json_.fields == null) { throw new Error() }
        { this.fields = []; for(let _ele of _json_.fields) { let _e : blueprint.Field; _e = new blueprint.Field(_ele); this.fields.push(_e);}}
    }

    readonly isAbstract: boolean
    readonly fields: blueprint.Field[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.fields) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace blueprint {

export  class Field  {

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.type == null) { throw new Error() }
        this.type = _json_.type
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
    }

    readonly name: string
    readonly type: string
    readonly desc: string

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace blueprint {

export  class EnumClazz  extends blueprint.Clazz {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.enums == null) { throw new Error() }
        { this.enums = []; for(let _ele of _json_.enums) { let _e : blueprint.EnumField; _e = new blueprint.EnumField(_ele); this.enums.push(_e);}}
    }

    readonly enums: blueprint.EnumField[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.enums) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace blueprint {

export  class EnumField  {

    constructor(_json_: any) {
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly name: string
    readonly value: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace bonus {
export class TbDrop{
    private _dataMap: Map<number, bonus.DropInfo>
    private _dataList: bonus.DropInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, bonus.DropInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: bonus.DropInfo
            _v = new bonus.DropInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, bonus.DropInfo> { return this._dataMap; }
    getDataList(): bonus.DropInfo[] { return this._dataList; }

    get(key: number): bonus.DropInfo  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace bonus {

export  class DropInfo  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.client_show_items == null) { throw new Error() }
        { this.clientShowItems = []; for(let _ele of _json_.client_show_items) { let _e : bonus.ShowItemInfo; _e = new bonus.ShowItemInfo(_ele); this.clientShowItems.push(_e);}}
        if (_json_.bonus == null) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
    }

    readonly id: number
    readonly desc: string
    readonly clientShowItems: bonus.ShowItemInfo[]
    readonly bonus: bonus.Bonus

    resolve(_tables: Map<string, any>) {
        for(let _e of this.clientShowItems) { if (_e != null ) {_e.resolve(_tables);} }
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}





export namespace bonus {

export  class ShowItemInfo  {

    constructor(_json_: any) {
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.item_num == null) { throw new Error() }
        this.itemNum = _json_.item_num
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly itemNum: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace bonus {

export  abstract  class Bonus  {
    static constructorFrom(_json_: any): Bonus {
        switch (_json_.__type__) {
            case 'OneItem': return new bonus.OneItem(_json_)
            case 'OneItems': return new bonus.OneItems(_json_)
            case 'Item': return new bonus.Item(_json_)
            case 'Items': return new bonus.Items(_json_)
            case 'CoefficientItem': return new bonus.CoefficientItem(_json_)
            case 'WeightItems': return new bonus.WeightItems(_json_)
            case 'ProbabilityItems': return new bonus.ProbabilityItems(_json_)
            case 'MultiBonus': return new bonus.MultiBonus(_json_)
            case 'ProbabilityBonus': return new bonus.ProbabilityBonus(_json_)
            case 'WeightBonus': return new bonus.WeightBonus(_json_)
            case 'DropBonus': return new bonus.DropBonus(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace bonus {

export  class OneItem  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
    }

    readonly itemId: number
    itemId_Ref : item.Item

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace bonus {

export  class OneItems  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.items == null) { throw new Error() }
        this.items = _json_.items
    }

    readonly items: Int32Array

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace bonus {

export  class Item  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.amount == null) { throw new Error() }
        this.amount = _json_.amount
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly amount: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace bonus {

export  class Items  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list == null) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.Item; _e = new bonus.Item(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.Item[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class CoefficientItem  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonus_id == null) { throw new Error() }
        this.bonusId = _json_.bonus_id
        if (_json_.bonus_list == null) { throw new Error() }
        this.bonusList = new bonus.Items(_json_.bonus_list)
    }

    readonly bonusId: number
    readonly bonusList: bonus.Items

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.bonusList != null) { this.bonusList.resolve(_tables);}
    }
}

}





export namespace bonus {

export  class WeightItems  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list == null) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.WeightItemInfo; _e = new bonus.WeightItemInfo(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.WeightItemInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class WeightItemInfo  {

    constructor(_json_: any) {
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
        if (_json_.weight == null) { throw new Error() }
        this.weight = _json_.weight
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly num: number
    readonly weight: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace bonus {

export  class ProbabilityItems  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list == null) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :bonus.ProbabilityItemInfo; _e = new bonus.ProbabilityItemInfo(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: bonus.ProbabilityItemInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class ProbabilityItemInfo  {

    constructor(_json_: any) {
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
        if (_json_.probability == null) { throw new Error() }
        this.probability = _json_.probability
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly num: number
    readonly probability: number

    resolve(_tables: Map<string, any>) {
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace bonus {

export  class MultiBonus  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses == null) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.Bonus; _e = bonus.Bonus.constructorFrom(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.Bonus[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class ProbabilityBonus  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses == null) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.ProbabilityBonusInfo; _e = new bonus.ProbabilityBonusInfo(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.ProbabilityBonusInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class ProbabilityBonusInfo  {

    constructor(_json_: any) {
        if (_json_.bonus == null) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
        if (_json_.probability == null) { throw new Error() }
        this.probability = _json_.probability
    }

    readonly bonus: bonus.Bonus
    readonly probability: number

    resolve(_tables: Map<string, any>) {
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}





export namespace bonus {

export  class WeightBonus  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.bonuses == null) { throw new Error() }
        { this.bonuses = []; for(let _ele of _json_.bonuses) { let _e :bonus.WeightBonusInfo; _e = new bonus.WeightBonusInfo(_ele); this.bonuses.push(_e);}}
    }

    readonly bonuses: bonus.WeightBonusInfo[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.bonuses) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace bonus {

export  class WeightBonusInfo  {

    constructor(_json_: any) {
        if (_json_.bonus == null) { throw new Error() }
        this.bonus = bonus.Bonus.constructorFrom(_json_.bonus)
        if (_json_.weight == null) { throw new Error() }
        this.weight = _json_.weight
    }

    readonly bonus: bonus.Bonus
    readonly weight: number

    resolve(_tables: Map<string, any>) {
        if (this.bonus != null) { this.bonus.resolve(_tables);}
    }
}

}





export namespace bonus {

export  class DropBonus  extends bonus.Bonus {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
    }

    readonly id: number
    id_Ref : bonus.DropInfo

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.id_Ref = (_tables.get('bonus.TbDrop') as bonus.TbDrop).get(this.id)
    }
}

}


   
export namespace common {
export class TbGlobalConfig{

     private _data: common.GlobalConfig
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new common.GlobalConfig(_json_[0])
    }

    getData(): common.GlobalConfig { return this._data; }

     get  bagCapacity(): number { return this._data.bagCapacity; }
     get  bagCapacitySpecial(): number { return this._data.bagCapacitySpecial; }
     get  bagTempExpendableCapacity(): number { return this._data.bagTempExpendableCapacity; }
     get  bagTempToolCapacity(): number { return this._data.bagTempToolCapacity; }
     get  bagInitCapacity(): number { return this._data.bagInitCapacity; }
     get  quickBagCapacity(): number { return this._data.quickBagCapacity; }
     get  clothBagCapacity(): number { return this._data.clothBagCapacity; }
     get  clothBagInitCapacity(): number { return this._data.clothBagInitCapacity; }
     get  clothBagCapacitySpecial(): number { return this._data.clothBagCapacitySpecial; }
     get  bagInitItemsDropId(): number { return this._data.bagInitItemsDropId; }
     get  mailBoxCapacity(): number { return this._data.mailBoxCapacity; }
     get  damageParamC(): number { return this._data.damageParamC; }
     get  damageParamE(): number { return this._data.damageParamE; }
     get  damageParamF(): number { return this._data.damageParamF; }
     get  damageParamD(): number { return this._data.damageParamD; }
     get  roleSpeed(): number { return this._data.roleSpeed; }
     get  monsterSpeed(): number { return this._data.monsterSpeed; }
     get  initEnergy(): number { return this._data.initEnergy; }
     get  initViality(): number { return this._data.initViality; }
     get  maxViality(): number { return this._data.maxViality; }
     get  perVialityRecoveryTime(): number { return this._data.perVialityRecoveryTime; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}





export namespace common {

export  class GlobalConfig  {

    constructor(_json_: any) {
        if (_json_.bag_capacity == null) { throw new Error() }
        this.bagCapacity = _json_.bag_capacity
        if (_json_.bag_capacity_special == null) { throw new Error() }
        this.bagCapacitySpecial = _json_.bag_capacity_special
        if (_json_.bag_temp_expendable_capacity == null) { throw new Error() }
        this.bagTempExpendableCapacity = _json_.bag_temp_expendable_capacity
        if (_json_.bag_temp_tool_capacity == null) { throw new Error() }
        this.bagTempToolCapacity = _json_.bag_temp_tool_capacity
        if (_json_.bag_init_capacity == null) { throw new Error() }
        this.bagInitCapacity = _json_.bag_init_capacity
        if (_json_.quick_bag_capacity == null) { throw new Error() }
        this.quickBagCapacity = _json_.quick_bag_capacity
        if (_json_.cloth_bag_capacity == null) { throw new Error() }
        this.clothBagCapacity = _json_.cloth_bag_capacity
        if (_json_.cloth_bag_init_capacity == null) { throw new Error() }
        this.clothBagInitCapacity = _json_.cloth_bag_init_capacity
        if (_json_.cloth_bag_capacity_special == null) { throw new Error() }
        this.clothBagCapacitySpecial = _json_.cloth_bag_capacity_special
        if(_json_.bag_init_items_drop_id != null) { this.bagInitItemsDropId = _json_.bag_init_items_drop_id } else { this.bagInitItemsDropId = null }
        if (_json_.mail_box_capacity == null) { throw new Error() }
        this.mailBoxCapacity = _json_.mail_box_capacity
        if (_json_.damage_param_c == null) { throw new Error() }
        this.damageParamC = _json_.damage_param_c
        if (_json_.damage_param_e == null) { throw new Error() }
        this.damageParamE = _json_.damage_param_e
        if (_json_.damage_param_f == null) { throw new Error() }
        this.damageParamF = _json_.damage_param_f
        if (_json_.damage_param_d == null) { throw new Error() }
        this.damageParamD = _json_.damage_param_d
        if (_json_.role_speed == null) { throw new Error() }
        this.roleSpeed = _json_.role_speed
        if (_json_.monster_speed == null) { throw new Error() }
        this.monsterSpeed = _json_.monster_speed
        if (_json_.init_energy == null) { throw new Error() }
        this.initEnergy = _json_.init_energy
        if (_json_.init_viality == null) { throw new Error() }
        this.initViality = _json_.init_viality
        if (_json_.max_viality == null) { throw new Error() }
        this.maxViality = _json_.max_viality
        if (_json_.per_viality_recovery_time == null) { throw new Error() }
        this.perVialityRecoveryTime = _json_.per_viality_recovery_time
    }

    readonly bagCapacity: number
    readonly bagCapacitySpecial: number
    readonly bagTempExpendableCapacity: number
    readonly bagTempToolCapacity: number
    readonly bagInitCapacity: number
    readonly quickBagCapacity: number
    readonly clothBagCapacity: number
    readonly clothBagInitCapacity: number
    readonly clothBagCapacitySpecial: number
    readonly bagInitItemsDropId?: number
    bagInitItemsDropId_Ref : bonus.DropInfo
    readonly mailBoxCapacity: number
    readonly damageParamC: number
    readonly damageParamE: number
    readonly damageParamF: number
    readonly damageParamD: number
    readonly roleSpeed: number
    readonly monsterSpeed: number
    readonly initEnergy: number
    readonly initViality: number
    readonly maxViality: number
    readonly perVialityRecoveryTime: number

    resolve(_tables: Map<string, any>) {
        this.bagInitItemsDropId_Ref = this.bagInitItemsDropId != null ? (_tables.get('bonus.TbDrop') as  bonus.TbDrop).get(this.bagInitItemsDropId) : null
    }
}

}


   
export namespace common {
export class TbDummy{
    private _dataMap: Map<number, common.Dummy>
    private _dataList: common.Dummy[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, common.Dummy>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: common.Dummy
            _v = new common.Dummy(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, common.Dummy> { return this._dataMap; }
    getDataList(): common.Dummy[] { return this._dataList; }

    get(key: number): common.Dummy  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace common {

export  class Dummy  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.limit == null) { throw new Error() }
        this.limit = limit.LimitBase.constructorFrom(_json_.limit)
    }

    readonly id: number
    readonly limit: limit.LimitBase

    resolve(_tables: Map<string, any>) {
        if (this.limit != null) { this.limit.resolve(_tables);}
    }
}

}





export namespace limit {

export  abstract  class LimitBase  {
    static constructorFrom(_json_: any): LimitBase {
        switch (_json_.__type__) {
            case 'DailyLimit': return new limit.DailyLimit(_json_)
            case 'MultiDayLimit': return new limit.MultiDayLimit(_json_)
            case 'WeeklyLimit': return new limit.WeeklyLimit(_json_)
            case 'MonthlyLimit': return new limit.MonthlyLimit(_json_)
            case 'CoolDown': return new limit.CoolDown(_json_)
            case 'GroupCoolDown': return new limit.GroupCoolDown(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace limit {

export  abstract  class DailyLimitBase  extends limit.LimitBase {
    static constructorFrom(_json_: any): DailyLimitBase {
        switch (_json_.__type__) {
            case 'DailyLimit': return new limit.DailyLimit(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class DailyLimit  extends limit.DailyLimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
    }

    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class MultiDayLimit  extends limit.LimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.day == null) { throw new Error() }
        this.day = _json_.day
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
    }

    readonly day: number
    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class WeeklyLimit  extends limit.LimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
    }

    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class MonthlyLimit  extends limit.LimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
    }

    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class CoolDown  extends limit.LimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.duration == null) { throw new Error() }
        this.duration = _json_.duration
    }

    readonly duration: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace limit {

export  class GroupCoolDown  extends limit.LimitBase {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.group_id == null) { throw new Error() }
        this.groupId = _json_.group_id
        if (_json_.duration == null) { throw new Error() }
        this.duration = _json_.duration
    }

    readonly groupId: number
    readonly duration: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}


   
export namespace error {
export class TbErrorInfo{
    private _dataMap: Map<string, error.ErrorInfo>
    private _dataList: error.ErrorInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<string, error.ErrorInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: error.ErrorInfo
            _v = new error.ErrorInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.code, _v)
        }
    }

    getDataMap(): Map<string, error.ErrorInfo> { return this._dataMap; }
    getDataList(): error.ErrorInfo[] { return this._dataList; }

    get(key: string): error.ErrorInfo  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace error {

export  class ErrorInfo  {

    constructor(_json_: any) {
        if (_json_.code == null) { throw new Error() }
        this.code = _json_.code
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.style == null) { throw new Error() }
        this.style = error.ErrorStyle.constructorFrom(_json_.style)
    }

    readonly code: string
    readonly desc: string
    readonly style: error.ErrorStyle

    resolve(_tables: Map<string, any>) {
        if (this.style != null) { this.style.resolve(_tables);}
    }
}

}





export namespace error {

export  abstract  class ErrorStyle  {
    static constructorFrom(_json_: any): ErrorStyle {
        switch (_json_.__type__) {
            case 'ErrorStyleTip': return new error.ErrorStyleTip(_json_)
            case 'ErrorStyleMsgbox': return new error.ErrorStyleMsgbox(_json_)
            case 'ErrorStyleDlgOk': return new error.ErrorStyleDlgOk(_json_)
            case 'ErrorStyleDlgOkCancel': return new error.ErrorStyleDlgOkCancel(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace error {

export  class ErrorStyleTip  extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace error {

export  class ErrorStyleMsgbox  extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn_name == null) { throw new Error() }
        this.btnName = _json_.btn_name
        if (_json_.operation == null) { throw new Error() }
        this.operation = _json_.operation
    }

    readonly btnName: string
    readonly operation: error.EOperation

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace error {

export  class ErrorStyleDlgOk  extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn_name == null) { throw new Error() }
        this.btnName = _json_.btn_name
    }

    readonly btnName: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace error {

export  class ErrorStyleDlgOkCancel  extends error.ErrorStyle {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.btn1_name == null) { throw new Error() }
        this.btn1Name = _json_.btn1_name
        if (_json_.btn2_name == null) { throw new Error() }
        this.btn2Name = _json_.btn2_name
    }

    readonly btn1Name: string
    readonly btn2Name: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}


   
export namespace error {
export class TbCodeInfo{
    private _dataMap: Map<error.EErrorCode, error.CodeInfo>
    private _dataList: error.CodeInfo[]
    constructor(_json_: any) {
        this._dataMap = new Map<error.EErrorCode, error.CodeInfo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: error.CodeInfo
            _v = new error.CodeInfo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.code, _v)
        }
    }

    getDataMap(): Map<error.EErrorCode, error.CodeInfo> { return this._dataMap; }
    getDataList(): error.CodeInfo[] { return this._dataList; }

    get(key: error.EErrorCode): error.CodeInfo  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace error {

export  class CodeInfo  {

    constructor(_json_: any) {
        if (_json_.code == null) { throw new Error() }
        this.code = _json_.code
        if (_json_.key == null) { throw new Error() }
        this.key = _json_.key
    }

    readonly code: error.EErrorCode
    readonly key: string

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace item {
export class TbItem{
    private _dataMap: Map<number, item.Item>
    private _dataList: item.Item[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, item.Item>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.Item
            _v = new item.Item(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, item.Item> { return this._dataMap; }
    getDataList(): item.Item[] { return this._dataList; }

    get(key: number): item.Item  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace item {

export  class Item  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.major_type == null) { throw new Error() }
        this.majorType = _json_.major_type
        if (_json_.minor_type == null) { throw new Error() }
        this.minorType = _json_.minor_type
        if (_json_.quality == null) { throw new Error() }
        this.quality = _json_.quality
        if (_json_.icon == null) { throw new Error() }
        this.icon = _json_.icon
        if (_json_.icon_backgroud == null) { throw new Error() }
        this.iconBackgroud = _json_.icon_backgroud
        if (_json_.icon_mask == null) { throw new Error() }
        this.iconMask = _json_.icon_mask
        if (_json_.desc == null) { throw new Error() }
        this.desc = _json_.desc
        if (_json_.show_order == null) { throw new Error() }
        this.showOrder = _json_.show_order
        if (_json_.quantifier == null) { throw new Error() }
        this.quantifier = _json_.quantifier
        if (_json_.show_in_bag == null) { throw new Error() }
        this.showInBag = _json_.show_in_bag
        if (_json_.min_show_level == null) { throw new Error() }
        this.minShowLevel = _json_.min_show_level
        if (_json_.batch_usable == null) { throw new Error() }
        this.batchUsable = _json_.batch_usable
        if (_json_.progress_time_when_use == null) { throw new Error() }
        this.progressTimeWhenUse = _json_.progress_time_when_use
        if (_json_.show_hint_when_use == null) { throw new Error() }
        this.showHintWhenUse = _json_.show_hint_when_use
        if (_json_.droppable == null) { throw new Error() }
        this.droppable = _json_.droppable
        if(_json_.price != null) { this.price = _json_.price } else { this.price = null }
        if (_json_.use_type == null) { throw new Error() }
        this.useType = _json_.use_type
        if(_json_.level_up_id != null) { this.levelUpId = _json_.level_up_id } else { this.levelUpId = null }
    }

    readonly id: number
    readonly name: string
    readonly majorType: item.EMajorType
    readonly minorType: item.EMinorType
    readonly quality: item.EItemQuality
    readonly icon: string
    readonly iconBackgroud: string
    readonly iconMask: string
    readonly desc: string
    readonly showOrder: number
    readonly quantifier: string
    readonly showInBag: boolean
    readonly minShowLevel: number
    readonly batchUsable: boolean
    readonly progressTimeWhenUse: number
    readonly showHintWhenUse: boolean
    readonly droppable: boolean
    readonly price?: number
    readonly useType: item.EUseType
    readonly levelUpId?: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace item {
export class TbItemFunc{
    private _dataMap: Map<item.EMinorType, item.ItemFunction>
    private _dataList: item.ItemFunction[]
    constructor(_json_: any) {
        this._dataMap = new Map<item.EMinorType, item.ItemFunction>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.ItemFunction
            _v = new item.ItemFunction(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.minorType, _v)
        }
    }

    getDataMap(): Map<item.EMinorType, item.ItemFunction> { return this._dataMap; }
    getDataList(): item.ItemFunction[] { return this._dataList; }

    get(key: item.EMinorType): item.ItemFunction  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace item {

export  class ItemFunction  {

    constructor(_json_: any) {
        if (_json_.minor_type == null) { throw new Error() }
        this.minorType = _json_.minor_type
        if (_json_.func_type == null) { throw new Error() }
        this.funcType = _json_.func_type
        if (_json_.method == null) { throw new Error() }
        this.method = _json_.method
        if (_json_.close_bag_ui == null) { throw new Error() }
        this.closeBagUi = _json_.close_bag_ui
    }

    readonly minorType: item.EMinorType
    readonly funcType: item.EItemFunctionType
    readonly method: string
    readonly closeBagUi: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace item {
export class TbItemExtra{
    private _dataMap: Map<number, item.ItemExtra>
    private _dataList: item.ItemExtra[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, item.ItemExtra>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: item.ItemExtra
            _v = item.ItemExtra.constructorFrom(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, item.ItemExtra> { return this._dataMap; }
    getDataList(): item.ItemExtra[] { return this._dataList; }

    get(key: number): item.ItemExtra  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace item {

export  abstract  class ItemExtra  {
    static constructorFrom(_json_: any): ItemExtra {
        switch (_json_.__type__) {
            case 'TreasureBox': return new item.TreasureBox(_json_)
            case 'InteractionItem': return new item.InteractionItem(_json_)
            case 'Clothes': return new item.Clothes(_json_)
            case 'DesignDrawing': return new item.DesignDrawing(_json_)
            case 'Dymmy': return new item.Dymmy(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
    }

    readonly id: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace item {

export  class TreasureBox  extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if(_json_.key_item_id != null) { this.keyItemId = _json_.key_item_id } else { this.keyItemId = null }
        if (_json_.open_level == null) { throw new Error() }
        this.openLevel = new condition.MinLevel(_json_.open_level)
        if (_json_.use_on_obtain == null) { throw new Error() }
        this.useOnObtain = _json_.use_on_obtain
        if (_json_.drop_ids == null) { throw new Error() }
        this.dropIds = _json_.drop_ids
        if (_json_.choose_list == null) { throw new Error() }
        { this.chooseList = []; for(let _ele of _json_.choose_list) { let _e : item.ChooseOneBonus; _e = new item.ChooseOneBonus(_ele); this.chooseList.push(_e);}}
    }

    readonly keyItemId?: number
    readonly openLevel: condition.MinLevel
    readonly useOnObtain: boolean
    readonly dropIds: number[]
    readonly chooseList: item.ChooseOneBonus[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.openLevel != null) { this.openLevel.resolve(_tables);}
        for(let _e of this.chooseList) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace condition {

export  abstract  class Condition  {
    static constructorFrom(_json_: any): Condition {
        switch (_json_.__type__) {
            case 'TimeRange': return new condition.TimeRange(_json_)
            case 'MultiRoleCondition': return new condition.MultiRoleCondition(_json_)
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            case 'ContainsItem': return new condition.ContainsItem(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace condition {

export  class TimeRange  extends condition.Condition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.date_time_range == null) { throw new Error() }
        this.dateTimeRange = new common.DateTimeRange(_json_.date_time_range)
    }

    readonly dateTimeRange: common.DateTimeRange

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.dateTimeRange != null) { this.dateTimeRange.resolve(_tables);}
    }
}

}





export namespace common {

export  class DateTimeRange  {

    constructor(_json_: any) {
        if(_json_.start_time != null) { this.startTime = _json_.start_time } else { this.startTime = null }
        if(_json_.end_time != null) { this.endTime = _json_.end_time } else { this.endTime = null }
    }

    readonly startTime?: number
    readonly endTime?: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace condition {

export  abstract  class RoleCondition  extends condition.Condition {
    static constructorFrom(_json_: any): RoleCondition {
        switch (_json_.__type__) {
            case 'MultiRoleCondition': return new condition.MultiRoleCondition(_json_)
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            case 'ContainsItem': return new condition.ContainsItem(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class MultiRoleCondition  extends condition.RoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.conditions == null) { throw new Error() }
        { this.conditions = []; for(let _ele of _json_.conditions) { let _e :condition.RoleCondition; _e = condition.RoleCondition.constructorFrom(_ele); this.conditions.push(_e);}}
    }

    readonly conditions: condition.RoleCondition[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.conditions) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace condition {

export  abstract  class BoolRoleCondition  extends condition.RoleCondition {
    static constructorFrom(_json_: any): BoolRoleCondition {
        switch (_json_.__type__) {
            case 'GenderLimit': return new condition.GenderLimit(_json_)
            case 'MinLevel': return new condition.MinLevel(_json_)
            case 'MaxLevel': return new condition.MaxLevel(_json_)
            case 'MinMaxLevel': return new condition.MinMaxLevel(_json_)
            case 'ClothesPropertyScoreGreaterThan': return new condition.ClothesPropertyScoreGreaterThan(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
    }


    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class GenderLimit  extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.gender == null) { throw new Error() }
        this.gender = _json_.gender
    }

    readonly gender: role.EGenderType

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class MinLevel  extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.level == null) { throw new Error() }
        this.level = _json_.level
    }

    readonly level: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class MaxLevel  extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.level == null) { throw new Error() }
        this.level = _json_.level
    }

    readonly level: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class MinMaxLevel  extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.min == null) { throw new Error() }
        this.min = _json_.min
        if (_json_.max == null) { throw new Error() }
        this.max = _json_.max
    }

    readonly min: number
    readonly max: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class ClothesPropertyScoreGreaterThan  extends condition.BoolRoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.prop == null) { throw new Error() }
        this.prop = _json_.prop
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly prop: item.EClothesPropertyType
    readonly value: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace condition {

export  class ContainsItem  extends condition.RoleCondition {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
        if (_json_.reverse == null) { throw new Error() }
        this.reverse = _json_.reverse
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly num: number
    readonly reverse: boolean

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace item {

export  class ChooseOneBonus  {

    constructor(_json_: any) {
        if (_json_.drop_id == null) { throw new Error() }
        this.dropId = _json_.drop_id
        if (_json_.is_unique == null) { throw new Error() }
        this.isUnique = _json_.is_unique
    }

    readonly dropId: number
    dropId_Ref : bonus.DropInfo
    readonly isUnique: boolean

    resolve(_tables: Map<string, any>) {
        this.dropId_Ref = (_tables.get('bonus.TbDrop') as bonus.TbDrop).get(this.dropId)
    }
}

}





export namespace item {

export  class InteractionItem  extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if(_json_.attack_num != null) { this.attackNum = _json_.attack_num } else { this.attackNum = null }
        if (_json_.holding_static_mesh == null) { throw new Error() }
        this.holdingStaticMesh = _json_.holding_static_mesh
        if (_json_.holding_static_mesh_mat == null) { throw new Error() }
        this.holdingStaticMeshMat = _json_.holding_static_mesh_mat
    }

    readonly attackNum?: number
    readonly holdingStaticMesh: string
    readonly holdingStaticMeshMat: string

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace item {

export  class Clothes  extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.attack == null) { throw new Error() }
        this.attack = _json_.attack
        if (_json_.hp == null) { throw new Error() }
        this.hp = _json_.hp
        if (_json_.energy_limit == null) { throw new Error() }
        this.energyLimit = _json_.energy_limit
        if (_json_.energy_resume == null) { throw new Error() }
        this.energyResume = _json_.energy_resume
    }

    readonly attack: number
    readonly hp: number
    readonly energyLimit: number
    readonly energyResume: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace item {

export  class DesignDrawing  extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.learn_component_id == null) { throw new Error() }
        this.learnComponentId = _json_.learn_component_id
    }

    readonly learnComponentId: number[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace item {

export  class Dymmy  extends item.ItemExtra {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.cost == null) { throw new Error() }
        this.cost = cost.Cost.constructorFrom(_json_.cost)
    }

    readonly cost: cost.Cost

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.cost != null) { this.cost.resolve(_tables);}
    }
}

}





export namespace cost {

export  abstract  class Cost  {
    static constructorFrom(_json_: any): Cost {
        switch (_json_.__type__) {
            case 'CostCurrency': return new cost.CostCurrency(_json_)
            case 'CostCurrencies': return new cost.CostCurrencies(_json_)
            case 'CostOneItem': return new cost.CostOneItem(_json_)
            case 'CostItem': return new cost.CostItem(_json_)
            case 'CostItems': return new cost.CostItems(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
    }


    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace cost {

export  class CostCurrency  extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.type == null) { throw new Error() }
        this.type = _json_.type
        if (_json_.num == null) { throw new Error() }
        this.num = _json_.num
    }

    readonly type: item.ECurrencyType
    readonly num: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace cost {

export  class CostCurrencies  extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.currencies == null) { throw new Error() }
        { this.currencies = []; for(let _ele of _json_.currencies) { let _e : cost.CostCurrency; _e = new cost.CostCurrency(_ele); this.currencies.push(_e);}}
    }

    readonly currencies: cost.CostCurrency[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.currencies) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace cost {

export  class CostOneItem  extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
    }

    readonly itemId: number
    itemId_Ref : item.Item

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace cost {

export  class CostItem  extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_id == null) { throw new Error() }
        this.itemId = _json_.item_id
        if (_json_.amount == null) { throw new Error() }
        this.amount = _json_.amount
    }

    readonly itemId: number
    itemId_Ref : item.Item
    readonly amount: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        this.itemId_Ref = (_tables.get('item.TbItem') as item.TbItem).get(this.itemId)
    }
}

}





export namespace cost {

export  class CostItems  extends cost.Cost {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.item_list == null) { throw new Error() }
        { this.itemList = []; for(let _ele of _json_.item_list) { let _e :cost.CostItem; _e = new cost.CostItem(_ele); this.itemList.push(_e);}}
    }

    readonly itemList: cost.CostItem[]

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        for(let _e of this.itemList) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}


   
export namespace l10n {
export class TbL10NDemo{
    private _dataMap: Map<number, l10n.L10NDemo>
    private _dataList: l10n.L10NDemo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, l10n.L10NDemo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: l10n.L10NDemo
            _v = new l10n.L10NDemo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, l10n.L10NDemo> { return this._dataMap; }
    getDataList(): l10n.L10NDemo[] { return this._dataList; }

    get(key: number): l10n.L10NDemo  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace l10n {

export  class L10NDemo  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.text == null) { throw new Error() }
        this.text = _json_.text
    }

    readonly id: number
    readonly text: string

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace l10n {
export class TbPatchDemo{
    private _dataMap: Map<number, l10n.PatchDemo>
    private _dataList: l10n.PatchDemo[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, l10n.PatchDemo>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: l10n.PatchDemo
            _v = new l10n.PatchDemo(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, l10n.PatchDemo> { return this._dataMap; }
    getDataList(): l10n.PatchDemo[] { return this._dataList; }

    get(key: number): l10n.PatchDemo  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace l10n {

export  class PatchDemo  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly id: number
    readonly value: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace mail {
export class TbSystemMail{
    private _dataMap: Map<number, mail.SystemMail>
    private _dataList: mail.SystemMail[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, mail.SystemMail>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: mail.SystemMail
            _v = new mail.SystemMail(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, mail.SystemMail> { return this._dataMap; }
    getDataList(): mail.SystemMail[] { return this._dataList; }

    get(key: number): mail.SystemMail  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace mail {

export  class SystemMail  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.title == null) { throw new Error() }
        this.title = _json_.title
        if (_json_.sender == null) { throw new Error() }
        this.sender = _json_.sender
        if (_json_.content == null) { throw new Error() }
        this.content = _json_.content
        if (_json_.award == null) { throw new Error() }
        this.award = _json_.award
    }

    readonly id: number
    readonly title: string
    readonly sender: string
    readonly content: string
    readonly award: number[]

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace mail {
export class TbGlobalMail{
    private _dataMap: Map<number, mail.GlobalMail>
    private _dataList: mail.GlobalMail[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, mail.GlobalMail>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: mail.GlobalMail
            _v = new mail.GlobalMail(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, mail.GlobalMail> { return this._dataMap; }
    getDataList(): mail.GlobalMail[] { return this._dataList; }

    get(key: number): mail.GlobalMail  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace mail {

export  class GlobalMail  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.title == null) { throw new Error() }
        this.title = _json_.title
        if (_json_.sender == null) { throw new Error() }
        this.sender = _json_.sender
        if (_json_.content == null) { throw new Error() }
        this.content = _json_.content
        if (_json_.award == null) { throw new Error() }
        this.award = _json_.award
        if (_json_.all_server == null) { throw new Error() }
        this.allServer = _json_.all_server
        if (_json_.server_list == null) { throw new Error() }
        this.serverList = _json_.server_list
        if (_json_.platform == null) { throw new Error() }
        this.platform = _json_.platform
        if (_json_.channel == null) { throw new Error() }
        this.channel = _json_.channel
        if (_json_.min_max_level == null) { throw new Error() }
        this.minMaxLevel = new condition.MinMaxLevel(_json_.min_max_level)
        if (_json_.register_time == null) { throw new Error() }
        this.registerTime = new condition.TimeRange(_json_.register_time)
        if (_json_.mail_time == null) { throw new Error() }
        this.mailTime = new condition.TimeRange(_json_.mail_time)
    }

    readonly id: number
    readonly title: string
    readonly sender: string
    readonly content: string
    readonly award: number[]
    readonly allServer: boolean
    readonly serverList: number[]
    readonly platform: string
    readonly channel: string
    readonly minMaxLevel: condition.MinMaxLevel
    readonly registerTime: condition.TimeRange
    readonly mailTime: condition.TimeRange

    resolve(_tables: Map<string, any>) {
        if (this.minMaxLevel != null) { this.minMaxLevel.resolve(_tables);}
        if (this.registerTime != null) { this.registerTime.resolve(_tables);}
        if (this.mailTime != null) { this.mailTime.resolve(_tables);}
    }
}

}


   
export namespace role {
export class TbRoleLevelExpAttr{
    private _dataMap: Map<number, role.LevelExpAttr>
    private _dataList: role.LevelExpAttr[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, role.LevelExpAttr>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: role.LevelExpAttr
            _v = new role.LevelExpAttr(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.level, _v)
        }
    }

    getDataMap(): Map<number, role.LevelExpAttr> { return this._dataMap; }
    getDataList(): role.LevelExpAttr[] { return this._dataList; }

    get(key: number): role.LevelExpAttr  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace role {

export  class LevelExpAttr  {

    constructor(_json_: any) {
        if (_json_.level == null) { throw new Error() }
        this.level = _json_.level
        if (_json_.need_exp == null) { throw new Error() }
        this.needExp = _json_.need_exp
        if (_json_.clothes_attrs == null) { throw new Error() }
        this.clothesAttrs = _json_.clothes_attrs
    }

    readonly level: number
    readonly needExp: number
    readonly clothesAttrs: number[]

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace role {
export class TbRoleLevelBonusCoefficient{
    private _dataMap: Map<number, role.LevelBonus>
    private _dataList: role.LevelBonus[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, role.LevelBonus>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: role.LevelBonus
            _v = new role.LevelBonus(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, role.LevelBonus> { return this._dataMap; }
    getDataList(): role.LevelBonus[] { return this._dataList; }

    get(key: number): role.LevelBonus  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace role {

export  class LevelBonus  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.distinct_bonus_infos == null) { throw new Error() }
        { this.distinctBonusInfos = []; for(let _ele of _json_.distinct_bonus_infos) { let _e : role.DistinctBonusInfos; _e = new role.DistinctBonusInfos(_ele); this.distinctBonusInfos.push(_e);}}
    }

    readonly id: number
    readonly distinctBonusInfos: role.DistinctBonusInfos[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.distinctBonusInfos) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace role {

export  class DistinctBonusInfos  {

    constructor(_json_: any) {
        if (_json_.effective_level == null) { throw new Error() }
        this.effectiveLevel = _json_.effective_level
        if (_json_.bonus_info == null) { throw new Error() }
        { this.bonusInfo = []; for(let _ele of _json_.bonus_info) { let _e : role.BonusInfo; _e = new role.BonusInfo(_ele); this.bonusInfo.push(_e);}}
    }

    readonly effectiveLevel: number
    readonly bonusInfo: role.BonusInfo[]

    resolve(_tables: Map<string, any>) {
        for(let _e of this.bonusInfo) { if (_e != null ) {_e.resolve(_tables);} }
    }
}

}





export namespace role {

export  class BonusInfo  {

    constructor(_json_: any) {
        if (_json_.type == null) { throw new Error() }
        this.type = _json_.type
        if (_json_.coefficient == null) { throw new Error() }
        this.coefficient = _json_.coefficient
    }

    readonly type: item.ECurrencyType
    readonly coefficient: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace tag {
export class TbTestTag{
    private _dataMap: Map<number, tag.TestTag>
    private _dataList: tag.TestTag[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, tag.TestTag>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: tag.TestTag
            _v = new tag.TestTag(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, tag.TestTag> { return this._dataMap; }
    getDataList(): tag.TestTag[] { return this._dataList; }

    get(key: number): tag.TestTag  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace tag {

export  class TestTag  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.value == null) { throw new Error() }
        this.value = _json_.value
    }

    readonly id: number
    readonly value: string

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbFullTypes{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x3, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class DemoType2  {

    constructor(_json_: any) {
        if (_json_.x4 == null) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 == null) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 == null) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x5 == null) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 == null) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x7 == null) { throw new Error() }
        this.x7 = _json_.x7
        if (_json_.x8_0 == null) { throw new Error() }
        this.x80 = _json_.x8_0
        if (_json_.x8 == null) { throw new Error() }
        this.x8 = _json_.x8
        if (_json_.x9 == null) { throw new Error() }
        this.x9 = _json_.x9
        if (_json_.x10 == null) { throw new Error() }
        this.x10 = _json_.x10
        if (_json_.x12 == null) { throw new Error() }
        this.x12 = new test.DemoType1(_json_.x12)
        if (_json_.x13 == null) { throw new Error() }
        this.x13 = _json_.x13
        if (_json_.x14 == null) { throw new Error() }
        this.x14 = test.DemoDynamic.constructorFrom(_json_.x14)
        if (_json_.s1 == null) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.v2 == null) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 == null) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 == null) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
        if (_json_.t1 == null) { throw new Error() }
        this.t1 = _json_.t1
        if (_json_.k1 == null) { throw new Error() }
        this.k1 = _json_.k1
        if (_json_.k2 == null) { throw new Error() }
        this.k2 = _json_.k2
        if (_json_.k3 == null) { throw new Error() }
        this.k3 = _json_.k3
        if (_json_.k4 == null) { throw new Error() }
        this.k4 = _json_.k4
        if (_json_.k5 == null) { throw new Error() }
        this.k5 = _json_.k5
        if (_json_.k6 == null) { throw new Error() }
        this.k6 = _json_.k6
        if (_json_.k7 == null) { throw new Error() }
        this.k7 = _json_.k7
        if (_json_.k8 == null) { throw new Error() }
        this.k8 = new Map<number, number>(); for(var _entry_ of _json_.k8) { let _k:number; _k = _entry_[0];  let _v:number;  _v = _entry_[1]; this.k8.set(_k, _v);  }
        if (_json_.k9 == null) { throw new Error() }
        { this.k9 = []; for(let _ele of _json_.k9) { let _e : test.DemoE2; _e = new test.DemoE2(_ele); this.k9.push(_e);}}
        if (_json_.k15 == null) { throw new Error() }
        { this.k15 = []; for(let _ele of _json_.k15) { let _e :test.DemoDynamic; _e = test.DemoDynamic.constructorFrom(_ele); this.k15.push(_e);}}
    }

    readonly x4: number
    readonly x1: boolean
    readonly x2: number
    readonly x3: number
    x3_Ref : test.DemoType2
    readonly x5: number
    readonly x6: number
    readonly x7: number
    readonly x80: number
    readonly x8: number
    readonly x9: bigint
    readonly x10: string
    readonly x12: test.DemoType1
    readonly x13: test.DemoEnum
    readonly x14: test.DemoDynamic
    readonly s1: string
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4
    readonly t1: number
    readonly k1: Int32Array
    readonly k2: number[]
    readonly k3: number[]
    readonly k4: number[]
    readonly k5: Set<number>
    readonly k6: Set<number>
    readonly k7: Set<number>
    readonly k8: Map<number, number>
    readonly k9: test.DemoE2[]
    readonly k15: test.DemoDynamic[]

    resolve(_tables: Map<string, any>) {
        this.x3_Ref = (_tables.get('test.TbFullTypes') as test.TbFullTypes).get(this.x3)
        if (this.x12 != null) { this.x12.resolve(_tables);}
        if (this.x14 != null) { this.x14.resolve(_tables);}
        for(let _e of this.k9) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.k15) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace test {

export  class DemoType1  {

    constructor(_json_: any) {
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = _json_.x1
    }

    readonly x1: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace test {

export  abstract  class DemoDynamic  {
    static constructorFrom(_json_: any): DemoDynamic {
        switch (_json_.__type__) {
            case 'DemoD2': return new test.DemoD2(_json_)
            case 'DemoE1': return new test.DemoE1(_json_)
            case 'DemoD5': return new test.DemoD5(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = _json_.x1
    }

    readonly x1: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace test {

export  class DemoD2  extends test.DemoDynamic {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x2 == null) { throw new Error() }
        this.x2 = _json_.x2
    }

    readonly x2: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace test {

export  abstract  class DemoD3  extends test.DemoDynamic {
    static constructorFrom(_json_: any): DemoD3 {
        switch (_json_.__type__) {
            case 'DemoE1': return new test.DemoE1(_json_)
            default: throw new Error()
        }
    }

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x3 == null) { throw new Error() }
        this.x3 = _json_.x3
    }

    readonly x3: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace test {

export  class DemoE1  extends test.DemoD3 {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.x4 == null) { throw new Error() }
        this.x4 = _json_.x4
    }

    readonly x4: number

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
    }
}

}





export namespace test {

export  class DemoD5  extends test.DemoDynamic {

    constructor(_json_: any) {
        super(_json_)
        if (_json_.time == null) { throw new Error() }
        this.time = new test.DateTimeRange(_json_.time)
    }

    readonly time: test.DateTimeRange

    resolve(_tables: Map<string, any>) {
        super.resolve(_tables)
        if (this.time != null) { this.time.resolve(_tables);}
    }
}

}





export namespace test {

export  class DateTimeRange  {

    constructor(_json_: any) {
        if (_json_.start_time == null) { throw new Error() }
        this.startTime = _json_.start_time
        if (_json_.end_time == null) { throw new Error() }
        this.endTime = _json_.end_time
    }

    readonly startTime: number
    readonly endTime: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace test {

export  class DemoE2  {

    constructor(_json_: any) {
        if(_json_.y1 != null) { this.y1 = _json_.y1 } else { this.y1 = null }
        if (_json_.y2 == null) { throw new Error() }
        this.y2 = _json_.y2
    }

    readonly y1?: number
    readonly y2: boolean

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbSingleton{

     private _data: test.DemoSingletonType
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.DemoSingletonType(_json_[0])
    }

    getData(): test.DemoSingletonType { return this._data; }

     get  id(): number { return this._data.id; }
     get  name(): string { return this._data.name; }
     get  date(): test.DemoDynamic { return this._data.date; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}





export namespace test {

export  class DemoSingletonType  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.date == null) { throw new Error() }
        this.date = test.DemoDynamic.constructorFrom(_json_.date)
    }

    readonly id: number
    readonly name: string
    readonly date: test.DemoDynamic

    resolve(_tables: Map<string, any>) {
        if (this.date != null) { this.date.resolve(_tables);}
    }
}

}


   
export namespace test {
export class TbDataFromJson{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}


   
export namespace test {
export class TbDataFromXml{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}


   
export namespace test {
export class TbDataFromLua{
    private _dataMap: Map<number, test.DemoType2>
    private _dataList: test.DemoType2[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoType2>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoType2
            _v = new test.DemoType2(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoType2> { return this._dataMap; }
    getDataList(): test.DemoType2[] { return this._dataList; }

    get(key: number): test.DemoType2  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}


   
export namespace test {
export class TbMultiRowRecord{
    private _dataMap: Map<number, test.MultiRowRecord>
    private _dataList: test.MultiRowRecord[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.MultiRowRecord>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiRowRecord
            _v = new test.MultiRowRecord(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.MultiRowRecord> { return this._dataMap; }
    getDataList(): test.MultiRowRecord[] { return this._dataList; }

    get(key: number): test.MultiRowRecord  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class MultiRowRecord  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.one_rows == null) { throw new Error() }
        { this.oneRows = []; for(let _ele of _json_.one_rows) { let _e : test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.oneRows.push(_e);}}
        if (_json_.multi_rows1 == null) { throw new Error() }
        { this.multiRows1 = []; for(let _ele of _json_.multi_rows1) { let _e : test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.multiRows1.push(_e);}}
        if (_json_.multi_rows2 == null) { throw new Error() }
        { this.multiRows2 = []; for(let _ele of _json_.multi_rows2) { let _e :test.MultiRowType1; _e = new test.MultiRowType1(_ele); this.multiRows2.push(_e);}}
        if (_json_.multi_rows3 == null) { throw new Error() }
        { this.multiRows3 = new Set<test.MultiRowType2>(); for(var _ele of _json_.multi_rows3) { let _e:test.MultiRowType2; _e = new test.MultiRowType2(_ele); this.multiRows3.add(_e);}}
        if (_json_.multi_rows4 == null) { throw new Error() }
        this.multiRows4 = new Map<number, test.MultiRowType2>(); for(var _entry_ of _json_.multi_rows4) { let _k:number; _k = _entry_[0];  let _v:test.MultiRowType2;  _v = new test.MultiRowType2(_entry_[1]); this.multiRows4.set(_k, _v);  }
    }

    readonly id: number
    readonly name: string
    readonly oneRows: test.MultiRowType1[]
    readonly multiRows1: test.MultiRowType1[]
    readonly multiRows2: test.MultiRowType1[]
    readonly multiRows3: Set<test.MultiRowType2>
    readonly multiRows4: Map<number, test.MultiRowType2>

    resolve(_tables: Map<string, any>) {
        for(let _e of this.oneRows) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.multiRows1) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.multiRows2) { if (_e != null) { _e.resolve(_tables); } }
        for(let _e of this.multiRows4.values()) { if (_e != null) {_e.resolve(_tables);} }
    }
}

}





export namespace test {

export  class MultiRowType1  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.x == null) { throw new Error() }
        this.x = _json_.x
    }

    readonly id: number
    readonly x: number

    resolve(_tables: Map<string, any>) {
    }
}

}





export namespace test {

export  class MultiRowType2  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.x == null) { throw new Error() }
        this.x = _json_.x
        if (_json_.y == null) { throw new Error() }
        this.y = _json_.y
    }

    readonly id: number
    readonly x: number
    readonly y: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbMultiRowTitle{
    private _dataMap: Map<number, test.MultiRowTitle>
    private _dataList: test.MultiRowTitle[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.MultiRowTitle>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.MultiRowTitle
            _v = new test.MultiRowTitle(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.MultiRowTitle> { return this._dataMap; }
    getDataList(): test.MultiRowTitle[] { return this._dataList; }

    get(key: number): test.MultiRowTitle  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class MultiRowTitle  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.name == null) { throw new Error() }
        this.name = _json_.name
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = new test.H1(_json_.x1)
        if (_json_.x2 == null) { throw new Error() }
        { this.x2 = []; for(let _ele of _json_.x2) { let _e : test.H2; _e = new test.H2(_ele); this.x2.push(_e);}}
        if (_json_.x3 == null) { throw new Error() }
        { this.x3 = []; for(let _ele of _json_.x3) { let _e :test.H2; _e = new test.H2(_ele); this.x3.push(_e);}}
    }

    readonly id: number
    readonly name: string
    readonly x1: test.H1
    readonly x2: test.H2[]
    readonly x3: test.H2[]

    resolve(_tables: Map<string, any>) {
        if (this.x1 != null) { this.x1.resolve(_tables);}
        for(let _e of this.x2) { if (_e != null ) {_e.resolve(_tables);} }
        for(let _e of this.x3) { if (_e != null) { _e.resolve(_tables); } }
    }
}

}





export namespace test {

export  class H1  {

    constructor(_json_: any) {
        if (_json_.y2 == null) { throw new Error() }
        this.y2 = new test.H2(_json_.y2)
        if (_json_.y3 == null) { throw new Error() }
        this.y3 = _json_.y3
    }

    readonly y2: test.H2
    readonly y3: number

    resolve(_tables: Map<string, any>) {
        if (this.y2 != null) { this.y2.resolve(_tables);}
    }
}

}





export namespace test {

export  class H2  {

    constructor(_json_: any) {
        if (_json_.z2 == null) { throw new Error() }
        this.z2 = _json_.z2
        if (_json_.z3 == null) { throw new Error() }
        this.z3 = _json_.z3
    }

    readonly z2: number
    readonly z3: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbTestNull{
    private _dataMap: Map<number, test.TestNull>
    private _dataList: test.TestNull[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestNull>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestNull
            _v = new test.TestNull(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestNull> { return this._dataMap; }
    getDataList(): test.TestNull[] { return this._dataList; }

    get(key: number): test.TestNull  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class TestNull  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if(_json_.x1 != null) { this.x1 = _json_.x1 } else { this.x1 = null }
        if(_json_.x2 != null) { this.x2 = _json_.x2 } else { this.x2 = null }
        if(_json_.x3 != null) { this.x3 = new test.DemoType1(_json_.x3) } else { this.x3 = null }
        if(_json_.x4 != null) { this.x4 = test.DemoDynamic.constructorFrom(_json_.x4) } else { this.x4 = null }
        if(_json_.s1 != null) { this.s1 = _json_.s1 } else { this.s1 = null }
        if(_json_.s2 != null) { this.s2 = _json_.s2 } else { this.s2 = null }
    }

    readonly id: number
    readonly x1?: number
    readonly x2?: test.DemoEnum
    readonly x3?: test.DemoType1
    readonly x4?: test.DemoDynamic
    readonly s1?: string
    readonly s2?: string

    resolve(_tables: Map<string, any>) {
        if (this.x3 != null) { this.x3.resolve(_tables);}
        if (this.x4 != null) { this.x4.resolve(_tables);}
    }
}

}


   
export namespace test {
export class TbDemoPrimitive{
    private _dataMap: Map<number, test.DemoPrimitiveTypesTable>
    private _dataList: test.DemoPrimitiveTypesTable[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoPrimitiveTypesTable>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoPrimitiveTypesTable
            _v = new test.DemoPrimitiveTypesTable(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.x4, _v)
        }
    }

    getDataMap(): Map<number, test.DemoPrimitiveTypesTable> { return this._dataMap; }
    getDataList(): test.DemoPrimitiveTypesTable[] { return this._dataList; }

    get(key: number): test.DemoPrimitiveTypesTable  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class DemoPrimitiveTypesTable  {

    constructor(_json_: any) {
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 == null) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x3 == null) { throw new Error() }
        this.x3 = _json_.x3
        if (_json_.x4 == null) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x5 == null) { throw new Error() }
        this.x5 = _json_.x5
        if (_json_.x6 == null) { throw new Error() }
        this.x6 = _json_.x6
        if (_json_.x7 == null) { throw new Error() }
        this.x7 = _json_.x7
        if (_json_.s1 == null) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.s2 == null) { throw new Error() }
        this.s2 = _json_.s2
        if (_json_.v2 == null) { throw new Error() }
        this.v2 = Vector2.deserializeFromJson(_json_.v2)
        if (_json_.v3 == null) { throw new Error() }
        this.v3 = Vector3.deserializeFromJson(_json_.v3)
        if (_json_.v4 == null) { throw new Error() }
        this.v4 = Vector4.deserializeFromJson(_json_.v4)
        if (_json_.t1 == null) { throw new Error() }
        this.t1 = _json_.t1
    }

    readonly x1: boolean
    readonly x2: number
    readonly x3: number
    readonly x4: number
    readonly x5: number
    readonly x6: number
    readonly x7: number
    readonly s1: string
    readonly s2: string
    readonly v2: Vector2
    readonly v3: Vector3
    readonly v4: Vector4
    readonly t1: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbTestString{
    private _dataMap: Map<number, test.TestString>
    private _dataList: test.TestString[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.TestString>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.TestString
            _v = new test.TestString(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.TestString> { return this._dataMap; }
    getDataList(): test.TestString[] { return this._dataList; }

    get(key: number): test.TestString  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class TestString  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.s1 == null) { throw new Error() }
        this.s1 = _json_.s1
        if (_json_.cs1 == null) { throw new Error() }
        this.cs1 = new test.CompactString(_json_.cs1)
        if (_json_.cs2 == null) { throw new Error() }
        this.cs2 = new test.CompactString(_json_.cs2)
    }

    readonly id: number
    readonly s1: string
    readonly cs1: test.CompactString
    readonly cs2: test.CompactString

    resolve(_tables: Map<string, any>) {
        if (this.cs1 != null) { this.cs1.resolve(_tables);}
        if (this.cs2 != null) { this.cs2.resolve(_tables);}
    }
}

}





export namespace test {

export  class CompactString  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.s2 == null) { throw new Error() }
        this.s2 = _json_.s2
        if (_json_.s3 == null) { throw new Error() }
        this.s3 = _json_.s3
    }

    readonly id: number
    readonly s2: string
    readonly s3: string

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbDemoGroup{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}





export namespace test {

export  class DemoGroup  {

    constructor(_json_: any) {
        if (_json_.id == null) { throw new Error() }
        this.id = _json_.id
        if (_json_.x1 == null) { throw new Error() }
        this.x1 = _json_.x1
        if (_json_.x2 == null) { throw new Error() }
        this.x2 = _json_.x2
        if (_json_.x4 == null) { throw new Error() }
        this.x4 = _json_.x4
        if (_json_.x5 == null) { throw new Error() }
        this.x5 = new test.InnerGroup(_json_.x5)
    }

    readonly id: number
    readonly x1: number
    readonly x2: number
    readonly x4: number
    readonly x5: test.InnerGroup

    resolve(_tables: Map<string, any>) {
        if (this.x5 != null) { this.x5.resolve(_tables);}
    }
}

}





export namespace test {

export  class InnerGroup  {

    constructor(_json_: any) {
        if (_json_.y1 == null) { throw new Error() }
        this.y1 = _json_.y1
        if (_json_.y2 == null) { throw new Error() }
        this.y2 = _json_.y2
        if (_json_.y4 == null) { throw new Error() }
        this.y4 = _json_.y4
    }

    readonly y1: number
    readonly y2: number
    readonly y4: number

    resolve(_tables: Map<string, any>) {
    }
}

}


   
export namespace test {
export class TbDemoGroup_C{
    private _dataMap: Map<number, test.DemoGroup>
    private _dataList: test.DemoGroup[]
    constructor(_json_: any) {
        this._dataMap = new Map<number, test.DemoGroup>()
        this._dataList = []
        for(var _json2_ of _json_) {
            let _v: test.DemoGroup
            _v = new test.DemoGroup(_json2_)
            this._dataList.push(_v)
            this._dataMap.set(_v.id, _v)
        }
    }

    getDataMap(): Map<number, test.DemoGroup> { return this._dataMap; }
    getDataList(): test.DemoGroup[] { return this._dataList; }

    get(key: number): test.DemoGroup  { return this._dataMap.get(key); }

    resolve(_tables: Map<string, any>) {
        for(var v of this._dataList) {
            v.resolve(_tables)
        }
    }


}
}


   
export namespace test {
export class TbTestGlobal{

     private _data: test.TestGlobal
    constructor(_json_: any) {
        if (_json_.length != 1) throw new Error('table mode=one, but size != 1')
        this._data = new test.TestGlobal(_json_[0])
    }

    getData(): test.TestGlobal { return this._data; }

     get  unlockEquip(): number { return this._data.unlockEquip; }
     get  unlockHero(): number { return this._data.unlockHero; }

    resolve(_tables: Map<string, any>) {
        this._data.resolve(_tables)
    }

    
}
}





export namespace test {

export  class TestGlobal  {

    constructor(_json_: any) {
        if (_json_.unlock_equip == null) { throw new Error() }
        this.unlockEquip = _json_.unlock_equip
        if (_json_.unlock_hero == null) { throw new Error() }
        this.unlockHero = _json_.unlock_hero
    }

    readonly unlockEquip: number
    readonly unlockHero: number

    resolve(_tables: Map<string, any>) {
    }
}

}




type JsonLoader = (file: string) => any

export class Tables {
    private _TbBlackboard: ai.TbBlackboard
    get TbBlackboard(): ai.TbBlackboard  { return this._TbBlackboard;}
    private _TbBehaviorTree: ai.TbBehaviorTree
    get TbBehaviorTree(): ai.TbBehaviorTree  { return this._TbBehaviorTree;}
    private _TbClazz: blueprint.TbClazz
    get TbClazz(): blueprint.TbClazz  { return this._TbClazz;}
    private _TbDrop: bonus.TbDrop
    get TbDrop(): bonus.TbDrop  { return this._TbDrop;}
    private _TbGlobalConfig: common.TbGlobalConfig
    get TbGlobalConfig(): common.TbGlobalConfig  { return this._TbGlobalConfig;}
    private _TbDummy: common.TbDummy
    get TbDummy(): common.TbDummy  { return this._TbDummy;}
    private _TbErrorInfo: error.TbErrorInfo
    get TbErrorInfo(): error.TbErrorInfo  { return this._TbErrorInfo;}
    private _TbCodeInfo: error.TbCodeInfo
    get TbCodeInfo(): error.TbCodeInfo  { return this._TbCodeInfo;}
    private _TbItem: item.TbItem
    get TbItem(): item.TbItem  { return this._TbItem;}
    private _TbItemFunc: item.TbItemFunc
    get TbItemFunc(): item.TbItemFunc  { return this._TbItemFunc;}
    private _TbItemExtra: item.TbItemExtra
    get TbItemExtra(): item.TbItemExtra  { return this._TbItemExtra;}
    private _TbL10NDemo: l10n.TbL10NDemo
    get TbL10NDemo(): l10n.TbL10NDemo  { return this._TbL10NDemo;}
    private _TbPatchDemo: l10n.TbPatchDemo
    get TbPatchDemo(): l10n.TbPatchDemo  { return this._TbPatchDemo;}
    private _TbSystemMail: mail.TbSystemMail
    get TbSystemMail(): mail.TbSystemMail  { return this._TbSystemMail;}
    private _TbGlobalMail: mail.TbGlobalMail
    get TbGlobalMail(): mail.TbGlobalMail  { return this._TbGlobalMail;}
    private _TbRoleLevelExpAttr: role.TbRoleLevelExpAttr
    get TbRoleLevelExpAttr(): role.TbRoleLevelExpAttr  { return this._TbRoleLevelExpAttr;}
    private _TbRoleLevelBonusCoefficient: role.TbRoleLevelBonusCoefficient
    get TbRoleLevelBonusCoefficient(): role.TbRoleLevelBonusCoefficient  { return this._TbRoleLevelBonusCoefficient;}
    private _TbTestTag: tag.TbTestTag
    get TbTestTag(): tag.TbTestTag  { return this._TbTestTag;}
    private _TbFullTypes: test.TbFullTypes
    get TbFullTypes(): test.TbFullTypes  { return this._TbFullTypes;}
    private _TbSingleton: test.TbSingleton
    get TbSingleton(): test.TbSingleton  { return this._TbSingleton;}
    private _TbDataFromJson: test.TbDataFromJson
    get TbDataFromJson(): test.TbDataFromJson  { return this._TbDataFromJson;}
    private _TbDataFromXml: test.TbDataFromXml
    get TbDataFromXml(): test.TbDataFromXml  { return this._TbDataFromXml;}
    private _TbDataFromLua: test.TbDataFromLua
    get TbDataFromLua(): test.TbDataFromLua  { return this._TbDataFromLua;}
    private _TbMultiRowRecord: test.TbMultiRowRecord
    get TbMultiRowRecord(): test.TbMultiRowRecord  { return this._TbMultiRowRecord;}
    private _TbMultiRowTitle: test.TbMultiRowTitle
    get TbMultiRowTitle(): test.TbMultiRowTitle  { return this._TbMultiRowTitle;}
    private _TbTestNull: test.TbTestNull
    get TbTestNull(): test.TbTestNull  { return this._TbTestNull;}
    private _TbDemoPrimitive: test.TbDemoPrimitive
    get TbDemoPrimitive(): test.TbDemoPrimitive  { return this._TbDemoPrimitive;}
    private _TbTestString: test.TbTestString
    get TbTestString(): test.TbTestString  { return this._TbTestString;}
    private _TbDemoGroup: test.TbDemoGroup
    get TbDemoGroup(): test.TbDemoGroup  { return this._TbDemoGroup;}
    private _TbDemoGroup_C: test.TbDemoGroup_C
    get TbDemoGroup_C(): test.TbDemoGroup_C  { return this._TbDemoGroup_C;}
    private _TbTestGlobal: test.TbTestGlobal
    get TbTestGlobal(): test.TbTestGlobal  { return this._TbTestGlobal;}

    constructor(loader: JsonLoader) {
        let tables = new Map<string, any>()
        this._TbBlackboard = new ai.TbBlackboard(loader('ai.TbBlackboard'))
        tables.set('ai.TbBlackboard', this._TbBlackboard)
        this._TbBehaviorTree = new ai.TbBehaviorTree(loader('ai.TbBehaviorTree'))
        tables.set('ai.TbBehaviorTree', this._TbBehaviorTree)
        this._TbClazz = new blueprint.TbClazz(loader('blueprint.TbClazz'))
        tables.set('blueprint.TbClazz', this._TbClazz)
        this._TbDrop = new bonus.TbDrop(loader('bonus.TbDrop'))
        tables.set('bonus.TbDrop', this._TbDrop)
        this._TbGlobalConfig = new common.TbGlobalConfig(loader('common.TbGlobalConfig'))
        tables.set('common.TbGlobalConfig', this._TbGlobalConfig)
        this._TbDummy = new common.TbDummy(loader('common.TbDummy'))
        tables.set('common.TbDummy', this._TbDummy)
        this._TbErrorInfo = new error.TbErrorInfo(loader('error.TbErrorInfo'))
        tables.set('error.TbErrorInfo', this._TbErrorInfo)
        this._TbCodeInfo = new error.TbCodeInfo(loader('error.TbCodeInfo'))
        tables.set('error.TbCodeInfo', this._TbCodeInfo)
        this._TbItem = new item.TbItem(loader('item.TbItem'))
        tables.set('item.TbItem', this._TbItem)
        this._TbItemFunc = new item.TbItemFunc(loader('item.TbItemFunc'))
        tables.set('item.TbItemFunc', this._TbItemFunc)
        this._TbItemExtra = new item.TbItemExtra(loader('item.TbItemExtra'))
        tables.set('item.TbItemExtra', this._TbItemExtra)
        this._TbL10NDemo = new l10n.TbL10NDemo(loader('l10n.TbL10NDemo'))
        tables.set('l10n.TbL10NDemo', this._TbL10NDemo)
        this._TbPatchDemo = new l10n.TbPatchDemo(loader('l10n.TbPatchDemo'))
        tables.set('l10n.TbPatchDemo', this._TbPatchDemo)
        this._TbSystemMail = new mail.TbSystemMail(loader('mail.TbSystemMail'))
        tables.set('mail.TbSystemMail', this._TbSystemMail)
        this._TbGlobalMail = new mail.TbGlobalMail(loader('mail.TbGlobalMail'))
        tables.set('mail.TbGlobalMail', this._TbGlobalMail)
        this._TbRoleLevelExpAttr = new role.TbRoleLevelExpAttr(loader('role.TbRoleLevelExpAttr'))
        tables.set('role.TbRoleLevelExpAttr', this._TbRoleLevelExpAttr)
        this._TbRoleLevelBonusCoefficient = new role.TbRoleLevelBonusCoefficient(loader('role.TbRoleLevelBonusCoefficient'))
        tables.set('role.TbRoleLevelBonusCoefficient', this._TbRoleLevelBonusCoefficient)
        this._TbTestTag = new tag.TbTestTag(loader('tag.TbTestTag'))
        tables.set('tag.TbTestTag', this._TbTestTag)
        this._TbFullTypes = new test.TbFullTypes(loader('test.TbFullTypes'))
        tables.set('test.TbFullTypes', this._TbFullTypes)
        this._TbSingleton = new test.TbSingleton(loader('test.TbSingleton'))
        tables.set('test.TbSingleton', this._TbSingleton)
        this._TbDataFromJson = new test.TbDataFromJson(loader('test.TbDataFromJson'))
        tables.set('test.TbDataFromJson', this._TbDataFromJson)
        this._TbDataFromXml = new test.TbDataFromXml(loader('test.TbDataFromXml'))
        tables.set('test.TbDataFromXml', this._TbDataFromXml)
        this._TbDataFromLua = new test.TbDataFromLua(loader('test.TbDataFromLua'))
        tables.set('test.TbDataFromLua', this._TbDataFromLua)
        this._TbMultiRowRecord = new test.TbMultiRowRecord(loader('test.TbMultiRowRecord'))
        tables.set('test.TbMultiRowRecord', this._TbMultiRowRecord)
        this._TbMultiRowTitle = new test.TbMultiRowTitle(loader('test.TbMultiRowTitle'))
        tables.set('test.TbMultiRowTitle', this._TbMultiRowTitle)
        this._TbTestNull = new test.TbTestNull(loader('test.TbTestNull'))
        tables.set('test.TbTestNull', this._TbTestNull)
        this._TbDemoPrimitive = new test.TbDemoPrimitive(loader('test.TbDemoPrimitive'))
        tables.set('test.TbDemoPrimitive', this._TbDemoPrimitive)
        this._TbTestString = new test.TbTestString(loader('test.TbTestString'))
        tables.set('test.TbTestString', this._TbTestString)
        this._TbDemoGroup = new test.TbDemoGroup(loader('test.TbDemoGroup'))
        tables.set('test.TbDemoGroup', this._TbDemoGroup)
        this._TbDemoGroup_C = new test.TbDemoGroup_C(loader('test.TbDemoGroup_C'))
        tables.set('test.TbDemoGroup_C', this._TbDemoGroup_C)
        this._TbTestGlobal = new test.TbTestGlobal(loader('test.TbTestGlobal'))
        tables.set('test.TbTestGlobal', this._TbTestGlobal)

        this._TbBlackboard.resolve(tables)
        this._TbBehaviorTree.resolve(tables)
        this._TbClazz.resolve(tables)
        this._TbDrop.resolve(tables)
        this._TbGlobalConfig.resolve(tables)
        this._TbDummy.resolve(tables)
        this._TbErrorInfo.resolve(tables)
        this._TbCodeInfo.resolve(tables)
        this._TbItem.resolve(tables)
        this._TbItemFunc.resolve(tables)
        this._TbItemExtra.resolve(tables)
        this._TbL10NDemo.resolve(tables)
        this._TbPatchDemo.resolve(tables)
        this._TbSystemMail.resolve(tables)
        this._TbGlobalMail.resolve(tables)
        this._TbRoleLevelExpAttr.resolve(tables)
        this._TbRoleLevelBonusCoefficient.resolve(tables)
        this._TbTestTag.resolve(tables)
        this._TbFullTypes.resolve(tables)
        this._TbSingleton.resolve(tables)
        this._TbDataFromJson.resolve(tables)
        this._TbDataFromXml.resolve(tables)
        this._TbDataFromLua.resolve(tables)
        this._TbMultiRowRecord.resolve(tables)
        this._TbMultiRowTitle.resolve(tables)
        this._TbTestNull.resolve(tables)
        this._TbDemoPrimitive.resolve(tables)
        this._TbTestString.resolve(tables)
        this._TbDemoGroup.resolve(tables)
        this._TbDemoGroup_C.resolve(tables)
        this._TbTestGlobal.resolve(tables)
    }
}


}